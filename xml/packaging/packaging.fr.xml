<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">
<document filename="index" lang="fr" >
<title>Création de paquets Fink</title>
<shorttitle>Paquets</shorttitle>
<cvsid>$Id: packaging.fr.xml,v 1.89 2024/12/20 6:46:11 nieder Exp $</cvsid>
<preface>
<p>Ce document explique comment créer des descriptions de paquets pour le gestionnaire de paquets de Fink. Il fournit aussi des règles et un fil conducteur pour la distribution Fink. Le format des fichiers de description et les règles de distribution sont en constante évolution. Il faut donc regarder en bas de page la ligne "Dernière mise à jour..." et la balise cvs pour détecter les changements. Les informations contenues dans ce document correspondent à la description du format et des règles utilisées dans les versions de développement postérieures à la version 0.9.0 du gestionnaire de paquets <tt>fink</tt>.</p>
<p>Si vous créez des paquets pour Fink, vous avez tout intérêt à vous abonner à la liste de diffusion <link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link>. Si vous cherchez un moyen d'aider Fink et que vous avez des compétences dans ce domaine, vous pouvez aussi adopter un <link url="http://pdb.finkproject.org/pdb/nomaintainer.php">paquet sans mainteneur</link>.</p>
</preface>
<chapter filename="intro">
<title>Introduction</title>
<shorttitle>Intro</shorttitle>
<section name="def1"><title>Qu'est-ce qu'un paquet ?</title>
<p>Un paquet est un logiciel qui forme une unité atomique. Un paquet contient en général un programme exécutable, les fichiers de données dont il a besoin et des catalogues de message pour l'internationalisation et la documentation. Dans Fink, les paquets peuvent exister sous deux formes : la description de paquet et le paquet binaire prêt à installer.</p>
<p>La description de paquet est un fichier texte compréhensible par un être humain qui contient tout ce qui est nécessaire pour construire le paquet, c'est-à-dire pour créer le paquet binaire. Les informations contenues dans la description de paquet comprennent des métainformations (comme le nom du paquet et une description de son objet), l'URL du source code et les instructions nécessaires à la configuration, compilation et construction du paquet. La description peut être accompagnée d'une rustine.</p>
<p>Un paquet binaire est une archive qui contient effectivement les fichiers qui constituent le paquet, c'est-à-dire les exécutables, les fichiers de données, les catalogues de messages, les bibliothèques, les fichiers include, etc... Le paquet peut aussi contenir des métainformations pour le paquet lui-même. 
L'installation d'un paquet binaire consiste simplement à le dépaqueter, puisqu'il est déjà dans un format prêt à l'emploi. Comme Fink construit les paquets avec le gestionnaire de paquets dpkg, les paquets binaires ont le format dpkg et ont une extension .deb.</p>
</section>
<section name="ident"><title>Identification d'un paquet</title>
<p>Un paquet est identifié par trois éléments : le nom du paquet, la version et la révision. Tous ces éléments peuvent contenir des lettres minuscules (a-z), des nombres (0-9), des tirets (-) sauf les numéros de révision, des signes plus (+) et des points (.). Les autres caractères sont interdits. En particulier, on ne peut utiliser de majuscules et de tiret de soulignement.</p>
<p>Le nom du paquet est tout simplement le nom du logiciel, par exemple openssh. La version, aussi appelée version en amont, est l'identifiant de version du paquet original. On peut utiliser des lettres dans la version, par exemple 2.9p1. fink et dpkg les trient correctement. La révision est un compteur qui est incrémenté quand la description du paquet change. Il démarre à 1 et doit être remis à 1 quand la version en amont change. La révision ne doit pas contenir de tiret. Le nom complet du paquet est constitué de la concaténation de ces trois éléments, séparés par des tirets, par exemple openssh-2.9p1-2.</p></section>
</chapter>
<chapter filename="format">
<title>Descriptions de paquets</title>
<shorttitle>Descriptions de paquets</shorttitle>
<section name="trees"><title>Arborescence</title>
<p>Les descriptions de paquets sont lues à partir des répertoires <code>finkinfo</code> situés dans le répertoire <filename>/opt/sw/fink/dists</filename>. La valeur de la variable "Trees" dans <filename>/opt/sw/etc/fink.conf</filename> contrôle quels répertoires sont lus. Le nom des fichiers de description de paquets doit être identique au nom complet du paquet suivi de l'extension ".info". 
À partir de fink 0.26.0, il existe plusieurs façons de spécifier le nom du fichier ; il est recommandé d'utiliser le nom le plus court compatible avec les autres paquets nécessaires. 
Le nom du fichier est de la forme : nom invariant du paquet, suivi éventuellement d'un tiret et de l'architecture, suivi éventuellement d'un tiret et de la distribution, suivi éventuellement d'un tiret et de la version ou du couple version-révision, et terminé par ".info". 
Les éléments "architecture" et "distributtion" ne sont autorisés que si leurs champs sont présents dans le paquet et qu'ils fournissent une seule et unique valeur.
</p>
<p>L'arborescence des descriptions de paquets comprend plusieurs niveaux de répertoires. En voici la liste de la racine au bas de l'arborescence :</p>
<ul>
<li><code>dists</code> est à la racine. Le répertoire <code>dists</code> est nécessaire pour les outils Debian.
<!-- start translation -->
In recent versions of fink, this is a symlink to a directory with a distribution-inspired name.
<!-- end translation -->
</li>
<li>La distribution. Il y en a trois : <code>stable</code>, <code>unstable</code> et <code>local</code>. Le répertoire <code>local</code> est sous le contrôle de l'utilisateur/administrateur local. Les répertoires <code>stable</code> et <code>unstable</code> font partie de Fink.</li>
<li>L'arbre.
<!-- start translation -->
The <code>main</code> tree contains the bulk of the packages. Prior to July 1, 2010, the Cryptographic software was kept in a separate tree, <code>crypto</code>, but this is now a section of the <code>main</code> tree.
<!-- end translation -->
</li>
<li><code>finkinfo</code> et <code>binary-darwin-powerpc</code>. <code>finkinfo</code> contient les descriptions de paquets Fink et leurs rustines, tandis que <code>binary-darwin-powerpc</code> contient les paquets binaires <code>.deb</code>.</li>
<li>Sections. L'arbre <code>main</code> est subdivisé en sections thématiques pour en faciliter la gestion.</li>
</ul>
</section>
<section name="format"><title>Format de fichier</title>
<p>Les fichiers de description sont de simples listes de paires clés-valeurs, appelés également "champs". Chaque ligne commence par une clé, suivie de deux-points et d'une espace, puis de la valeur de clé :</p>
<codeblock>clé: valeur</codeblock>
<p>Il y a deux notations pour les champs qui peuvent s'étendre sur plusieurs lignes.</p>
<p>La notation recommandée est basée sur la syntaxe "here-document" - "données ci-après", utilisée dans les scripts shell. Dans cette syntaxe, la première ligne est composée de la clé, suivie du symbole redoublé <code>&lt;&lt;</code> comme valeur. Toutes les lignes suivantes sont considérées comme valeurs, jusqu'à la rencontre d'une ligne ne contenant que <code>&lt;&lt;</code>. L'exemple ci-dessus ressemble maintenant à :</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
<p>Avec ce format, l'indentation est optionnelle, mais vous pouvez l'utiliser pour améliorer la lisibilité.</p>
<p>On peut imbriquer plusieurs "here-document". Cela arrive souvent dans un champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code>. Ces champs contiennent d'autres champs (à lignes multiples), et cette syntaxe permet aux sous-champs de contenir eux mêmes des lignes multiples. Le même code de terminaison <code>&lt;&lt;</code> est utilisé pour les sous-champs utilisant la syntaxe "here-document". En voici un exemple :</p>
<codeblock>
SplitOff: &lt;&lt;
  Package: %N-shlibs
  InstallScript: &lt;&lt;
    ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
  &lt;&lt;
&lt;&lt;
</codeblock>
<p>Une notation plus ancienne, obsolète, est basée sur la méthode de pliage des headers du RFC 822. Une ligne commençant par une espace est traitée comme la continuation de la ligne précédente. Exemple :</p>
<codeblock>InstallScript: mkdir -p %i/share/man
 make install prefix=%i mandir=%i/share/man
 mkdir -p %i/share/doc/%n
 install -m 644 COPYING %i/share/doc/%n</codeblock>
<p>Notez l'indentation obligatoire des lignes.</p>
<p>Dans les deux formats, les lignes vides ainsi que celles débutant avec un dièse (#) sont ignorées. Dans Fink, les clés (noms des champs) ne sont pas sensibles à la casse, vous pouvez donc écrire indifféremment : <code>InstallScript</code>, <code>installscript</code> ou <code>INSTALLSCRIPT</code>. Cependant, on conseille la première forme, où chaque initiale de mot est mise en majuscules, pour des raisons de lisibilité. Certains champs prennent une valeur booléenne ; sont traitées comme vraies, les valeurs suivantes : "true", "yes", "on", "1" (toutes insensibles à la casse) ; toute autre valeur est traitée comme fausse.</p>
</section>
<section name="percent"><title>Raccourcis %</title>
<p>Pour vous rendre la vie plus facile, Fink gère un jeu de raccourcis sur certains champs. Pour lever toute ambiguïté, vous pouvez utiliser des accolades autour des caractères qui doivent être considérés comme des raccourcis. Par exemple, <code>%{n}</code> a la même signification que <code>%n</code>. Les raccourcis disponibles sont les suivants :</p>
<itemtable labeld="Signification" labelt="Raccourcis">
<item><itemt>%n</itemt>
<itemd>
<p>le <em>n</em>om du paquet actif</p>
</itemd></item>
<item><itemt>%N</itemt>
<itemd>
<p><em>N</em>om du paquet parent (le même que %n à moins d'être dans un
<code>SplitOff</code>)</p>
<p>Note : si le champ <code>Package</code> d'un paquet parent contient %type_*[], la valeur de ces raccourcis <em>sera</em> incluse dans %N dans un bloc <code>SplitOff</code> (étant donné qu'elle est incluse dans %n dans le paquet parent).</p>
</itemd></item>
<item><itemt>%e</itemt>
<itemd>
<p>ère du paqu<em>e</em>t</p>
</itemd></item>
<item><itemt>%v</itemt>
<itemd>
<p><em>v</em>ersion du paquet. Notez que l'ère ne fait partie de <code>%v</code>.</p>
</itemd></item>
<!-- start translation -->
<item><itemt>%V</itemt>
<itemd>
<p>
the full package <em>V</em>ersion, which automatically includes the Epoch
if present.  Note that this percent expansion is only available for
packages whose <code>InfoN</code> level is at least 4.
</p>
</itemd></item>
<!-- end translation -->
<item><itemt>%r</itemt>
<itemd>
<p><em>r</em>évision du paquet</p>
</itemd></item>
<item><itemt>%f</itemt>
<itemd>
<p>nom complet du paquet, c'est-à-dire : %n-%v-%r. Notez que l'ère ne fait partie de <code>%f</code>.</p>
</itemd></item>
<item><itemt>%p, %P</itemt>
<itemd>
<p><em>p</em>réfixe d'installation de Fink, par exemple : <filename>/opt/sw</filename>. Vous ne devez pas partir du principe que Fink est installé dans <filename>/opt/sw</filename>, utilisez <code>%p</code> pour obtenir le bon chemin.</p>
</itemd></item>
<item><itemt>%d</itemt>
<itemd>
<p>répertoire <em>d</em>ans lequel le paquet est construit, par exemple : <filename>/opt/sw/src/fink.build/root-gimp-1.2.1-1</filename>. Ce répertoire temporaire sert de racine d'arborescence lors de la phase d'installation de la compilation d'un paquet. Vous ne devez pas partir du principe que <filename>root-%f</filename> est dans <filename>%p/src</filename>, car l'utilisateur peut changer ce répertoire en utilisant le champ <code>Buildpath</code> de <filename>/opt/sw/etc/fink.conf</filename>.</p>
</itemd></item>
<item><itemt>%D</itemt>
<itemd>
<p>répertoire <em>D</em>ans lequel le paquet parent est construit (le même que %d à moins d'être dans un <code>SplitOff</code>)</p>
</itemd></item>
<item><itemt>%i</itemt>
<itemd>
<p>préf<em>i</em>xe complet de la phase d'installation, équivalent à %d%p</p>
</itemd></item>
<item><itemt>%I</itemt>
<itemd>
<p>préfixe d'<em>I</em>nstallation du paquet parent, équivalent à %D%P (identique à %i à moins d'être dans un <code>SplitOff</code>)</p>
</itemd></item>
<item><itemt>%a</itemt>
<itemd>
<p>chemin des rustines</p>
</itemd></item>
<item><itemt>%b</itemt>
<itemd>
<p>répertoire de compilation, exemple : <filename>/opt/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>. Vous ne devez pas partir du principe que <filename>%f</filename> est dans <filename>%p/src</filename>, car l'utilisateur peut changer ce répertoire en utilisant le champ <code>Buildpath</code> de <filename>/opt/sw/etc/fink.conf</filename>. Le dernier sous-répertoire tire son nom du champ <code>Source</code>, ou du champ <code>SourceDirectory</code> (si ce champ existe), ou bien n'existe pas si le champ <code>NoSourceDirectory</code> a pour valeur <code>true</code> (vrai).</p>
<p>Note : ne l'utilisez que s'il n'y a pas d'autres possibilités. Le répertoire de compilation est
le répertoire actif lorsque les scripts sont exécutés ; vous devez utiliser des chemins relatifs dans les commandes.</p>
</itemd></item>
<item><itemt>%c</itemt>
<itemd>
<p>paramètres pour <em>c</em>onfigure : <code>--prefix=%p</code> plus tout autre élément spécifié avec ConfigureParams. Dans le cas d'un paquet qui comporte le <code>Type: perl</code>, les drapeaux par défaut de construction d'un paquet perl sont utilisés à la place de <code>--prefix=%p</code>.</p>
</itemd></item>
<item><itemt>%m</itemt>
<itemd>
<p>chaîne spécifiant l'architecture de la <em>m</em>achine. Identique au résultat de la commande <code>uname -p</code>. Les valeurs habituelles sont 'powerpc' pour les machines ppc and 'i386' pour les machines x86. Introduit dans les versions CVS de fink postérieures à la version 0.12.1.</p>
</itemd></item>
<item><itemt>%%</itemt>
<itemd>
<p>signe pourcentage (%) (ce signe n'est pas interprété en fonction de ce qui le suit). L'interprétation se fait de gauche à droite, si bien que %%n n'a rien à voir avec le nom du paquet, mais représente la chaîne %n. (Introduit dans fink-0.18.0).</p>
</itemd></item>
<item><itemt>%type_raw[<em>type</em>], %type_pkg[<em>type</em>], %type_num[<em>type</em>]</itemt>
<itemd>
<p>fonction de pseudo-hachage retournant le sous-type du <em>type</em> donné. Voir la documentation sur le champ <code>Type</code> plus bas. La forme _raw correspond à la chaîne précise du sous-type, tandis que la forme _pkg correspond à la même chaîne dont tous les points auraient été enlevés (suivant les conventions de nommage des paquets - language-version - de Fink et pour d'autres usages réservés aux experts). (Introduit dans une version CVS de Fink ultérieure à la version 0.19.2). La forme _num a été introduit dans la version 0.26.0 de fink et supprime tous les caractères non numériques du champ <code>Type</code>.</p>
</itemd></item>
<item><itemt>%{ni}, %{Ni}</itemt>
<itemd>
<p>la partie <em>i</em>nvariante du <em>n</em>om du paquet. Identiques à %n et %N, à l'exception près que tous les %type_pkg[] et %type_raw[] sont occultés. (Introduit dans une version CVS de Fink ultérieure à la version 0.19.2). Vous devez utiliser %{ni} et %{Ni} pour éviter de possibles confusions avec les raccourcis %n et %N.</p>
</itemd></item>
<item><itemt>%{default_script}</itemt>
<itemd>
<p>Uniquement valide dans les champs <code>PatchScript</code>, <code>CompileScript</code> et <code>InstallScript</code>. Correspond au contenu par défaut de ce type de champ. Sa valeur dépend souvent du champ <code>Type</code> et est toujours définie (même si elle vide). Lorsque ce raccourci est utilisé dans le champ <code>InstallScript</code> d'un <code>SplitOff</code> ou d'un <code>SplitOffN</code>, son interprétation correspond à la valeur par défaut du champ <em>parent</em>, bien que la valeur par défaut de <code>InstallScript</code> dans un <code>SplitOff</code> soit vide. (Introduit dans fink-0.20.6)</p>
</itemd></item>
<item><itemt>%{PatchFile}</itemt>
<itemd>
<p>Chemin complet du fichier indiqué dans le champ<code>PatchFile</code>. Introduit dans la version 0.24.12 de fink.</p>
</itemd></item>
<item><itemt>%lib</itemt>
<itemd>
<p>Si le champ <code>Type: -64bit</code> a pour valeur <code>-64bit</code>, ce raccourci permet de définir le répertoire des bibliothèques comme étant le répertoire <em>lib/ppc64</em> sur machines powerpc, ou  <em>lib/x86_64</em> sur machines intel (répertoires standards pour les bibliothèques 64-bit). Dans le cas contraire, le raccourci définit le répertoire <em>lib</em> comme répertoire pour les bibliothèques. Introduit dans la version 0.20.6 de fink.</p>
<!-- start translation -->
<p>Note that <code>%lib</code> is not permitted in the
<code>ConfigureParams</code> field unless the <code>InfoN</code>
 level is at least 4.
</p>
<!-- end translation -->
</itemd></item>
</itemtable>
</section>
</chapter>
<chapter filename="policy">
<title>Règles de distribution des paquets</title>
<shorttitle>Règles</shorttitle>
<section name="licenses"><title>Licences de paquets</title>
<p>Les paquets inclus dans Fink ont différents types de licences. La plupart d'entre elles stipulent une restriction sur la redistribution des sources complètes et particulièrement sur la distribution des binaires. Certains paquets ne peuvent être inclus dans la distribution binaire de Fink à cause de ces licences restrictives. C'est pourquoi il est essentiel que les mainteneurs de paquets vérifient, scrupuleusement, les licences de leurs paquets.</p>
<p>Chaque paquet distribué en tant que binaire doit contenir une copie de la licence. Elle doit être installée dans le répertoire de documentation, c'est à dire dans <filename>%p/share/doc/%n</filename>. (Dans InstallScript, il faut, évidemment, utiliser %i au lieu de %p. Le champ DocFiles gère les détails automatiquement). S'il n'y a pas de licence explicite dans le source original, placez un fichier texte contenant une note à propos du statut du paquet. La plupart des licences requièrent que celle-ci accompagne toute distribution. La règle de Fink est de toujours faire ainsi, même si ce n'est pas explicitement requis.</p>
<p>Pour automatiser le plus possible la maintenance de la distribution binaire, tout paquet distribué doit avoir un champ <code>License</code>. Ce champ indique la nature de la licence et est utilisé pour décider quels paquets font partie de la distribution et quels paquets doivent en être exclus. Le champ ne peut exister que si les termes réels de la licence sont inclus dans le paquet binaire, comme expliqué ci-dessus.</p>
<p>Pour que le champ <code>License</code> ait une utilité, n'utilisez qu'une seule des valeurs prédéfinies suivantes. Si vous construisez un paquet qui ne rentre pas dans ces catégories, demandez de l'aide sur la liste des développeurs.</p>
<ul>
<li><code>GPL</code> - la licence générale publique GNU. Cette licence requiert que le source soit accessible au même endroit que le binaire.</li>
<li><code>LGPL</code> - la licence publique GNU moins générale. Cette licence requiert que le source soit accessible au même endroit que le binaire.</li>
<li><code>GPL/LGPL</code> - c'est un cas spécial pour les paquets dans lesquels une partie est sous licence GPL (par exemple les exécutables) et une autre partie est sous licence LGPL (par exemple les bibliothèques).</li>
<li><code>BSD</code> - pour les licences style BSD. Ceci inclue la licence BSD dite "original", la licence BSD "modified" et la licence MIT. La licence Apache compte aussi parmi les licences BSD. Avec ces licences, la distribution du code source est optionnelle. </li>
<li><code>Artistic</code> - pour la licence "Artistic" et ses dérivées.</li>
<li><code>Artistic/GPL</code> - licence duale, combinée Artistic/GPL.</li>
<li><code>GNU Free Documentation License</code> et <code>Linux Documentation Project</code> - si la documentation incluse dans un paquet l'est explicitement sous une de ces licences, alors ce sera indiqué par l'ajout de <code>/GFDL</code> ou <code>/LDP</code> au code de la licence, ce qui donne l'une des combinaisons autorisées suivantes : "GFDL", "GPL/GFDL", "LGPL/GFDL", "GPL/LGPL/GFDL", "LDP", ou "GPL/LGPL/LDP". </li>
<li><code>DFSG-Approved</code> - pour les paquets qui suivent les règles du <link url="http://www.debian.org/social_contract">Pacte social Debian</link>.
</li>
<li><code>OSI-Approved</code> - pour les autres licences Open Source approuvées par l'Initiative Open Source (OSI) <link url="http://www.opensource.org/"></link>. L'une des règles de l'OSI est que la libre distribution de binaires et de sources est autorisée. Ce code peut aussi servir de cadre aux paquets à licence duale.</li>
<li><code>Restrictive</code> - pour les licences restrictives. Utilisez ceci pour les paquets qui sont accessibles en tant que sources à usage libre auprès de l'auteur, mais dont la libre redistribution n'est pas autorisée. </li>
<li><code>Restrictive/Distributable</code> - pour des licences restrictives qui admettent une distribution des binaires et du source. Utilisez ceci pour les paquets qui sont accessibles en tant que sources auprès de l'auteur, autorisent la distribution du source et des binaires, mais ont des restrictions qui en font des licences non open-sources.</li>
<li><code>Commercial</code> - pour des licences restrictives de type commercial. Utilisez ceci pour des paquets de type commercial ( par exemple graticiels, partagiciels qui n'autorisent pas la libre redistribution du source ou des binaires.</li>
<li><code>Public Domain</code> - pour des paquets qui sont dans le domaine public, c'est-à-dire que l'auteur a abandonné ses droits sur le code. Ces paquets n'ont aucune licence d'aucune sorte et tout un chacun peut en faire ce que bon lui semble.</li>
</ul>
</section>
<section name="openssl"><title>La licence GPL et OpenSSL</title>
<p>(Changement de règle à dater d'avril 2005).</p>
<p>En raison d'une incompatibilité manifeste entre la licence d'OpenSSL et les licences GPL et LGPL, les paquets de Fink sous licence originale GPL ou LGPL qui sont liés à <code>openssl</code> doivent avoir une licence "Restrictive". En conséquence, le projet Fink ne distribuera pas les binaires de ces paquets. Toutefois les utilisateurs sont libres de les compiler à partir du source.</p>
<p>Nous encourageons les mainteneurs à indiquer la licence originale du paquet dans le champ <code>DescPackaging</code>.</p>
</section>
<section name="prefix"><title>Interférence avec le système de base</title>
<p>Fink est une distribution additionnelle qui est installée dans un répertoire distinct du système de base. Il est essentiel qu'un paquet n'installe aucun fichier en dehors du répertoire de Fink.</p>
<p>Il peut y avoir des exceptions quand on ne peut faire autrement, par exemple avec XFree86. Dans ce cas, le paquet doit tester l'existence de fichiers avant l'installation et refuser de s'installer si cela amène à écraser des fichiers déjà existants. Le paquet doit s'assurer que tous les fichiers qu'il aura installés en dehors du répertoire de Fink seront supprimés lorsque le paquet lui-même sera éliminé, ou que ces fichiers ne causeront aucun problème s'ils sont laissés sur place (c'est-à-dire qu'ils devront tester l'existence des binaires avant de les appeler, etc...).</p>
</section>
<section name="sharedlibs"><title>Bibliothèques partagées</title>
<p>Fink a de nouvelles règles en ce qui concerne les bibliothèques partagées, règles qui prennent effet à compter de février 2002. Cette partie de la documentation donne des explications sur la version 4 de ces règles, qui coïncide avec la publication de la distribution 0.5.0 de Fink,
<!-- start translation -->
as modified in December, 2006 to handle 64bit libraries
and from January, 2008 to handle private shared libraries. (In addition,
the discussion was updated in June, 2008 to eliminate obsolete references to a
transitional period for implementing the shared libraries policy.)
We begin with a quick summary, and then discuss things in more detail.
<!-- end translation -->
Nous commencerons par un bref résumé, puis nous passerons à une revue de détails.
</p>
<p>Tout paquet qui construit des bibliothèques partagées et qui doit gérer ses bibliothèques partagées conformément aux règles de Fink. Ceci signifie :</p>
<ul>
<li>vérifier, à l'aide de <code>otool -L</code> (ou de <code>otool64 -L</code> pour les bibliothèques 64bit), que le nom d'installation de chaque bibliothèque, ses numéros de versions de compatibilité et actuels sont corrects</li>
<li>mettre les bibliothèques partagées dans un paquet séparé (exception faite pour les liens de libfoo.dylib vers nom d'installation), et inclure le champ <code>Shlibs</code> dans ce paquet</li>
<li>mettre les headers et les liens finaux venant de libfoo.dylib dans un paquet caractérisé par <code>BuildDependsOnly: True</code>, et prévoir qu'aucun autre paquet ne dépendra de lui.</li>
</ul>
<!-- start translation -->
<p>Note that a package may also install private shared libraries, which
are not intended to be linked from any other package.  In this case, the
libraries need not go into a separate package, but a <code>Shlibs</code>
field must still be part of the package containing shared libraries.  Also,
maintainers should try to avoid storing a final link from libfoo.dylib
in the main library directory <filename>%i/lib</filename> 
(or its 64-bit equivalent), to prevent
other programs from accidentally linking to this library.
</p><!-- end translation -->
<p>Un mainteneur, qui a de bonnes raisons de s'écarter de ces règles et ne scinde pas le paquet, devra expliquer pourquoi dans le champ DescPackaging.</p>
<p>Pour certains paquets, tout peut être fait avec un paquet principal et un paquet -shlibs ; dans d'autres cas, vous aurez besoin d'un troisième paquet. Le nouveau champ <code>SplitOff</code> facilite ce processus.</p>
<p>Quand trois paquets sont nécessaires, il y a deux façons différentes de les nommer, suivant que les bibliothèques (option 1) ou les binaires (option 2) sont les fonctionnalités les plus importantes du paquet. 
Pour l'option 1, utilisez le schéma suivant :</p>
<itemtable labeld="Contenu" labelt="Paquet">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd>
<p>Librairies partagées</p>
</itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd>
<p>Headers</p>
</itemd></item>
<item><itemt><code>foo-bin</code></itemt>
<itemd>
<p>Binaires, etc...</p>
</itemd></item>
</itemtable>
<p>Pour l'option 2, utilisez :</p>
<itemtable labeld="Contenu" labelt="Paquet">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd>
<p>Librairies partagées</p>
</itemd></item>
<item><itemt><code>foo-dev</code></itemt>
<itemd>
<p>Headers</p>
</itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd>
<p>Binaires, etc...</p>
</itemd></item>
</itemtable>
<p><em>Règles détaillées</em></p>
<p>Nous allons désormais discuter de tout cela en détails. Comme exemples des règles en action, voir les paquets libpng, libjpeg et libtiff.</p>
<p>Les logiciels portés sur Darwin doivent, autant que possible, construire des bibliothèques partagées. (Les mainteneurs de paquets sont libres de construire des bibliothèques statiques, si cela s'avère plus approprié pour leurs paquets ; ils peuvent aussi soumettre des paquets contenant uniquement des bibliothèques statiques, s'ils le souhaitent). 
Quand on construit des bibliothèques partagées
<!-- that are expected to be used by other packages, -->
<em>deux</em> paquets - nommés foo et foo-shlibs -, étroitement liés, doivent être construits. Les bibliothèques partagées vont dans foo-shlibs, et les headers dans foo. Ces deux paquets peuvent être réalisés avec un seul fichier .info, en utilisant le champ <code>SplitOff</code>, comme indiqué ci-dessous. (En fait, il est souvent nécessaire de construire plus de deux paquets à partir du source, et cela peut être fait en utilisant <code>SplitOff2</code>, <code>SplitOff3</code>, etc...)</p>
<p><!-- Chaque paquet logiciel pour lequel des bibliothèques partagées peuvent être construites doit avoir un <em>numéro de version majeure</em> N. -->
<!-- start translation -->
Each software package for which public shared libraries are built must have
a <em>major version number</em> N, which is included in the shared
library's filename (for example, <filename>libbar.N.dylib</filename>).
<!-- end translation -->
Le numéro de version majeure n'est censé changer que lorsqu'un changement irréversible se produit dans l'API de la bibliothèque. Fink utilise la convention de nommage suivante : si le nom en amont du paquet est bar, alors les paquets fink sont appelés barN et barN-shlibs. (Ceci n'est appliqué rigoureusement qu'à de nouveaux paquets ou lorsque le numéro de version majeure change). Par exemple, le numéro de version majeure pour le paquet pré-existant libpng était 2, mais les versions récentes de la bibliothèque ont pour numéro de version majeure 3. Il y a donc, maintenant, 4 paquets fink pour gérer ceci : libpng, libpng-shlibs, libpng3, libpng3-shlibs. Seul libpng ou libpng3 peut être installé à un moment donné, mais libpng-shlibs et libpng3-shlibs peuvent être installés en même temps. (Notez que deux fichiers .info suffisent à construire ces quatre paquets).</p>
<p>La bibliothèque partagée elle-même et certains fichiers liés seront placés dans le paquet barN-shlibs ; les fichiers "include" et un certain nombre d'autres fichiers seront placés dans le paquet barN. Il ne peut y avoir de recouvrement de fichiers entre ces deux paquets, et tout ce qui est placé dans barN-shlibs doit avoir un nom chemin qui, d'une façon ou d'une autre, contienne le numéro de version majeure N. Dans de nombreux cas, votre paquet aura besoin de certains fichiers à l'exécution, fichiers qui sont généralement installés dans <filename>%i/lib/bar/</filename> ou <filename>%i/share/bar/</filename> ; vous devrez adapter les chemins d'installation à <filename>%i/lib/bar/N/</filename> ou <filename>%i/share/bar/N/</filename>.</p>
<p>Tous les autres paquets dépendant de bar, version majeure N, devront utiliser les dépendances :</p>
<codeblock>
  Depends: barN-shlibs
  BuildDepends: barN
</codeblock>
<!-- start translation --><p>
It is not be permitted for 
another package to depend on barN itself.  (Although there may still be
a few such dependencies involving packages which were in place prior to 
February, 2002.)  This is
signaled to other developers by a boolean field
</p><!-- end translation -->
<codeblock>
  BuildDependsOnly: True
</codeblock>
<p>dans la description du paquet barN.</p>
<p>Si votre paquet inclut à la fois des bibliothèques partagées et des binaires, et si les binaires doivent être présents à l'exécution (et pas seulement à la compilation), alors les binaires doivent être regroupés dans un troisième paquet, qui peut être appelé barN-bin. Les autres paquets peuvent dépendre de barN-bin comme de barN-shlibs.</p>
<p>Lors de la construction de bibliothèques partagées de version majeure N, il est important que le "nom d'installation" soit <filename>%p/lib/libbar.N.dylib</filename>. Vous trouverez le nom d'installation en exécutant <code>otool -L</code> (ou <code>otool64 -L</code>pour les bibliothèques 64bit) sur votre bibliothèque. Le fichier bibliothèque réel doit être installé sous le nom de :</p>
<codeblock>
  %i/lib/libbar.N.x.y.dylib
</codeblock>
<p>et votre paquet doit créer des liens symboliques :</p>
<codeblock>
  %i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib
</codeblock>
<!-- start translation --><p>from the install_name path and from the linking path to the actual
library.  (The first will not be needed if the library is in fact
installed at the install_name path, which is becoming more common.)
</p><!-- end translation -->
<p>Si la bibliothèque statique est aussi construite, elle doit être installée sous le nom de :</p>
<codeblock>
  %i/lib/bar.a
</codeblock>
<p>Si le paquet utilise libtool, ceci est généralement géré automatiquement, mais, dans tous les cas, vous devez vérifier que tout s'est passé correctement. Vous devez aussi vérifier que la version courante et la version de compatibilité sont définies de façon appropriée à vos bibliothèques partagées. On peut trouver les numéros de version avec la commande <code>otool -L</code> (ou la commande <code>otool64 -L</code> pour les bibliothèques 64bit).</p>
<p>Les fichiers sont scindés entre les deux paquets comme suit :</p>
<ul>
<li>  dans le paquet barN-shlibs :
<codeblock>
  %i/lib/libbar.N.x.y.dylib
  %i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar/N/*
  %i/share/bar/N/*
  %i/share/doc/barN-shlibs/*
</codeblock>
</li>
<li>  dans le paquet barN :
<codeblock>
  %i/include/*
  %i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar.a
  %i/share/doc/barN/*
  autres fichiers, si nécessaire
</codeblock>
</li>
</ul>
<p>Notez que les deux paquets doivent contenir des informations sur la licence, mais que les répertoires contenant les fichiers de documentation (DocFiles) sont différents.</p>
<p>Tout ceci est facile à réaliser en utilisant le champ <code>SplitOff</code>. Voici comment l'exemple ci-dessus serait (partiellement) implémenté :</p>
<codeblock>
Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/libbar.N.x.y.dylib lib/libbar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;
</codeblock>
<p>Durant l'exécution du champ <code>SplitOff</code>, les fichiers et les répertoires spécifiés sont déplacés du répertoire d'installation %I du paquet principal vers le répertoire d'installation %i du paquet splitoff. (Il y a une convention similaire pour les noms : %N est le nom du paquet principal, et %n est le nom du paquet actif). La commande <code>DocFiles</code> place ensuite une copie de la documentation dans <filename>%i/share/doc/barN-shlibs</filename>.</p>
<p>Notez que nous avons inclus la version courante exacte de barN-shlibs comme dépendance du paquet principal barN (qui peut être abrégé en %N-shlibs (= %v-%r) ). Ceci assure que les versions correspondent, et garantit aussi que barN "hérite" automatiquement de toutes les dépendances de barN-shlibs.</p>
<p><em>Le champ BuildDependsOnly</em></p>
<p>Lors de mises à jour de bibliothèques, il est souvent nécessaire d'avoir deux versions des headers pendant une période de transition. L'une d'entre elles est utilisée pour compiler certaines choses, l'autre pour en compiler d'autres. C'est pourquoi, les paquets contenant des headers doivent être construits avec soin. Si foo-dev et bar-dev contiennent tous les deux des headers qui se recouvrent, alors foo-dev doit déclarer :</p>
<codeblock>
  Conflicts: bar-dev
  Replaces: bar-dev
</codeblock>
<p>de même, bar-dev déclare des Conflicts/Replaces sur foo-dev.</p>
<p>De plus, les deux paquets doivent déclarer :</p>
<codeblock>
  BuildDependsOnly: True
</codeblock>
<p>Ceci empêche d'autres paquets de dépendre de foo-dev ou de bar-dev, car de telles dépendances enrayeraient le mécanisme du Conflicts/Replaces.</p>
<p>Il existe certains paquets contenant des headers et pour lesquels il ne semble pas approprié de déclarer une valeur "true" pour BuildDependsOnly. Dans ce cas, le paquet doit déclarer : </p>
<codeblock>
  BuildDependsOnly: False
</codeblock>
<p>et la raison pour laquelle cela est fait doit être mentionnée dans le champ DescPackaging.</p>
<p>Le champ BuildDependsOnly ne doit être mentionné dans le fichier .info du paquet que si ce paquet contient des headers installés dans /opt/sw/include.</p>
<p>À partir de la version 0.20.5 de fink, "fink validate" affichage un message pour tout .deb qui contient des headers et au moins une dylib, et qui ne donne pas la valeur "true" ou "false" au champ BuildDependsOnly. (Il est possible que, dans les versions postérieures de fink, ce message soit étendu aux cas des .deb contenant des headers et une bibliothèque statique). </p>
<!-- start translation --><p>
  The goal of the Shared Library Policy is to allow assure
  compatibility between libraries supplied by one package and
  libraries or programs that use them in a different package. Some
  packages may have shared libraries that are not designed to be used
  by other packages. Common situations include a suite of programs
  that come with a back-end library of utility functions or a program
  that comes with plugins to handle various features. Because these
  libraries are "private" to the package that has them, they do not
  require being packaged with separate -shlibs
  or <code>BuildDependsOnly</code> SplitOffs.
</p><!-- end translation -->
<p><em>Le champ Shlibs :</em></p>
<p>En sus de placer les bibliothèques partagées dans le bon paquet, suivant en cela la version 4 de cette règle, vous devez également déclarer toutes les bibliothèques partagées en utilisant le champ <code>Shlibs</code>. Ce champ contient une ligne distincte pour chaque bibliothèque partagée ; la ligne comprend le <code>nom d'installation</code> de la bibliothèque.
<!-- start translation -->
If the library is public, its <code>Shlibs</code> entry also
lists the <code>-compatibility_version</code>, versioned
dependency information specifying the Fink package which provides
this library at this compatibility version, and the library
architecture.
<!-- end translation -->
Cette architecture peut avoir pour valeur "32", "64", "32-64" ou même ne pas exister ; dans ce dernier cas, elle prend la valeur "32" par défaut. La dépendance doit être déclarée sous la forme <code> foo (>= version-révision)</code> où <code>version-révision</code> correspond à la <em>première</em> version du paquet de Fink qui fournit cette bibliothèque (avec cette version de compatibilité). Par exemple, une déclaration :</p>
<codeblock>
  Shlibs: &lt;&lt;
    %p/lib/libbar.1.dylib 2.1.0 bar1 (>= 1.1-2) 32
  &lt;&lt;
</codeblock>
<p>indique qu'une bibliothèque 32bit, dont le <code>nom d'installation</code> est %p/lib/libbar.1.dylib et <code>la version de compatibilité </code> est 2.1.0, a été installée à partir de la version 1.1-2 du paquet <em>bar1</em>. De plus, cette déclaration équivaut à la promesse du mainteneur qu'une bibliothèque 32 bit avec ce nom et une version de compatibilité au moins égale à 2.10 sera toujours présente dans les versions ultérieures du paquet <em>bar1</em>.</p>
<p>Notez l'utilisation de %p dans le nom de la bibliothèque, ce qui permet à tous les utilisateurs de Fink de trouver le bon <code>nom d'installation</code>, quel que soit le préfixe qu'ils ont choisi.</p>
<p>Quand un paquet est mis à jour, on copie tout simplement le champ <code>Shlibs</code> dans la nouvelle version/révision du paquet. L'exception à cette règle survient quand la <code>version de compatibilité</code> est incrémentée : dans ce cas, le numéro de version
dans les informations de dépendance doit être changé pour la version/révision courante (celle qui est la première à fournir la bibliothèque avec le nouveau numéro de version de compatibilité).</p>
<!-- start translation -->
<p>
The <code>Shlibs</code>
entry for a private library uses a different syntax:
</p>
<codeblock>
  Shlibs: &lt;&lt;
    !%p/lib/%N/libbar.1.dylib
  &lt;&lt;
</codeblock>
<p>The leading exclamation point indicates that this is a private library,
and since the other information is not relevant in this case, it is 
not included.</p>
<p>Note that in this example, the private shared library has been placed
in its own subdirectory <filename>%N</filename> of the 
<filename>%i/lib</filename> directory (which was named after the
package).  This is a recommended procedure for private libraries,
as an additional safety measure, to prevent other packages from accidentally
linking to this library.
</p>
<!-- end translation -->
<p><em>Mesures à prendre quand le numéro de version majeure change :</em></p>
<p>Si le numéro de version majeure change de N à M, vous devez créer deux nouveaux paquets barM et barM-shlibs. Le paquet barM-shlibs ne peut recouvrir le paquet barN-shlibs, puisque de nombreux utilisateurs installeront les deux simultanément. Dans le paquet barM, vous devez utiliser les dépendances :</p>
<codeblock>
  Conflicts: barN
  Replaces: barN
</codeblock>
<p>et vous devez modifier barN, de façon similaire, pour inclure les dépendances :</p>
<codeblock>
  Conflicts: barM
  Replaces: barM
</codeblock>
<p>Les utilisateurs verront alors barN et barM apparaître et disparaître au gré de la construction de divers paquets dépendant de l'une ou l'autre version de la bibliothèque partagée, tandis que barN-shlibs et barM-shlibs resteront installés de façon permanente.</p>
<p><em>Paquets contenant des fichiers binaires et des bibliothèques :</em></p>
<p>Quand un paquet en amont contient tout à la fois des fichiers binaires et des public bibliothèques, la construction des paquets fink doit être menée avec soin. Dans certains cas, les seuls fichiers binaires seront des fichiers du genre <code>foo-config</code>, qui sont censés n'être utilisés qu'à la compilation, et jamais à l'exécution. Dans ces cas, les binaires peuvent aller avec les headers dans le paquet <code>foo</code>.</p>
<p>Dans d'autres cas, les fichiers binaires seront nécessaires à d'autres paquets pendant l'exécution, et devront être regroupés dans un paquet fink séparé avec un nom du type <code>foo-bin</code>. Le paquet <code>foo-bin</code> doit dépendre du paquet <code>foo-shlibs</code>, et les mainteneurs d'autres paquets doivent être encouragés à utiliser :</p>
<codeblock>
  Depends: foo-bin
  BuildDepends: foo
</codeblock>
<p>ainsi la gestion de foo-shlibs sera assurée implicitement.</p>
<p>Néanmoins, la mise à jour pose un problème dans ce cas, puisque les utilisateurs ne seront pas invités à installer <code>foo-bin</code>. Pour résoudre ce problème, tant que tous les autres mainteneurs de paquets n'ont pas révisé leur paquets comme indiqué ci-dessus, votre paquet <code>foo</code> peut stipuler :</p>
<codeblock>
  Depends: foo-shlibs (= version.exacte), foo-bin
</codeblock>
<p>Ceci forcera l'installation de foo-bin sur la plupart des systèmes, jusqu'au moment où les mainteneurs de paquets auront mis à jour leurs paquets qui dépendent de <code>foo</code>.</p>
<!-- start translation -->
<p>
  As of fink-0.28.0 (released in January 2008), the format of
  the <code>Shlibs</code> entry for a "private" shared library has
  changed (see earlier discussion of the difference between a public
  and a private shared library). Note that the Shared Library Policy
  has always required all shared libraries to be listed; the change
  here is only in the syntax of the <code>Shlibs</code> field. Because
  this type of shared library is not designed to be used by external
  packages, there is no need to document its compatilibity or other
  versioning. Instead, an exclamation-mark is used.  For example,
  if <filename>libquux.3.dylib</filename> is
  the <code>install_name</code> of a private shared library, it would
  be listed as follows:
</p>
<codeblock>
  Shlibs: &lt;&lt;
    !%p/lib/libquux.3.dylib
  &lt;&lt;
</codeblock>
<!-- end translation -->
</section><section name="perlmods"><title>Modules Perl</title>
<p>La réglementation de Fink pour les modules perl, effective à partir de mai 2003, a été modifiée en avril 2004.</p>
<p>Traditionnellement, les paquets Fink pour les modules Perl avaient un suffixe <code>-pm</code>, et étaient compilés en utilisant la directive <code>Type: perl</code>, qui place les modules Perl dans <filename>/opt/sw/lib/perl5</filename> et/ou dans <filename>/opt/sw/lib/perl5/darwin</filename>. Avec la nouvelle réglementation, cet emplacement n'est autorisé que pour les modules perl qui sont indépendants de la version de perl utilisée pour les compiler (et qui ne dépendent pas d'autres modules perl dépendants des versions).</p>
<p>Les modules Perl qui sont dépendants des versions sont les modules dits XS, qui contiennent fréquemment du code C compilé ainsi que des routines écrites en langage Perl. Il y a de nombreuses façons de les reconnaître, notamment par la présence d'un fichier avec un suffixe <code>.bundle</code>.</p>
<p>Un module perl qui dépend des versions doit être construit en utilisant un binaire dont le nom comporte le numéro de version de perl, comme <code>perl5.6.0</code>, et doit stocker ses fichiers dans des sous-répertoires des répertoires standards de perl ; les noms de ces sous-répertoires doivent comporter le numéro de version de perl, comme <filename>/opt/sw/lib/perl5/5.6.0</filename> et <filename>/opt/sw/lib/perl5/5.6.0/darwin</filename>. Par convention, les noms des paquets utilisent le suffixe <code>-pm560</code> pour un module Perl de version 5.6.0. Des conventions de stockage et de nommage similaires s'imposent pour les autres versions de perl, qui incluent perl 5.6.1 (dans les seules branches 10.2), perl 5.8.0 (dans les seules branches 10.3), perl 5.8.1, perl 5.8.4 et perl 5.8.6.</p>
<p>La directive <code>Type: perl 5.6.0</code> utilise automatiquement le binaire dont le nom comporte le numéro de version de perl et stocke les fichiers dans les bons sous-répertoires. (Cette directive est disponible à partir de la version 0.13.0 de fink).</p>
<p>Sous la réglementation de mai 2003, il était permis de créer un paquet <code>-pm</code>, qui est essentiellement un paquet "lot", qui charge la variante <code>-pm560</code> ou une autre variante existante. Cette stratégie est déconseillée sous la réglementation d'avril 2004, et sera complètement interdite après une période de transition. (La seule exception sera le paquet <code>storable-pm</code> qui doit se présenter sous cette forme pour le bootstrap).</p>
<p>À partir de la version 0.20.2 de fink, le paquet virtuel system-perl "fournit" automatiquement certains modules perl quand la version de Perl présente sur le système est supérieure ou égale à 5.8.0. Dans le cas de system-perl-5.8.1-1, ces modules sont les suivants : <em>attribute-handlers-pm581, cgi-pm581, digest-md5-pm581, file-spec-pm581, file-temp-pm581, filter-simple-pm581, filter-util-pm581, getopt-long-pm581, i18n-langtags-pm581, libnet-pm581, locale-maketext-pm581, memoize-pm581, mime-base64-pm581, scalar-list-utils-pm581, test-harness-pm581, test-simple-pm581, time-hires-pm581.</em> (Cette liste était légèrement différente dans la version 0.20.1 de fink ; les mainteneurs de paquet sont invités à vérifier que c'est bien sur la nouvelle liste qu'ils se basent).</p>
<p>Effective à partir de la version 0.13.0 de fink, la commande <code>fink validate</code>, quand elle est appliquée à un fichier <code>.deb</code>, teste si le paquet fink est un module XS qui a été installé dans un répertoire dont le nom ne comporte pas le numéro de version, et, génère, dans ce cas, une alerte.</p>
<p>Les utilisateurs peuvent avoir plusieurs versions de perl installées au même moment. C'est pourquoi tout paquet de module basé sur une version de perl doit être écrit de tel sorte qu'il permette d'installer concurremment une autre version du même module. Il faut donc prendre soin d'éviter tout conflit d'installation dû à des noms identiques lors de l'installation des pages de manuel, des binaires ou autres scripts exécutables. Il est interdit de mettre dans un paquet un nom de fichier se terminant par -pm<em>XYZ</em> si le chemin complet du fichier est identique dans une autre version <em>XYZ</em>. L'utilisation de <code>Replaces</code> pour permettre de remplacer des fichiers de nom identique dans des modules correspondant à des versions de perl différentes n'est plus autorisée. En ce qui concerne les pages de manuel, voici la solution de remplacement à partir de mars 2005: on a définit dans Fink des emplacements différents pour le MANPATH : <filename>%p/lib/perl5/X.Y.Z/man</filename> pour chaque version perl-X.Y.Z. Il n'est plus besoin de créer des paquets SplitOff -man ou -doc mutuellement exclusifs. Par exemple, pour éviter des conflits entre uri-pm581 et uri-pm586, la page de manuel nommée <filename>URI.3pm</filename> est installée sous le nom <filename>%p/lib/perl5/5.8.1/man/man3/URI.3pm</filename> pour la version 5.8.1 et sous le nom <filename>%p/lib/perl5/5.8.6/man/man3/URI.3pm</filename> pour la version 5.8.6. Notez que les scripts par défaut générés par <code>Type: perl X.Y.Z</code> n'ont pas changé, vous devez donc installer les man pages manuellement dans <code>InstallScript</code>. Si, par ailleurs, vous n'utilisez pas un script hautement personnalisé, vous pouvez toujours utiliser le script par défaut, puis déplacer les fichiers manuellement :</p>
<codeblock>
%{default_script}
mv %i/share/man %i/lib/perl5/5.8.1
</codeblock>
<p>
Cela déplacera toutes les pages de manuel. Si vous ne désirez déplacer qu'une section des pages de manuel (par exemple, la section 3, page de manuel du module, mais pas la section, page de manuel des scripts), vous pouvez utiliser l'approche suivante :</p>
<codeblock>
%{default_script}
mkdir -p %i/lib/perl5/5.8.1/man
mv %i/share/man/man3 %i/lib/perl5/5.8.1/man
</codeblock>
<p>Si votre paquet comporte des exécutables, par exemple des scripts démo ou des utilitaires dans <filename>%p/bin</filename>, vous avez plusieurs options. L'une d'entre elle est de mettre ces fichiers (et leurs pages de manuel et autres fichiers associés) dans un paquet splitoff %N-bin. L'utilisation des champs <code>Conflicts</code> et <code>Replaces</code> assurera que l'installation des différentes versions de perl de ces paquets, qui contiennent des fichiers de même nom, est mutuellement exclusive. L'utilisateur peut installer de nombreuses versions différentes des modules de runtime basées sur des versions différentes de perl et décider laquelle choisir à tout moment pour exécuter un script. Par exemple, Tk.pm comporte un exécutable <filename>ptksh</filename>. La collection des paquets tk-pm* peut être construite de la façon suivante :</p>
<codeblock>
Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.8.1 5.8.4 5.8.6)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
&lt;&lt;
SplitOff: &lt;&lt;
  Package: %N-bin
  Depends: %N
  Conflicts: %{Ni}5.8.1, %{Ni}5.8.4, %{Ni}5.8.6
  Replaces: %{Ni}5.8.1, %{Ni}5.8.4, %{Ni}5.8.6
  Files: bin share/man/man1
&lt;&lt;
&lt;&lt;
</codeblock>
<p>Une autre solution est de renommer les scripts et leurs pages de manuel de façon à y inclure la version de perl. Cette méthode assure qu'il n'y a jamais de conflit, il n'est donc pas besoin d'utiliser des splitoffs %N-bin mutuellement exclusifs :
</p>
<codeblock>
Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.8.1 5.8.4 5.8.6)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
  mv %i/bin/ptksh %i/bin/ptksh%type_raw[perl]
  mv %i/share/man/man1/ptksh.1 %i/share/man/man1/ptksh%type_raw[perl].1
&lt;&lt;
&lt;&lt;
</codeblock>
<p>L'utilisateur accède à la version de ptksh correspondant à la version de perl désirée. On peut aussi utiliser <code>update-alternatives</code> pour permettre aux utilisateurs d'accéder à ces versions par leurs noms génériques (pas de mention de version de perl dans le nom).</p>
<p>De même, à partir de mars 2005, l'emplacement des pages de manuel et des modules installés par les paquets fink pour perl lui-même (paquets perlXYZ et perlXYZ-core pour des versions de perl différentes de celle fournie par Apple) a changé. Par conséquent, aucun autre paquet de fink fournissant des versions de mises à jour des modules core perl ne doit énumérer des paquets perlXYZ ou perlXYZ-core dans un champ <code>Replaces</code>.</p>
</section>
<section name="emacs"><title>Règles Emacs</title>
<p>Le projet Fink a choisi de suivre les règles du projet Debian en ce qui concerne emacs, avec quelques différences. (Vous trouverez les règles Debian sur <link url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">http://www.debian.org/doc/packaging-manuals/debian-emacs-policy</link>). Il existe deux différences dans les règles de Fink. Premièrement, ces règles ne s'appliquent, à l'heure actuelle, qu'aux paquets 
<filename>emacs21</filename>, <filename>emacs22</filename> et <filename>emacs21</filename> de fink. (Ceci pourra changer à l'avenir). Deuxièmement, contrairement aux règles Debian, les paquets Fink peuvent installer des objets directement dans /opt/sw/share/emacs/site-lisp.</p>
</section>



<!-- start translation -->
<section name="sources"><title>Source Policy</title>
    <p>Sources should normally be downloaded from the location(s) that the upstream
    developer(s) use, and any modifications for Fink should be done through the use
    of a PatchFile and/or a PatchScript.  Do not make changes manually and use a changed
    source archive as a <code>Source</code> in your Fink packaging.</p>
    <p>If a VCS checkout (e.g. from <em>git</em> or <em>svn</em>) is to be used, e.g.
    because a project doesn't do formal releases, or a fix for a particular issue has
    been added between releases of a package, an acceptable source can be generated
    via the following method:</p>
    <ol>
        <li>Check out the package, preferably at a definite revision of the VCS.</li>
        <li>Make an archive from the VCS checkout (e.g. <em>zip</em>, <em>tar</em>, <em>tar.gz</em>,
        or <em>tar.bz2</em>).
            <p>Give the tarball a unique version.  For example, you can include the VCS revision in the archive name, e.g.
            <filename>foo-0svn1234.tar.gz</filename> for a package that doesn't make releases, or
            <filename>bar-1.2.3+svn4567.tar.bz2</filename> for a Fink package which is between
            upstream releases.</p></li>
        <li>Use the same <code>Version</code> in your <filename>.info</filename> file.</li>
        <li>It is also useful to put the commands that you ran to generate the source tarball in the
        <code>DescPackaging</code> field.</li>
        <li>Upload the tarball to a public download site where users can use <code>fink</code> to download it.
        If you don't have ready access to one, ask on the
        <link url="mailto:fink-devel@lists.sourceforge.net">Fink developers mailing list</link> or
        <link url="https://web.libera.chat/#fink">the #fink IRC channel</link>,
        and someone should be able to help.</li>
    </ol>
</section>

<section name="downloading"><title>File Download Policy</title>
    <p>Packages are not to download any files during the unpack, patch, compile, install,
    or build phases of the <xref chapter="reference" section="build">build process</xref>.  Any large patches (i.e.
    larger than can be accommodated conveniently in a PatchFile) that need to be applied should
    set up as additional Sources in accordance with the <xref chapter="policy" section="sources">
    Source Policy.</xref></p>
    <p>Packages may download data in a PostInstScript after they have been installed on the system,
    under some limited circumstances:</p>
    <ul>
        <li>No updates to the package itself are allowed.</li>
        <li>The nature of the data is such that it couldn't easily be packaged for Fink.  E.g.
        virus definitions for <filename>clamav</filename> can be downloaded during this phase,
        because they change continually.</li>
    </ul>
    <p>If you are unsure, contact <link url="mailto:fink-core@lists.sourceforge.net">the Fink Core
    Team</link>.</p> 
</section>
<!-- end translation -->



</chapter>
<chapter filename="fslayout">
<title>Organisation des fichiers</title>
<shorttitle>Organisation des fichiers</shorttitle>
<preface>
<p>Les règles d'organisation des fichiers suivantes font partie intégrante des règles de construction des paquets de Fink.</p>
</preface>
<section name="fhs"><title>Hiérarchie standard des fichiers</title>
<p>Fink suit l'esprit de <link url="http://www.pathname.com/fhs/">Filesystem Hierarchy Standard</link> - Norme de hiérarchie du système de fichiers, ou FHS en raccourci. Il ne peut qu'en suivre l'esprit car FHS a été conçu pour les vendeurs de systèmes qui ont le contrôle des arborescences <filename>/</filename> et <filename>/usr</filename>. Fink n'est qu'une distribution supplémentaire qui ne contrôle que son répertoire (ou préfixe) d'installation. Les exemples ci-dessous utilisent le préfixe par défaut, soit <filename>/opt/sw</filename>.</p>
</section>
<section name="dirs"><title>Répertoires</title>
<p>Les fichiers doivent être placés dans les sous-répertoires suivant de l'arborescence :</p>
<itemtable labeld="Utilisation" labelt="Répertoire">
<item><itemt><filename>/opt/sw/bin</filename></itemt>
<itemd>
<p>Ce répertoire est dédié aux exécutables généraux. Il n'existe pas de sous-répertoire.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/sbin</filename></itemt>
<itemd>
<p>Ce répertoire correspond aux exécutables pour administrateurs système. Les démons lancés en tâche de fond y sont placés. Il n'y a pas de sous-répertoire.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/include</filename></itemt>
<itemd>
<p>Ce répertoire stocke les headers C et C++. On peut créer autant de sous-répertoires que nécessaire. Si un paquet installe des headers qui peuvent être confondus avec des headers standard C, les headers du paquet <em>doivent</em> être installés dans un sous-répertoire.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/lib</filename></itemt>
<itemd>
<p>Ce répertoire est destiné aux fichiers de données et bibliothèques dépendants de l'architecture du système. Les bibliothèques statiques et partagées doivent être placées dans <filename>/opt/sw/lib</filename>, sauf s'il existe une bonne raison pour ne pas le faire. C'est également là que sont placés les exécutables qui ne doivent pas être directement lancés par l'utilisateur (dans le cas contraire, ils sont placés dans libexec).</p>
<p>On peut créer un sous-répertoire spécifique à un paquet, afin d'y mettre des données privées ou des modules chargeables. Pensez à utiliser des noms de répertoire qui garantissent la compatibilité entre versions. Il est bon d'utiliser le numéro de version majeur du paquet dans le nom du sous-répertoire ou à un niveau inférieur de la hiérarchie ; par exemple, <filename>/opt/sw/lib/perl5</filename> ou <filename>/opt/sw/lib/apache/1.3</filename>. Faites attention si vous utilisez le type d'hôte dans le nom des répertoires créés. Un sous-répertoire nommé <code>powerpc-apple-darwin1.3.3</code> ne garantit pas la compatibilité entre versions ; utilisez plutôt <code>powerpc-apple-darwin1.3</code> ou <code>powerpc-apple-darwin</code>.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/lib/ppc64</filename>
<filename>/opt/sw/lib/x86_64</filename></itemt>
<itemd>
<p>Ce répertoire est dédié aux bibliothèques 64-bit. Le répertoire <filename>/opt/sw/lib/ppc64</filename> est utilisé sous architecture powerpc et le répertoire <filename>/opt/sw/lib/x86_64</filename> sous architecture i386. Les bibliothèques combinées (fat) doivent être enregistrées dans le répertoire <filename>/opt/sw/lib</filename>.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/share</filename></itemt>
<itemd>
<p>Ce répertoire sert aux fichiers de données indépendants de l'architecture. Les mêmes règles que celles en vigueur pour <filename>/opt/sw/lib</filename> s'appliquent ici. Quelques sous-répertoires courants sont décrits ci-dessous.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/share/man</filename></itemt>
<itemd>
<p>Ce répertoire contient les pages de manuel. Son arborescence suit celle des sections courantes. Chaque programme installé dans <filename>/opt/sw/bin</filename> et <filename>/opt/sw/sbin</filename> doit avoir une page de manuel associée dans ce répertoire.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/share/info</filename></itemt>
<itemd>
<p>Ce répertoire contient la documentation en format Info (produit à partir de sources Texinfo). La maintenance du fichier <code>dir</code> est automatisée par la version Debian du programme <code>install-info</code> (qui fait partie du paquet <code>dpkg</code>). Utilisez le champ de description <code>InfoDocs</code> pour générer le code approprié utilisé par les scripts de paquet <code>postinst</code> et <code>prerm</code>. Fink s'assure qu'aucun paquet n'installe un fichier <code>dir</code> de lui-même. Il n'y a pas de sous-répertoire.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/share/doc</filename></itemt>
<itemd>
<p>Ce répertoire contient la documentation autre que les pages de manuel ou les documents Info. Les fichiers README, LICENSE et COPYING sont placés dans ce répertoire. Chaque paquet doit y créer un sous-répertoire, dont le nom est basé sur celui du paquet. Le nom du sous-répertoire ne doit pas contenir de numéro de version (sauf s'il fait lui-même partie du nom du paquet). Conseil : utilisez <code>%n</code>.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/share/locale</filename></itemt>
<itemd>
<p>Ce répertoire contient les catalogues de messages de traduction.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/var</filename></itemt>
<itemd>
<p>Le répertoire <filename>var</filename> contient les données variables. Ceci inclut les répertoires spool (fichiers en attente de traitement), les fichiers verrous (lock), les bases de données des variables d'état (db), les données variables des jeux (games) et les fichiers d'historique (log).</p>
</itemd></item>
<item><itemt><filename>/opt/sw/etc</filename></itemt>
<itemd>
<p>Ce répertoire contient les fichiers de configuration. Quand un paquet possède plus d'un ou deux fichiers de configuration, un sous-répertoire doit être créé. Le nom du sous-répertoire doit être celui du paquet ou d'un de ses programmes, de façon à l'identifier facilement.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/src</filename></itemt>
<itemd>
<p>Ce répertoire sert à stocker et compiler le code source. Un paquet ne doit rien installer dans ce répertoire.</p>
</itemd></item>
<!-- start translation -->
<item><itemt><filename>/opt/sw/Applications</filename></itemt>
<itemd>
<p>This directory is for storing OS X-style applications which are launched by double-clicking rather than from the command line.</p>
</itemd></item>
<item><itemt><filename>/opt/sw/Library/Frameworks</filename></itemt>
<itemd>
<p>This directory is for storing OS X-style frameworks, sometimes used by OS X-style applications.</p>
</itemd></item>
<!-- end translation -->
</itemtable>
</section>
<section name="avoid"><title>À éviter</title>
<p>Aucun autre répertoire que ceux mentionnés ci-dessus ne doit être créé dans <filename>/opt/sw</filename>. En particulier, les répertoires suivant ne doivent pas être utilisés : <filename>/opt/sw/man</filename>, <filename>/opt/sw/info</filename>, <filename>/opt/sw/doc</filename>, <filename>/opt/sw/libexec</filename> et <filename>/opt/sw/lib/locale</filename>.</p>
</section>
</chapter>
<chapter filename="compilers"><title>Compilateurs</title>
<shorttitle>Compilateurs</shorttitle>
<preface>
<p>Fink utilise la famille des compilateurs gcc, tel qu'ils sont fournis par Apple Computer sur le site Apple Developer Connection. Il existe différentes versions de gcc et chaque système Mac OS X en comporte, en général, plusieurs.</p>
<p>Cette partie explique quelques-unes des façons dont Fink gère ces différentes versions de gcc. Un courriel posté sur la liste de diffusion de Fink comporte <link 
url="http://www.mail-archive.com/fink-devel@lists.sourceforge.net/msg11877.html"> de plus amples explications</link>.</p>
</preface>
<section name="versions"><title>Versions du compilateur</title>
<p>Comme ces compilateurs évoluent, il y a plusieurs "distributions" de fink différentes pour s'adapter à ces changements.</p>
<p>Chaque distribution comporte certaines valeurs par défaut pour les compilateurs gcc et g++, qui correspondent à ceux qu'un utilisateur compilant à partir des sources est censé avoir installés. Vous pouvez donc compter sur le fait qu'un appel direct à "gcc" ou "g++" à partir d'un paquet utilisera ces valeurs par défaut. Si vous avez besoin d'utiliser une valeur différente (par exemple, durant la transition vers une nouvelle distribution), le fichier .info du paquet doit le spécifier en utilisant les versions binaires fournies par Apple. La façon exacte de le faire dépend du système de compilation du logiciel, mais pour de nombreux paquets, on peut utiliser les champs fink <code>SetCC</code> et <code>SetCXX</code> à cette fin. Par exemple, vous pouvez passer à la version 3.3 du compilateur g++ avec le champ <code>SetCXX: g++-3.3</code>. Vérifiez le résultat lors de la compilation afin de vous assurer que le bon compilateur est utilisé.</p>
<p>La distribution 10.1 part du principe que la version du compilateur est la version 2.95 ; la distribution 10.2 que la version du compilateur est la version 3.1 ; les distributions 10.2-gcc3.3 et 10.3 que la version du compilateur est la version 3.3. Pour la distribution 10.4-transitional, c'est un peu plus compliqué : g++-3.3 est utilisé avec gcc-4.0. Cela changera de nouveau dans la distribution 10.4 où l'on utilisera gcc-4.0 et g++-4.0.</p>
<p>À partir de la distribution 10.4-transitional, une nouvelle méthode a été introduite pour assurer la sélection du bon compilateur g++. Durant la compilation, un répertoire <filename>/opt/sw/var/lib/fink/path-prefix-g++-XXX</filename> (où XXX est le numéro de version) est ajouté au PATH. Ce répertoire contient des scripts shell qui se charge de sélectionner la bonne version de g++.</p>
</section>
<section name="abi"><title>L'ABI g++</title>
<p>L'ABI g++ a changé trois fois depuis la naissance de Mac OS X : elle est différente pour les versions 2.95, 3.1, 3.3 et 4.0. Ces différentes ABI ne sont pas compatibles entre elles, et toute bibliothèque utilisant du code C++ et liée à un projet doit être compilée avec la même ABI que celle en cours d'utilisation.</p>
<p>Fink garde trace de l'ABI g++ à l'aide du champ GCC. Ce champ doit être défini par tout paquet qui invoque les compilateurs g++ ou c++. Il NE doit PAS être défini pour les paquets qui n'invoquent pas ces compilateurs. Quand un changement d'ABI intervient, il faut vérifier le champ GCC de toutes les dépendances d'un paquet. Quand toutes les dépendances ont été mises à jour, le paquet lui-même peut être mis à jour. Les versions des dépendances doivent être modifiées pour assurer que les utilisateurs aient bien toutes les dépendances correctes mises à jour avant de tenter de compiler la nouvelle version d'un paquet.</p>
<p>Si un petit nombre de paquets dépendent uniquement les uns des autres, on peut laisser la version de l'ABI précédente en place, s'ils ne sont pas prêts pour la mise à jour. Quand la mise à jour aura lieu, ils seront tous mis à jour en même temps avec une version correcte sur tous les paquets. C'est pourquoi il est préférable de ne mettre à jour les paquets qu'au moment de la distribution.</p>
<p>Fink utilise le champ GCC pour s'assurer que les utilisateurs ont bien la bonne version du compilateur g++ installée sur leur système. Si le champ GCC est défini par le paquet, fink vérifie que la commande <code>gcc_select</code> a reçu la valeur en cours. Cette valeur est 3.3 pour les versions 10.2 et 10.3 de Mac OS X, et 4.0 pour la version 10.4 de Mac OS X. La commande <code>gcc_select</code> n'était pas disponible antérieurement à la version 10.2 de Mac OS X.</p>
</section>
</chapter>
<chapter filename="reference">
<title>Référence</title>
<shorttitle>Référence</shorttitle>
<section name="build"><title>Construction d'un paquet</title>
<p>Pour comprendre l'utilité de certains des champs, vous devez d'abord savoir comment Fink construit un paquet. La construction se déroule en cinq phases : décompression, application des rustines, compilation, installation et construction proprement dite. L'exemple ci-dessous correspond à une installation dans <filename>/opt/sw</filename> du paquet gimp-1.2.1-1.</p>
<p>Lors de la <em>phase de décompression</em>, le répertoire <filename>/opt/sw/src/fink.build/gimp-1.2.1-1</filename> est créé et l'archive tar y est décompressée (il peut y avoir plusieurs archives tar). Dans la plupart des cas, un répertoire gimp-1.2.1, contenant le source, sera créé ; toutes les étapes suivantes seront exécutées dans ce répertoire (par exemple <filename>/opt/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>). Les champs SourceDirectory, NoSourceDirectory et Source<em>N</em>ExtractDir permettent de contrôler quels sont les répertoires à utiliser.</p>
<p>Lors de la <em>phase d'application des rustines</em>, le code source est modifié par les rustines, pour qu'il compile sous Darwin. Les actions dérivées des champs UpdateConfigGuess, UpdateLibtool, Patch et PatchScript sont exécutées dans l'ordre d'énumération de ces champs.</p>
<p>Lors de la <em>phase de compilation</em>, le source est configuré et compilé. En général, cela correspond au lancement du script <code>configure</code> avec certains paramètres, puis à l'exécution de la commande <code>make</code>. Voir la description du champ CompileScript pour de plus amples informations. Si les séries de tests sont activées (nouvelle fonctionnalité accessible en mode mainteneur dans la version 0.25 de fink), le script TestScript est lancé juste après le script CompileScript.</p>
<p>Lors de la <em>phase d'installation</em>, le paquet est installé dans un répertoire temporaire, <filename>/opt/sw/src/fink.build/root-gimp-1.2.1-1</filename> (= %d). (Notez la partie "root-"). Tous les fichiers qui sont normalement installés dans <filename>/opt/sw</filename> sont installés dans <filename>/opt/sw/src/fink.build/root-gimp-1.2.1-1/opt/sw</filename> (= %i = %d%p). Voir la description du champ InstallScript pour de plus amples informations.</p>
<p>(<em>À partir de fink 0.9.9.</em>, il est possible de générer plusieurs paquets à partir d'une seule description de paquet en utilisant le champ <code>SplitOff</code>. À la fin de la phase d'installation, des répertoires d'installation distincts sont créés pour chaque paquet à construire et les fichiers sont placés dans le répertoire approprié).</p>
<p>Lors de la <em>phase de construction</em>, un fichier binaire (.deb) est construit à partir du répertoire temporaire. On ne peut agir directement sur cette étape, néanmoins différentes informations issues de la description du paquet sont utilisées afin de générer un fichier de <filename>contrôle</filename> pour dpkg.</p>
</section>
<section name="fields"><title>Champs</title><p>Nous avons classé les champs en plusieurs catégories. Cette liste n'est pas forcément exhaustive. <code>:-)</code></p>
<p><em>Données initiales :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>Package</itemt>
<itemd>
<p>Nom du paquet. Peut contenir des minuscules, des nombres ou les caractères spéciaux suivants : '.', '+' et '-'. Pas de trait de soulignement ('_'), ni de majuscules. Champ obligatoire.</p>
<p>Seuls les raccourcis %N, %{Ni}, %type_raw[] et %type_pkg[] sont applicables à ce champ.</p>
<p>Selon les règles de Fink, un paquet donné doit toujours être compilé avec les mêmes options activées. Si un paquet peut avoir plusieurs variantes (voir la documentation sur le champ <code>Type</code>), vous devez encoder les informations concernant la variante dans le champ <code>Package</code> (voir la documentation sur le raccourci %type_pkg[]). De cette façon, chaque variante possédera un nom unique. Le nom du paquet indique quelles variantes sont incluses. Notez que l'usage des raccourcis %type_pkg[] et %type_raw[] dans le nom du paquet est récent et grandement incompatible avec les anciennes versions de fink ; les descriptions de ces paquets doivent être insérés dans un champ <code>InfoN</code> avec N>=2.</p>
</itemd></item>
<item><itemt>Version</itemt>
<itemd>
<p>Le numéro de version en amont. Même limitations que pour le champ Package. Champ obligatoire.</p>
<p>Notez que certains programmes utilisent une numérotation de version non standard qui peut provoquer des problèmes de tri, ou bien utilisent des caractères non autorisés dans ce champ. Dans ce cas, vous devez convertir la valeur de la version originale en une valeur acceptable qui permette de trier les versions correctement. Si vous ne savez pas comment les versions seront triées, utilisez la commande <code>dpkg</code> à l'invite d'un shell. Par exemple :</p>
<codeblock>
dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo "vrai"
</codeblock>
<p>imprimera &quot;vrai&quot; car le numéro de version &quot;1.2.1&quot; est inférieur au numéro de version &quot;1.3&quot;. Voir la page de manuel <code>dpkg</code> pour de plus amples informations.</p>
</itemd></item>
<item><itemt>Revision</itemt>
<itemd>
<p>Le numéro de révision du paquet. Incrémentez ce numéro quand vous faites une nouvelle description pour la même version en amont. Les numéros de révision commencent à 1. Champ obligatoire.</p>
<p> Les règles de Fink stipule vous <em>devez</em> incrémenter le champ <code>Revision</code> <em>chaque fois</em> que vous changez un fichier <filename>.info</filename>, si les changements entraînent une modification de la forme binaire (compilée) du paquet (le fichier <filename>.deb</filename>). Cela s'applique aux changements opérés dans le champ <code>Depends</code> ou les autres champs incluant une liste de paquets, ainsi qu'à l'ajout, la suppression ou le changement de nom des paquets splitoff, ou bien encore le déplacement de fichiers d'un splitoff à un autre. Quand la migration d'un paquet vers une nouvelle arborescence (par exemple de 10.2 à 10.3) conduit à des modifications de cette nature, vous devez incrémenter le champ <code>Revision</code> de 10 unités dans la nouvelle arborescence, de façon à garder la possibilité de mises à jour ultérieures dans l'arborescence la plus ancienne.</p>
</itemd></item>
<item><itemt>Architecture</itemt>
<itemd>
<p>Liste d'architectures système basées sur la CPU et séparées par des virgules sur lesquelles le paquet et tout paquet splitoff sont censés tourner. Pour le moment, les seules valeurs valides sont <code>powerpc</code> et <code>i386</code>. Si ce champ est présent et non vide après vérification conditionnelle, fink ignorera la ou les descriptions de paquet(s) correspondante(s) si l'architecture système de la machine locale n'est pas comprise dans la liste. Si le champ est omis ou s'il est vide, le paquet est géré comme si toutes les architectures système étaient reconnues. Introduit dans une version CVS de fink postérieure à la version 0.24.11.</p>
<p>Pour l'instant, l'utilisation la plus courante de ce champ est prévue pour les paquets qui requièrent un compilateur antérieur à gcc-4.0 (ou pour les paquets qui en dépendent). Dans ce cas, la valeur du champ sera <code>powerpc</code>.
</p>
<p>Ce champ admet la syntaxe conditionnelle standard pour toute valeur de la liste. Les raccourcis clavier peuvent y être utilisés (voir le champ <code>Depends</code> pour de plus amples informations). Il s'ensuit que certaines variantes peuvent être restreintes à certaines architectures systèmes. Par exemple :</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.1 5.8.4 5.8.6)
  Architecture: (%type_pkg[perl] = 581) powerpc
</codeblock>
<p>est interprété comme une variante foo-pm581 pour l'architecture système <code>powerpc</code>, le champ restant vide pour toute autre variante. N'oubliez pas que le fait d'omettre une certaine valeur d'architecture ne signifie pas que le paquet n'est pas censé tourner sur l'architecture système en question.</p>
</itemd></item>



<!-- start translation -->
<item><itemt>Distribution</itemt>
<itemd>
<p>
A comma-separated list of distribution(s) for which the package
(and any splitoff packages) are intended.
At present, the only valid values for distribution are
<code>10.4</code>,
<code>10.5</code>,
<code>10.6</code>,
<code>10.7</code>,
<code>10.8</code>,
<code>10.9</code>,
<code>10.10</code>,
<code>10.11</code>,
<code>10.12</code>,
<code>10.13</code>,
<code>10.14</code>,
<code>10.14.5</code>,
and <code>10.15</code>
. If this field is present and not blank after
conditional handling, fink will ignore the package description(s) if
the local machine distribution is not listed. If the field is omitted
or the value is blank, all distributions are assumed.
(Introduced in fink 0.26.0.)
</p>
<p>
Since Fink's <code>10.9</code> through <code>10.14.5</code> distributions share
a common set of finkinfo files, the most common use of this field will be for 
packages which are suitable for one of those distributions but not the
other.
</p>
<p>
This field supports the standard conditional syntax for any value in
the value list and percent-expansions can be used (see
the <code>Depends</code> field for more information). In this manner,
certain variants can be restricted to certain architectures. For
example:
</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.1 5.8.6)
  Distribution: (%type_pkg[perl] = 581) 10.3, (%type_pkg[perl] = 581) 10.4
</codeblock>
<p>
will result in the field for the foo-pm581 variant
being <code>10.3, 10.4</code> and the field being blank for the 
foo-pm586 variant.
</p>
<p>Since python 2.5 is not available in the 10.7+ distributions, and the
available perl versions vary by distribution, these package types provide
a common use of this field.  For reference, we note the availabilty of
various perl versions in the 10.3 through 13.0 distributions
(<em>bolded</em> systems indicate system-perl at that version):
</p>
<codeblock>
    perl 5.6.0:  10.3
    perl 5.8.0:  10.3
    perl 5.8.1:  <em>10.3</em>, 10.4
    perl 5.8.4:  10.3, 10.4
    perl 5.8.6:  10.3, <em>10.4</em>, 10.5
    perl 5.8.8:        10.4, <em>10.5</em>, 10.6
    perl 5.10.0:             10.5, <em>10.6</em>
    perl 5.12.3:                         <em>10.7</em>, 10.8, 10.9
    perl 5.12.4:                         10.7, <em>10.8</em>, 10.9
    perl 5.16.2:                         10.7, 10.8, <em>10.9</em>, 10.10, 10.11, 10.12, 10.13
    perl 5.18.2:                         10.7, 10.8, 10.9, <em>10.10</em>, <em>10.11</em>, <em>10.12</em>, <em>10.13</em>, <em>10.14</em>, 10.14.5, 10.15, 11.0, 11.3, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.18.4:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, <em>10.14.5</em>, <em>10.15</em>, 11.0, 11.3, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.28.2:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, <em>11.0</em>, 11.3, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.30.2:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, 11.0, <em>11.3</em>, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.30.3:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, 11.0, 11.3, <em>12.0</em>, <em>13.0</em>, <em>14.0</em>, 14.4, 15.0
    perl 5.34.1:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, 11.0, 11.3, 12.0, 13.0, 14.0, <em>14.4</em>, <em>15.0</em>
</codeblock>
<p>A way to include all variants in a single finkinfo file is as follows.
</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.6.0 5.8.0 5.8.1 5.8.4 5.8.6 5.8.8 5.10.0 5.12.3)
  Distribution: &lt;&lt;
   (%type_pkg[perl] = 560) 10.3, (%type_pkg[perl] = 580) 10.3, 
   (%type_pkg[perl] = 581) 10.3, (%type_pkg[perl] = 581) 10.4, 
   (%type_pkg[perl] = 584) 10.3, (%type_pkg[perl] = 584) 10.4, 
   (%type_pkg[perl] = 586) 10.3, (%type_pkg[perl] = 586) 10.4, (%type_pkg[perl] = 586) 10.5,
   (%type_pkg[perl] = 588) 10.4, (%type_pkg[perl] = 588) 10.5, (%type_pkg[perl] = 588) 10.6,
   (%type_pkg[perl] = 5100) 10.5, (%type_pkg[perl] = 5100) 10.6,
   (%type_pkg[perl] = 5123) 10.7
  &lt;&lt;
</codeblock>
<p>Note that we do not include old
distributions, such as 10.2 or 10.4-transitional, since the versions of
fink which are relevant for them do not recognize this field.
</p>
</itemd></item>
<!-- end translation -->



<item><itemt>Epoch</itemt>
<itemd>
<p><em>Introduit à partir de fink 0.12.0.</em> Ce champ facultatif peut être utilisé pour spécifier l'ère du paquet (défaut 0 si ce champ n'est pas renseigné). Pour de plus amples informations, voir <link url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian Policy Manual</link>. Comme Fink et quelques-uns des outils Debian sous-jacents utilisent nom-version-revision comme identifiant unique d'un paquet, vous ne devez pas créer deux paquets qui ne diffèrent que par le numéro d'ère.</p>
<p>Quant elle est utilisée dans la version, l'ère apparaît avant la valeur de la version, séparée d'elle par deux-points (1:3.14-2). Notez que l'ère ne fait partie ni de <code>%v</code>, ni de <code>%f</code>. Si vous ajoutez un champ ère au fichier de description d'un paquet, vous pouvez être amené à l'introduire également dans ses dépendances. Par exemple, si vous ajoutez <code>Epoch: 1</code> à foo et que foo-dev déclare <code>Depends: foo-shlibs (= %v-%r)</code>, vous devez le changer en <code>Depends: foo-shlibs (= %e:%v-%r)</code>.
</p>
</itemd></item>
<item><itemt>Description</itemt>
<itemd>
<p>Courte description du paquet (répond à la question qu'est-ce c'est ?). C'est une description d'une ligne qui est affichée sous forme de liste, elle doit donc être courte et bien ciblée. Elle peut avoir moins de 45 caractères, mais ne peut dépasser 60 caractères. Il n'est pas nécessaire d'indiquer le nom du paquet, il sera affiché de toute façon. Champ obligatoire.</p>
</itemd></item>
<item><itemt>Type</itemt>
<itemd>
<p>Peut être <code>bundle</code>. Les paquets lots sont utilisés pour regrouper plusieurs paquets. Ils n'ont que des dépendances, mais ni code ni fichiers installés. Les champs Source, PatchScript, CompileScript, InstallScript et ceux qui leur sont liés sont ignorés pour ce type de paquets.</p>
<p><code>nosource</code> est un type très voisin. Il sert à indiquer qu'il n'y a pas d'archive tar source. Rien n'est téléchargé et la phase de décompression crée simplement un répertoire vide. Néanmoins, les phases d'application de rustine, de compilation et d'installation sont exécutées normalement. De cette façon, on peut incorporer tout le code avec une rustine, ou créer quelques répertoires avec InstallScript. À partir de la version 0.18.0 de fink, on peut utiliser <code>Source: none</code> pour obtenir le même résultat. Ceci permet d'utiliser "Type" pour d'autres usages (<code>Type: perl</code>, etc...).</p>
<p>À partir de fink 0.9.5, il existe un type <code>perl</code>, qui permet d'offrir un choix de valeurs par défaut pour les scripts de compilation et d'installation. À partir de fink 0.13.0, il existe une nouvelle variante de ce type, <code>perl $version</code>, où $version est une version spécifique de perl, constituée de trois chiffres séparés par un point, par exemple : <code>perl 5.6.0</code>.</p>
<p>Dans une version CVS postérieure à fink-0.19.2, l'utilisation de langage/langage-version a été généralisée pour permettre à tout mainteneur de définir des types et sous-types associés et ainsi d'utiliser plus d'un type par paquet. Les types et sous-types sont des chaînes de caractères arbitraires ; toutefois, les blancs sont interdits et les parenthèses, virgules, crochets et signe pourcentage ne doivent pas être utilisés. Les raccourcis ne sont pas interprétés et le type (mais non le sous-type) est converti en minuscules. Les valeurs du type sont définies dans une liste , chaque valeur étant séparée de la suivante par des virgules ; chaque valeur peut elle-même avoir une liste de sous-types associés séparés par des blancs.</p>
<p>De plus, il existe un concept de &quot;variantes&quot;, qui permet de décrire dans un fichier .info unique une famille de paquets étroitement liés, ayant chacun des options différentes activées. La clé de ce processus est l'utilisation d'une liste de sous-types. Au lieu d'une simple chaîne de caractères, on utilise une liste de chaînes de caractères séparés par des blancs et mise entre parenthèses. Fink clone le fichier de description du paquet pour chaque sous-type de la liste et remplace cette liste par un unique sous-type dans le clone. Par exemple :</p>
<codeblock>Type: perl (5.6.0 5.8.1)</codeblock>
<p>provoque la création de deux descriptions de paquet, une qui se comporte comme si on avait <code>Type: perl 5.6.0</code> et l'autre comme si on avait <code>Type: perl 5.8.1</code>. Le sous-type spécial &quot;(boolean)&quot; est un raccourci pour une liste contenant le type lui-même et un point. Ainsi les deux formes suivantes sont identiques :</p>
<codeblock>
Type: -x11 (boolean)
Type: -x11 (-x11 .)
</codeblock>
<p>L'interprétation de la liste de sous-types / clonage du paquet est récursive. S'il y a plusieurs types avec des listes de sous-types, on obtient toutes les combinaisons possibles :</p>
<codeblock>Type: -ssl (boolean), perl (5.6.0 5.8.1)</codeblock>
<p>Dans les autres champs, on accède à un sous-type donné de variante en utilisant les fonctions de pseudo-hachage %type_raw[] et %type_pkg[]. Voici deux exemples de fragments de fichiers .info :</p>
<codeblock>
Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.6.0 5.8.1)
Depends: perl%type_pkg[perl]-core
 &lt;&lt;
</codeblock>
<codeblock>
Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [ &quot;%type_raw[-x11]&quot; == &quot;-x11&quot; ]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;
</codeblock>
<p>À partir de la version 0.26.0 de fink, il existe un champ spécial <code>Type: -64bit</code> qui contrôle un nouveau raccourci <code>%lib</code> et modifie la valeur par défaut du drapeau <code>LDFLAGS</code>. Quand on combine ce champ avec la construction %type_num[], ceci permet de construire à partir d'un seul fichier .info les versions 32-bit et 64-bit d'une bibliothèque. Voici un exemple :</p>
<codeblock>
Info2: &lt;&lt;
Package: foo%type_pkg[-64bit]
Type: -64bit (boolean)
Depends: (%type_raw[-64bit] = -64bit) 64bit-cpu
ConfigureParams: --libdir='${prefix}/%lib'
SplitOff: &lt;&lt;
 Package: %N-shlibs
 Files: %lib/libfoo.*.dylib
 Shlibs: &lt;&lt;
    %p/%lib/libfoo.1.dylib 1.0.0 %n (>= 1.0-1) %type_num[-64bit]
  &lt;&lt;
&lt;&lt;
&lt;&lt;
</codeblock>
</itemd></item>
<item><itemt>License</itemt>
<itemd>
<p>Ce champ indique la nature de la licence sous laquelle le paquet est distribué. Sa valeur doit être l'une de celles décrites plus haut dans la section <xref chapter="policy" section="licenses">Licences de paquet</xref>. De plus, ce champ ne doit être renseigné que si le paquet respecte effectivement les règles de construction des paquets, c'est-à-dire installe une copie de la licence dans le répertoire doc.</p>
</itemd></item>
<item><itemt>Maintainer</itemt>
<itemd>
<p>Nom et adresse e-mail de la personne responsable du paquet. Ce champ est obligatoire et ne doit mentionner qu'un nom et qu'une adresse e-mail sous le format suivant :</p>
<codeblock>Prénom Nom &lt;utilisateur@hôte.domaine.com&gt;</codeblock>
</itemd></item>
<item><itemt>InfoN</itemt>
<itemd>
<p>Ce champ permet à fink d'implémenter des changements de syntaxe incompatibles avec les versions précédentes dans les fichiers de description de paquet. Une version donnée de fink est configurée avec un nombre entier maximum "N", qu'il sait gérer. Tout paquet dont le champ InfoN est supérieur à ce nombre sera ignoré. Il ne faut donc utiliser ce mécanisme que dans les cas d'absolue nécessité, faute de quoi on priverait de ces paquets les personnes utilisant des versions plus anciennes de fink. Quand un autre champ doit utiliser un numéro InfoN spécifique, mention en est faite dans la description du champ. Pour utiliser ce mécanisme, il faut insérer l'ensemble de la description du paquet dans le champ InfoN. Voir plus haut la section "Format de fichier" pour une description de la syntaxe des champs constitués de plusieurs lignes. Voici les fonctionnalités ajoutées à chaque niveau InfoN, ainsi que la version la plus ancienne de fink qui les gère :</p>
<ul>
<li>
<code>Info2</code> (fink >= 0.20.0) : capacité à interpréter les raccourcis dans le champ <code>Package</code> principal du fichier .info et à utiliser les raccourci <code>%type_*</code> dans le champ <code>Package</code> des paquets <code>SplitOff</code> (et <code>SplitOff<em>N</em></code>).
</li>
<li>
<code>Info3</code> (fink>=0.25.0) : possibilité d'utiliser des retraits significatifs dans les fichiers .info, arrêt de la gestion des lignes multiples de la norme RFC-822, possibilité de mettre des commentaires dans les champs de listes de paquets.
</li>
<!-- start translation -->
<li>
<code>Info4</code> (fink>=0.26.2): adds %V expansion, and permits
<code>%lib</code> in <code>ConfigureParams</code> field.
</li>
<!-- end translation -->
</ul>
</itemd></item>
</itemtable>
<p><em>Dépendances :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>Depends</itemt>
<itemd>
<p>Liste de paquets à installer pour que le paquet puisse compiler. L'interprétation des raccourcis a lieu dans ce champ (tout comme dans les autres champs de cette catégorie : BuildDepends, RuntimeDepends, Provides, Conflicts, Replaces, Recommends, Suggests et Enhances). C'est, en général, une liste de noms de paquets séparés par des virgules, mais Fink gère maintenant les clauses de choix et de version avec la même syntaxe que dpkg. En voici un exemple :</p>
<codeblock>Depends: daemonic (&gt;= 20010902-1), emacs | xemacs</codeblock>
<p>Notez qu'on ne peut indiquer de réelles options de dépendances. Si un paquet fonctionne avec ou sans un autre paquet, vous devez soit vous assurer que l'autre paquet n'est pas utilisé, même s'il est présent, soit l'ajouter à la liste des dépendances. Si vous voulez donner à l'utilisateur le choix entre les deux options, faîtes deux paquets distincts, par exemple : wget et wget-ssl.</p>
<p>Ordre des opérations : le &quot;OU&quot; logique (liste de choix exclusifs) a priorité sur le &quot;ET&quot; logique entre chaque paquet (ou jeu de choix) dans la liste séparée par des virgules. À moins de mettre des parenthèses comme celles utilisées en arithmétique, il n'y a aucun moyen de spécifier des groupes de choix ou de changer l'ordre des opérations dans le champ <code>Depends</code> et les champs similaires.</p>
<p>À partir d'une version CVS postérieure à la version 0.18.2 de fink, on peut utiliser des dépendances conditionnelles. Celles-ci sont indiquées en plaçant <code>(chaîne1 opérateur chaîne2)</code> avant le nom du paquet. L'interprétation des raccourcis se fait normalement, puis les deux chaînes sont comparées en fonction de l'<code>opérateur</code> utilisé, qui peut être : &lt;&lt;, &lt;=, =, !=, &gt;&gt;, &gt;=. Le paquet qui suit n'est considéré comme une dépendance que si la comparaison est vraie.</p>
<p>Vous pouvez utiliser ce format pour simplifier la maintenance de paquets similaires. Par exemple, elinks et elinks-ssl peuvent avoir :</p>
<codeblock>Depends: (%n = elinks-ssl) openssl097-shlibs, expat-shlibs</codeblock>
<p>Ce qui a le même effet que si elinks avait :</p>
<codeblock>Depends: expat-shlibs</codeblock>
<p>et elinks-ssl avait :</p>
<codeblock>Depends: openssl097-shlibs, expat-shlibs</codeblock>
<p>Vous pouvez aussi utiliser un autre type de syntaxe : <code>(chaîne de caractères)</code>, qui est &quot;vrai&quot; si la <code>chaîne de caractères</code> est non nulle. Par exemple :</p>
<codeblock>
Package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11
</codeblock>
<p>indiquera une dépendance du paquet x11 pour la variante nethack-x11, mais pas pour la variante nethack.</p>
<p>Notez que quand on utilise les champs Depends/BuildDepends pour les paquets de bibliothèques partagées, alors qu'il existe plus d'une version majeure disponible, il <em>ne faut pas</em> utiliser la syntaxe suivante :</p>
<codeblock>
Package: foo
Depends: id3lib3.7-shlibs | id3lib3.7-shlibs
BuildDepends: id3lib3.7-dev | id3lib4-dev
</codeblock>
<p>même si le paquet peut fonctionner avec l'une ou l'autre bibliothèque. Il faut en choisir une (de préférence, la version la plus élevée possible) et s'y tenir dans l'ensemble du paquet.</p>
<p>Comme cela a été expliqué dans la section <xref chapter="policy" section="sharedlibs">Librairies partagées</xref>, un seul des paquets -dev peut être installé à un instant donné, et chacun possède des liens de même nom qui peuvent se référer à des noms de fichiers différents dans le paquet associé -shlibs. Lors de la compilation du paquet foo, le nom réel du fichier (dans le paquet -shlibs) est codé en dur dans le binaire foo. Cela signifie que le paquet résultant nécessite le paquet -shlibs associé au -dev qui était installé au moment de la compilation. En conséquence, on ne peut indiquer dans le champ <code>Depends</code> que l'un quelconque des paquets est requis.</p>
<p>Auparavant, les paquets non essentiels dépendaient implicitement des paquets essentiels ; ce n'est plus vrai.</p>
</itemd></item>
<item><itemt>BuildDepends</itemt>
<itemd>
<p><em>Introduit dans fink 0.9.0.</em> Liste de dépendances utilisées uniquement lors de la compilation. Il sert à spécifier des outils (par exemple flex) qui doivent être présents pour compiler les paquets, mais qui ne sont pas nécessaires à l'exécution. Utilise la même syntaxe que Depends. Si les séries de tests sont activées, les dépendances du champs <code>TestDepends</code> sont ajoutés à cette liste.</p>
</itemd></item>
<item><itemt>RuntimeDepends</itemt>
<itemd>
<p><em>Introduit dans fink 0.32.0.</em>
<!-- start translation -->
A list of dependencies that is applied at run time only,
that is, when the package is being installed.
This can be used to list packages that must be present to
run the package, but which are not used at build time.
Supports the same syntax as Depends.
<!-- end translation -->
</p>
</itemd></item>
<item><itemt>Provides</itemt>
<itemd>
<p>Liste de noms de paquets séparés par des virgules que ce paquet est censé "fournir". Si un paquet nommé "pine" indique <code>Provides: mailer</code>, alors toute dépendance à "mailer" est considérée comme satisfaite si "pine" est installé. En général, on énumère aussi ces paquets dans les champs "Conflicts" et "Replaces".</p>
<p>Notez qu'aucun numéro de version n'est associé aux éléments Provides. Ils n'héritent pas du paquet parent qui contient la liste Provides, et il n'existe aucune syntaxe permettant d'indiquer un numéro de version dans le champ Provides lui-même. En outre, une dépendance contenant un numéro de version n'est pas satisfaite par un paquet qui a un champ Provides contenant le paquet dépendant. En conséquence, le fait d'avoir plusieurs variantes avec un champ Provides qui inclut un même paquet peut être dangereux, car cela revient à interdire l'utilisation des numéros de versions dans les dépendances. Par exemple, si foo-gnome et foo-nognome ont tous les deux un champ "Provides: foo", tout autre paquet contenant un champ "Depends: foo (> 1.1)" ne fonctionnera pas correctement.</p>
</itemd></item>
<item><itemt>Conflicts</itemt>
<itemd>
<p>Liste de noms de paquets séparés par des virgules qui ne doivent pas être installés en même temps que le paquet. Pour les paquets virtuels, on peut énumérer dans ce champ les noms des paquets fournis ; ils seront gérés correctement. Ce champ gère aussi les clauses de versions tout comme le champ Depends, mais pas les clauses de choix (cela n'aurait aucun sens). Si un paquet est nommé dans son propre champ Conflicts, il sera supprimé de cette liste (sans avertissement). (Introduit dans une version CVS de fink postérieure à la version 0.18.2).</p>
<p><em>Note :</em> Fink lui-même ignore ce champ à l'heure actuelle. Néanmoins, il est passé à dpkg et est géré en conséquence. Bref, il n'a d'effet qu'à l'exécution, pas à la compilation.</p>
</itemd></item>
<item><itemt>BuildConflicts</itemt>
<itemd>
<p>Liste de paquets qui ne doivent pas être installés lorsque le paquet est compilé. Ce champ peut être utilisé pour empêcher <code>./configure</code> ou le compilateur de détecter des headers debibliothèques ou pour éviter d'utiliser une certaine version d'un outil connue pour être boguée (par exemple, un bogue dans une certaine version de sed). Si les séries de tests sont activées, les paquets énumérés dans le champt <code>TestConflicts</code> sont ajoutés à cette liste.</p>
</itemd></item>
<item><itemt>Replaces</itemt>
<itemd>
<p>Utilisé en général avec "Conflicts", quand le paquet non seulement remplace les fonctions du paquet en conflit, mais a aussi des fichiers en commun. Sans ce champ, dpkg pourrait générer des erreurs lors de la phase d'installation du paquet, car certains fichiers appartiendraient toujours à un autre paquet. C'est aussi l'indication que les deux paquets en cause sont équivalents l'un l'autre, et que l'un peut être remplacé par l'autre. Si un paquet est nommé dans son propre champ Replaces, il sera supprimé (sans avertissement) de cette liste. (Introduit dans une version CVS de fink postérieure à la version 0.18.2).</p>
<p><em>Note :</em> Fink lui-même ignore ce champ à l'heure actuelle. Néanmoins, il est passé à dpkg et est géré en conséquence. Bref, il n'a d'effet qu'à l'exécution, pas à la compilation.</p>
</itemd></item>
<item><itemt>Recommends, Suggests, Enhances</itemt>
<itemd>
<p>Ces champs indiquent des relations supplémentaires spécifiques dans le même style que les autres champs de dépendances. Ces trois champs n'ont aucun effet sur l'installation via <code>dpkg</code> ou <code>apt-get</code>. Néanmoins, ils sont utilisés par <code>dselect</code> et d'autres interfaces pour aider l'utilisateur à faire des choix.</p>
</itemd></item>
<item><itemt>Pre-Depends</itemt>
<itemd>
<p>Une variante spéciale du champ Depends avec une sémantique plus stricte. Ce champ ne doit être utilisé qu'après en avoir discuté sur la liste de développeurs et qu'il soit apparu évident que cela était nécessaire.</p>
</itemd></item>
<item><itemt>Essential</itemt>
<itemd>
<p>Valeur booléenne qui signale les paquets essentiels. Ceux-ci sont installés lors du processus de bootstrap. <code>dpkg</code> refusera de supprimer les paquets essentiels du système, à moins d'utiliser des options spéciales, qui permettent de lever cette interdiction. Auparavant, les paquets non essentiels dépendaient implicitement des paquets essentiels ; ce n'est plus vrai.</p>
</itemd></item>
<item><itemt>BuildDependsOnly</itemt>
<itemd>
<p><em>Introduit dans fink 0.9.9.</em> Valeur booléenne qui indique qu'aucun autre paquet ne doit avoir un champ Depends le mentionnant, seul le champ BuildDepends est autorisé. Contrairement aux autres champs booléens, <code>BuildDependsOnly</code> a trois valeurs : indéfini (non spécifié) n'a pas le même sens que faux. Voir la section <xref chapter="policy" section="sharedlibs">Librairies partagées</xref> pour de plus amples informations.</p>
<p>À partir de la version 0.20.5 de fink, la présence ou l'absence de ce champ, et sa valeur s'il est présent, sont sauvegardées dans le fichier .deb à la construction du paquet. Par conséquent, <em>si vous changez la valeur de BuildDependsOnly, ou si vous l'ajoutez ou le supprimez, vous devez incrémenter le numéro de révision</em> du paquet.</p>
</itemd></item>
</itemtable>
<p><em>Phase de décompression :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>CustomMirror</itemt>
<itemd>
<p>Liste de sites miroirs. Chaque ligne correspond à un site miroir, sous le format suivant : <code>&lt;emplacement&gt;: &lt;url&gt;</code>. L'<em>emplacement</em> peut être un code continent (par exemple : <code>nam</code> - Amérique du Nord), un code pays (par exemple : <code>nam-us</code> - Amérique du Nord-États-Unis), ou bien autre chose ; les archives sont recherchées sur les miroirs dans l'ordre d'énumération de ces derniers. Exemple :</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&lt;&lt;</codeblock>
<p>Les codes des continents et des pays se trouvent dans le fichier <filename>/opt/sw/lib/fink/mirror/_keys</filename>, qui est partie intégrante des paquets fink et fink-mirrors.</p>
</itemd></item>
<item><itemt>Source</itemt>
<itemd>
<p>URL de l'archive tar du source. Ce doit être une URL HTTP ou FTP, mais Fink ne fait pas de vérification - il se contente de passer l'URL à wget. Ce champ gère un type spécial d'URL pour les miroirs : <code>miroir:&lt;nom-miroir&gt;:&lt;chemin-relatif&gt;</code>. Ainsi, la définition du miroir <em>nom-miroir</em> est récupérée dans le fichier de configuration de Fink, la partie <em>chemin-relatif</em> y est ajoutée, et c'est l'ensemble qui est utilisé comme réelle URL. Chaque <em>nom-miroir</em> reconnu est stocké dans le fichier <filename>/opt/sw/lib/fink/mirror/_list</filename>, qui fait partie du paquet fink ou du paquet fink-mirrors. Par ailleurs, l'utilisation de <code>custom</code> comme <em>nom-miroir</em> oblige Fink à utiliser le champ <code>CustomMirror</code>. L'interprétation des raccourcis a lieu avant utilisation de l'URL. N'oubliez pas que %n correspond à toutes les variantes du champ %type_, il est donc conseillé d'utiliser ici %{ni} (avec, éventuellement, des spécifications de %type_).</p>
<p>À partir de fink 0.18.0, <code>Source: none</code> indique qu'il n'y a pas de source à récupérer. Voir la description du champ <code>Type</code> pour de plus amples informations. La valeur <code>gnu</code> est un raccourci pour <code>mirror:gnu:%n/%n-%v.tar.gz</code> ; de même, <code>gnome</code> est un raccourci pour <code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code>. La valeur par défaut est <code>%n-%v.tar.gz</code> (correspond à un téléchargement ordinaire). Cette forme de définition implicite pour <code>Source</code> est obsolète (il est toujours possible de fournir un nom de fichier explicite ou d'opérer un téléchargement manuel).</p>
<p>Les sources nécessaires à la seule exécution des séries de tests doivent être placés à l'intérieur d'un bloc <code>InfoTest</code> et utilisés les champs de type <code>TestSource</code>.</p>
</itemd></item>
<item><itemt>Source<em>N</em></itemt>
<itemd>
<p>Quand un paquet est constitué de plusieurs archives tar, vous devez les énumérer en utilisant ces champs supplémentaires, où N commence à 2. Le premier fichier archive tar (sorte d'archive tar "principale") est indiqué dans <code>Source</code>, le second dans <code>Source2</code>, et ainsi de suite. Les règles sont les mêmes que celles en vigueur pour le champ Source, mais les raccourcis "gnu" et "gnome" ne sont pas interprétés - cela n'aurait aucune utilité par ailleurs. À partir d'une version CVS de fink postérieure à la version 0.19.2, vous pouvez utiliser n'importe quels nombres entiers N >= 2 (non nécessairement consécutifs). Néanmoins, les doublons ne sont pas autorisés.</p>
</itemd></item>
<item><itemt>SourceDirectory</itemt>
<itemd>
<p>Doit être utilisé quand la décompression de l'archive tar aboutit à la création d'un répertoire dont le nom est différent du nom de base de l'archive. En général, une archive tar nommée "foo-1.0.tar.gz" crée un répertoire nommé "foo-1.0". Si le répertoire créé porte un nom différent, indiquez-le dans ce champ. L'interprétation des raccourcis y est effectuée.</p>
</itemd></item>
<item><itemt>NoSourceDirectory</itemt>
<itemd>
<p>Donnez à ce paramètre booléen la valeur "true" si la décompression de l'archive tar ne crée pas de répertoire. En général, une archive tar nommée "foo-1.0.tar.gz" crée un répertoire nommé "foo-1.0". Si les fichiers sont simplement décompressés dans le répertoire en cours, utilisez ce champ et donnez-lui la valeur "true".</p>
</itemd></item>
<item><itemt>Source<em>N</em>ExtractDir</itemt>
<itemd>
<p>Normalement, une archive tar auxiliaire est extraite dans le même répertoire que l'archive tar principale. Si vous devez l'extraire dans un sous-répertoire spécifique, utilisez ce champ pour l'indiquer. Source2ExtractDir correspond, bien évidemment, à l'archive tar Source2. Voir ghostscript, vim et tetex comme exemples d'utilisation de ce champ.</p>
</itemd></item>
<item><itemt>SourceRename</itemt>
<itemd>
<p>Ce champ renomme une archive tar à la volée. Ceci est utile, par exemple, lorsque la version du source est encodée dans le nom du répertoire du serveur, mais que l'archive elle-même porte le même nom pour toutes les versions, comme <filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename>. Pour résoudre les problèmes que cela cause, vous pouvez utiliser quelque chose de similaire à :</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
<p>Dans l'exemple ci-dessus, l'archive tar sera sauvegardée sous <filename>/opt/sw/src/coolapp-1.2.3.tar.gz</filename>.</p>
</itemd></item>
<item><itemt>Source<em>N</em>Rename</itemt>
<itemd>
<p>Ce champ est semblable au champ <code>SourceRename</code>, mais il est utilisé pour renommer l'archive tar correspondant au champ <code>Source<em>N</em></code>. Voir context ou hyperref comme exemples d'utilisation de ce champ.</p>
</itemd></item>
<item><itemt>Source-MD5</itemt>
<itemd>
<p><em>Introduit dans fink 0.10.0.</em> Vous pouvez indiquer dans ce champ la somme de contrôle MD5 du fichier source. La valeur sera alors utilisée par Fink pour détecter les fichiers sources incorrects, c'est-à-dire les archives tar qui ne correspondent pas à celles que le créateur du paquet a utilisées. Les causes les plus courantes de ce type de problème sont : téléchargement incomplet de l'archive, mainteneurs en amont ayant changé l'archive sans le signaler, chevaux de Troie ou attaques similaires, etc... </p>
<p>Exemple :</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
<p>La somme de contrôle est calculée avec l'outil <code>md5sum</code>. Si vous voulez calculer la somme de contrôle de l'archive tar <filename>/opt/sw/src/apache_1.3.23.tar.gz</filename>, exécutez la commande suivante (le résultat est affiché au-dessous) :</p>
<codeblock>fingolfin% md5sum /opt/sw/src/apache_1.3.23.tar.gz 
4499443fa1d604243467afe64522abac  /opt/sw/src/apache_1.3.23.tar.gz</codeblock>
<p>La valeur affichée à gauche correspond à la valeur recherchée.</p>
</itemd></item>
<item><itemt>Source<em>N</em>-MD5</itemt>
<itemd>
<p><em>Introduit dans fink 0.10.0.</em> Ce champ est semblable au champ <code>Source-MD5</code>, mais il est utilisé pour indiquer la somme de contrôle MD5 de l'archive tar correspondant au champ <code>Source<em>N</em></code>.</p>
</itemd></item>
<item><itemt>Source-Checksum</itemt>
<itemd>
<p>
Alternative method to list the checksum for a source file. This field
takes a hash type, followed by the actual checksum. For example:
</p>
<codeblock>Source-Checksum: SHA256(5048f1c8fc509cc636c2f97f4b40c293338b6041a5652082d5ee2cf54b530c56)</codeblock>
<p>
Current valid checksums are <code>MD5</code>, <code>SHA1</code>, and
<code>SHA256</code>. The <code>shasum</code> tool can be used to
calculate SHA checksums:</p>
<codeblock>$ shasum -a 256 /opt/sw/src/libexif-0.6.22.tar.xz 
5048f1c8fc509cc636c2f97f4b40c293338b6041a5652082d5ee2cf54b530c56  /opt/sw/src/libexif-0.6.22.tar.xz
</codeblock>
<p>
The <code>Source-Checksum</code> field should only be used once per
.info file. If both the <code>Source-MD5</code> and
<code>Source-Checksum</code> fields are present,
<code>Source-Checksum</code> takes precedence.
</p>
</itemd></item>
<item><itemt>Source<em>N</em>-Checksum</itemt>
<itemd>
<p>
This is just the same as the <code>Source-Checksum</code> field, except that it
is used to specify the checksum of the tarball specified by the
corresponding <code>Source<em>N</em></code> field.
</p>
</itemd></item>
<item><itemt>TarFilesRename</itemt>
<itemd>
<p><em>Introduit dans fink 0.10.0.</em> Ce champ ne s'applique qu'aux fichiers sources utilisant le format tar.</p>
<p>Avec ce champ, vous pouvez renommer les fichiers d'une archive tar donnée durant l'extraction. Ceci est très utile pour gérer les problèmes dus au fait que le système de fichiers HFS+ ne tient pas compte de la casse. En effet, sur un système standard Mac OS X, les fichiers <filename>install</filename> et <filename>INSTALL</filename> ne sont pas distinguables. L'utilisation de ce champ permet d'éviter ces problèmes sans avoir à changer l'archive tar (comme on le faisait auparavant dans de tels cas).</p>
<p>Indiquez juste la liste des fichiers à renommer dans ce champ. Vous pouvez utiliser des caractères joker. Par défaut, à tout fichier spécifié dans la liste est ajouté le suffixe <code>_tmp</code>. Vous pouvez modifier ce comportement en utilisant la même syntaxe que celles des champs <code>Files</code> et <code>DocFiles</code>, c'est-à-dire en écrivant l'ancien nom suivi de deux-points, puis du nouveau nom. Exemple :</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: directory/INSTALL:directory/INSTALL.txt</codeblock>
</itemd></item><item><itemt>Tar<em>N</em>FilesRename</itemt>
<itemd>
<p><em>Introduit dans fink 0.10.0.</em> Ce champ est similaire au champ <code>TarFilesRename</code>, mais il est utilisé pour renommer l'archive tar correspondant au champ <code>Source<em>N</em></code>.</p>
</itemd></item>
</itemtable><!-- Patch Phase -->
<p><em>Phase d'application des rustines :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>UpdateConfigGuess</itemt>
<itemd>
<p>Valeur booléenne. Si elle est vraie ("true"), les fichiers config.guess et config.sub présents dans le répertoire de compilation sont remplacés par des versions reconnaissant Darwin. Ce remplacement se produit lors de la phase d'application des rustines avant que le script PatchScript soit exécuté. <em>N'utilisez</em> ce champ quand cas d'absolue nécessité, c'est-à-dire lorsque le script configure se termine inopinément par un message "unknown host" (système inconnu).</p>
</itemd></item>
<item><itemt>UpdateConfigGuessInDirs</itemt>
<itemd>
<p><em>Introduit dans une version CVS postérieure à la version 0.9.0.</em> Liste de sous-répertoires. A le même effet que UpdateConfigGuess, mais dans toute l'arborescence du source ; utile lorsque plusieurs fichiers config.guess existent dans différents répertoires du source. Auparavant, il fallait copier ou déplacer les fichiers dans le script PatchScript. Avec ce nouveau champ, il suffit de donner la liste des répertoires. Utilisez <code>.</code> pour mettre à jour les fichiers dans le répertoire de compilation.</p>
</itemd></item>
<item><itemt>UpdateLibtool</itemt>
<itemd>
<p>Valeur booléenne. Si elle est vraie ("true"), les fichiers ltconfig et ltmain.sh présents dans le répertoire de compilation sont remplacés par des versions reconnaissant Darwin. Ce remplacement se produit lors de la phase d'application des rustines avant que le script PatchScript soit exécuté. <em>N'utilisez</em> ce champ quand cas d'absolue nécessité. Certains paquets ne fonctionnent plus lorsqu'on modifie la version des scripts libtool. Voir la <link url="/doc/porting/libtool.php">page libtool</link> pour de plus amples informations.</p>
</itemd></item>
<item><itemt>UpdateLibtoolInDirs</itemt>
<itemd>
<p><em>Introduit dans une version CVS postérieure à la version 0.9.0.</em> Liste de sous-répertoires. A le même effet que UpdateLibtool ; utile lorsque plusieurs fichiers scripts libtool 1.3.x sont présents dans différents répertoires de l'arborescence du source. Auparavant, il fallait copier ou déplacer les fichiers dans le script PatchScript. Avec ce nouveau champ, il suffit de donner la liste des répertoires. Utilisez <code>.</code> pour mettre à jour les fichiers dans le répertoire de compilation.</p>
</itemd></item>
<item><itemt>UpdatePoMakefile</itemt>
<itemd>
<p>Valeur booléenne. Si elle est vraie ("true"), le fichier <filename>Makefile.in.in</filename> présent dans le sous-répertoire <filename>po</filename> est remplacé par une version modifiée. Ce remplacement se produit lors de la phase d'application des rustines avant que le script PatchScript soit exécuté.</p>
<p>La version modifiée prend en compte DESTDIR et garantit que les catalogues de messages seront placés dans <filename>/opt/sw/share/locale</filename>, et non pas dans <filename>/opt/sw/lib/locale</filename>. Assurez-vous, avant d'utiliser ce champ, qu'il est absolument nécessaire et que le paquet continuera à fonctionner. Vous pouvez exécuter <code>diff</code> pour trouver les différences entre la version du paquet et celle de Fink (située dans <filename>/opt/sw/lib/fink/update</filename>).</p>
</itemd></item>
<item><itemt>Patch</itemt>
<itemd>
<p>Le nom d'une rustine à appliquer avec <code>patch -p1 &lt;<em>nom-rustine</em></code>. Ne donnez que le nom du fichier ; le chemin est ajouté automatiquement devant le nom du fichier. L'interprétation des raccourcis y est effectuée, si bien qu'on trouve, en général : <code>%f.patch</code> ou <code>%n.patch</code>. La rustine est appliquée avant que le script PatchScript soit exécuté (s'il existe).</p>
<p>N'oubliez pas que %n inclut implicitement toutes les variantes %type_. Le cas échéant, utilisez %{ni} (éventuellement avec des variantes spécifiques %type_). Il est plus facile de gérer une seule rustine et de faire des changements spécifiques à certaines variantes dans le script <code>PatchScript</code> que de gérer une rustine par variante.</p>
</itemd></item>
<item><itemt>PatchScript</itemt>
<itemd>
<p>Liste de commandes à exécuter lors de la phase d'application des rustines. C'est là où vous pouvez placer les commandes qui corrigent ou modifient le paquet source. Voir plus loin la <xref chapter="reference" section="scripts">note au sujet des scripts</xref>. L'<xref chapter="format" section="percent">interprétation des raccourcis</xref> a lieu avant que les commandes ne soient exécutées. Il n'existe pas de script par défaut.</p>
</itemd></item>
</itemtable>
<p><em>Phase de compilation :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>Set<em>ENVVAR</em></itemt>
<itemd>
<p>Définit certaines variables d'environnement pendant les phases de compilation et d'installation. On peut utiliser ce champ pour passer des drapeaux de compilation, etc... aux scripts configure et aux Makefile. Les variables reconnues à l'heure actuelle sont : CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, DYLD_LIBRARY_PATH, JAVA_HOME, LD, LDFLAGS, LIBRARY_PATH, LIBS, MACOSX_DEPLOYMENT_TARGET, MAKE, MFLAGS, MAKEFLAGS. L'interprétation des raccourcis a lieu sur la valeur spécifiée, comme expliquée dans la section précédente. Exemple courant :</p>
<codeblock>SetCPPFLAGS: -no-cpp-precomp</codeblock>
<p>Certaines de ces variables ont des valeurs pré-établies par défaut. Si vous leur donnez une valeur, celle-ci sera ajoutée dans la liste devant la valeur par défaut. Les variables à valeur pré-établies sont les suivantes :</p>
<codeblock>
CPPFLAGS: -I%p/include
LDFLAGS: -L%p/lib
</codeblock>
<p>À partir de la version 0.26.0 de fink, il existe une exception à ces valeurs par défaut. Si le champ <code>Type: -64bit</code> a pour valeur <code>-64bit</code>, alors la valeur par défaut de la variable <code>LDFLAGS</code> est <code>-L%p/%lib -L%p/lib</code>.</p>
<p>Enfin, la variable MACOSX_DEPLOYMENT_TARGET a une valeur par défaut qui dépend de la version de Mac OS X en cours d'exécution, mais le fait d'affecter une valeur à cette variable pour un paquet donné remplace la valeur par défaut, elle ne vient pas s'ajouter devant la valeur par défaut.</p>
</itemd></item>
<item><itemt>NoSet<em>ENVVAR</em></itemt>
<itemd>
<p>Quand la valeur de ce champ est true (vraie), les valeurs par défaut des variables à valeurs pré-établies, telles CPPFLAGS, LDFLAGS et CXXFLAGS mentionnées ci-dessus, sont désactivées. Autrement dit, si vous ne voulez pas que LDFLAGS ait une valeur par défaut, utilisez <code>NoSetLDFLAGS: true</code>.</p>
</itemd></item>
<item><itemt>ConfigureParams</itemt>
<itemd>
<p>Paramètres supplémentaires à passer au script configure. (Voir CompileScript pour de plus amples informations). Pour les paquets qui ne sont pas de <code>Type: Perl</code>, le paramètre <code>--prefix=%p</code> est  ajouté avant la valeur de ce champ. À partir des versions de fink > 0.13.7, ce champ fonctionne aussi avec les modules perl <code>Type: Perl</code> ; il ajoute les paramètres à la chaîne perl par défaut Makefile.PL.</p>
<p>Si les séries de tests sont activées, la valeur du champ <code>TestConfigureParams</code> est ajoutée à ces paramètres.</p>
<p>À partir de la version 0.22.0 de fink, ce champ gère les expressions conditionnelles. La syntaxe est la même que celle utilisée dans le champ <code>Depends</code> et les autres champs basés sur des listes de paquets. L'expression conditionnelle s'applique au &quot;mot&quot; délimité par des espaces suivant immédiatement l'expression. Par exemple :</p>
<codeblock>
Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) \
 --with-x11 --disable-shared
</codeblock>
<p>passera les drapeaux <code>--mandir</code> et <code>--disable-shared</code> dans tous les cas de figure, mais ne passera le drapeau <code>--with-x11</code> qu'à la seule variante -x11.</p>
</itemd></item>
<item><itemt>GCC</itemt>
<itemd>
<p>Ce champ spécifie l'ABI-GCC utilisé par le code C++ du paquet (cela est indispensable, car l'ABI a changé deux fois au cours du temps; toute bibliothèque liée à du code C++ doit être compilée avec l'ABI résidant sur le système au moment de son utilisation).</p>
<p>Les valeurs autorisées sont les suivantes : <code>2.95.2</code> (ou <code>2.95</code>), <code>3.1</code>, <code>3.3</code> et <code>4.0</code>. Nous avons cru comprendre que les auteurs de GCC comptent stabiliser l'ABI-GCC à un moment donné ; nous espérons qu'elle ne changera pas de nouveau.</p>
<p>Le champ GCC n'a pas de valeur par défaut ; il est ignoré s'il n'est pas défini. Néanmoins il existe dans chaque arborescence une valeur attendue qui correspond au compilateur g++ par défaut pour cette arborescence. Ces valeurs sont les suivantes : <code>2.95</code> pour l'arborescence 10.1, <code>3.1</code> pour l'arborescence 10.2, <code>3.3</code> pour les arborescences 10.2-gcc3.3, 10.3 et 10.4-transitional, et <code>4.0</code> pour l'arborescence 10.4 à venir.</p>
<p>Notez que lorsque la valeur GCC est différente de la valeur par défaut, le compilateur doit être indiqué dans le paquet (en général, en utilisant les drapeaux CC ou CXX), et qu'une dépendance sur un des paquets (virtuels) gcc doit être spécifiée.</p>
<p>À partir de la version 0.13.8 de fink, quand ce champ est utilisé, la version de gcc est testée via <code>gcc_select</code>, et fink se termine avec un message d'erreur si la version requise n'est pas présente.</p>
<p>Ce champ a été ajouté pour faciliter la transition entre les compilateurs gcc, qui ont introduit une incompatibilité binaire entre bibliothèques ; cette incompatibilité concerne des parties de code C++ non reproduites dans les différentes versions.</p>
</itemd></item>
<item><itemt>CompileScript</itemt>
<itemd>
<p>Liste de commandes à exécuter durant la phase de compilation. C'est là qu'il faut mettre les commandes de configuration et de compilation du paquet. Voir plus loin la <xref chapter="reference" section="scripts">note au sujet des scripts</xref>. L'<xref chapter="format" section="percent">interprétation des raccourcis</xref> a lieu avant que les commandes ne soient exécutées. Normalement, les commandes sont les suivantes :</p>
<codeblock>./configure %c
make</codeblock>
<p>Elles conviennent pour les paquets utilisant GNU autoconf. Pour ceux de type perl (indiqué via le champ Type) dont la version perl n'est pas indiquée, les commandes par défaut (à partir de la version 0.13.4 de fink) sont les suivantes :</p>
<codeblock>perl Makefile.PL PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5 \
 INSTALLARCHLIB=%p/lib/perl5/darwin \
 INSTALLSITELIB=%p/lib/perl5 \
 INSTALLSITEARCH=%p/lib/perl5/darwin \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>Si le type est du style <code>perl $version</code> (où <code>$version</code> est, par exemple, 5.6.0), les commandes par défaut sont les suivantes :</p>
<codeblock>perl$version Makefile.PL \
 PERL=perl$version PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5/$version \
 INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%p/lib/perl5/$version \
 INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>où <code>$perlarchdir</code> est "darwin" pour les versions antérieures ou égales à 5.8.0, "darwin-thread-multi-2level" pour les versions postérieures ou égales à 5.8.1.</p>
</itemd></item>
<item><itemt>NoPerlTests</itemt>
<itemd> 
<p><em>Introduite dans une version de fink > 0.13.7.</em> Valeur booléenne spécifique aux paquets de module perl. Si sa valeur est true (vraie), la partie <code>make test</code> de <code>CompileScript</code> est ignorée pour ce paquet.</p>
</itemd></item>
</itemtable>
<p><em>Séries de tests</em> :</p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>InfoTest</itemt>
<itemd>
<p><em>Introduit dans la version 0.25 de fink.</em> Ce champ englobe les données spécifiques à utiliser pour exécuter les séries de tests. Il contient d'autres champs. Si ce champ est présent, il <em>doit</em> inclure un champ <code>TestScript</code>. Tous les autres champs sont facultatifs. Les champs autorisés à l'intérieur du champ <code>InfoTest</code> sont les suivants :</p>
<ul>
<li><code>TestScript</code> : script d'exécution de la série de tests. Ce script doit retourner un statut de valeur 0 si la série de tests s'est déroulée sans incident, de 1 s'il y a des messages d'attention, et de n'importe quelle autre valeur si les incidents sont suffisamment sévères pour les considérer comme fatals. Du fait de cette logique à trois états, la valeur du statut doit être explicitement indiquée. Par exemple, <code>make check</code> n'est pas conforme à cette logique, puisqu'il retourne un statut de 1 si la cible à vérifier n'existe pas ; par contre, <code>make check || exit 2</code> respecte la logique à trois états.</li>
<li><code>TestConfigureParams</code> : valeur ajoutée au champ <code>ConfigureParams</code>.</li>
<li><code>TestDepends</code> et <code>TestConflicts</code> : liste des paquets à ajouter respectivement aux champs <code>BuildDepends</code> et <code>BuildConflicts</code>.</li>
<li><code>TestSource</code> : sources supplémentaires nécessaires pour exécuter la série de tests. Tous les champs liés à ce champ sont autorisés. On <em>doit</em> donc aussi utiliser le champ <code>TestSource-MD5</code> ou <code>TestSource-Checksum</code>. On peut aussi se servir des champs <code>TestSourceN</code> et <code>TestSourceN-MD5</code>, <code>TestSourceN-Checksum</code>, <code>TestTarFilesRename</code>, etc...</li>
<li><code>TestSuiteSize</code> : donne une idée approximative de la durée d'exécution de la série de tests. Les valeurs permises sont les suivantes : <code>small</code>, <code>medium</code> et <code>large</code>. Ce champ est pour l'instant ignoré.</li>
<li>Tout autre champ standard. Si un champ est indiqué à la fois à l'intérieur et à l'extérieur du bloc <code>InfoTest</code>, c'est sa valeur à l'intérieur du bloc <code>InfoTest</code> qui sera utilisée si la suite de tests est activée.</li>
</ul>
<p>Voici un exemple :</p>
<codeblock>InfoTest: &lt;&lt;
    TestScript: make check || exit 2
    TestConfigureParams: --enable-tests
&lt;&lt;</codeblock>
</itemd></item>
</itemtable>
<p><em>Phase d'installation :</em></p>
<itemtable labeld="Utilisation" labelt="Champ"><item><itemt>UpdatePOD</itemt>
<itemd>
<p><em>Introduit dans la version 0.9.5 de fink.</em> Valeur booléenne réservée aux paquets de module perl. Si sa valeur est true (vraie), du code est ajouté aux scripts install, postrm et postinst, qui gèrent les fichiers .pod fournis par les paquets perl. En particulier, la date .pod est ajoutée et ôtée du fichier central <filename>/opt/sw/lib/perl5/darwin/perllocal.pod</filename>. (Si le type est du style <code>perl $version</code>, où $version est, par exemple, 5.6.0, les scripts sont adaptés pour gérer le fichier central .pod <filename>/opt/sw/lib/perl5/$version/perllocal.pod</filename>).</p>
</itemd></item>
<item><itemt>InstallScript</itemt>
<itemd>
<p>Liste de commandes à exécuter durant la phase d'installation. C'est là où il faut mettre les commandes qui copient tous les fichiers requis dans le répertoire de construction du paquet. Voir plus loin la <xref chapter="reference" section="scripts">note au sujet des scripts</xref>. L'<xref chapter="format" section="percent">interprétation des raccourcis</xref> a lieu avant que les commandes ne soient exécutées. Normalement, on utilise :</p>
<codeblock>make install prefix=%i</codeblock>
<p>Ceci convient pour les paquets utilisant GNU autoconf. Pour ceux de type perl (indiqué via le champ Type) dont la version perl n'est pas indiquée, les commandes par défaut (à partir de la version 0.13.4 de fink) sont les suivantes :</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
 INSTALLARCHLIB=%i/lib/perl5/darwin \
 INSTALLSITELIB=%i/lib/perl5 \
 INSTALLSITEARCH=%i/lib/perl5/darwin \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3 \
 INSTALLSITEMAN1DIR=%i/share/man/man1 \
 INSTALLSITEMAN3DIR=%i/share/man/man3 \
 INSTALLBIN=%i/bin \
 INSTALLSITEBIN=%i/bin \
 INSTALLSCRIPT=%i/bin</codeblock>
<p>Si le type est du style <code>perl $version</code> (où <code>$version</code> est, par exemple, 5.6.0), les commandes par défaut sont les suivantes :</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
 INSTALLARCHLIB=%i/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%i/lib/perl5/$version \
 INSTALLSITEARCH=%i/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3 \
 INSTALLSITEMAN1DIR=%i/share/man/man1 \
 INSTALLSITEMAN3DIR=%i/share/man/man3 \
 INSTALLBIN=%i/bin \
 INSTALLSITEBIN=%i/bin \
 INSTALLSCRIPT=%i/bin</codeblock>
<p>où <code>$perlarchdir</code> est "darwin" pour les versions antérieures ou égales à 5.8.0, et "darwin-thread-multi-2level" pour les versions postérieures ou égales à 5.8.1.</p>
<p>Si le paquet l'admet, il est préférable d'utiliser <code>make install DESTDIR=%d</code>.</p>
</itemd></item>
<item><itemt>AppBundles</itemt>
<itemd>
<p><em>Introduit dans une version postérieure à la version 0.23.1.</em> Ce champ installe le(s) lot(s) dans le répertoire <filename>%p/Applications</filename>. Il crée également un lien symbolique vers le répertoire <filename>/Applications/Fink</filename>. Exemple :</p>
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
</itemd></item>
<item><itemt>JarFiles</itemt>
<itemd>
<p><em>Introduit dans la version 0.10.0 de fink.</em> Champ similaire au champ DocFiles. Il installe les fichiers jar spécifiés dans <filename>%p/share/java/%n</filename>. Exemple :</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
<p>Cette commande installe tous les fichiers jar situés dans le répertoire lib, puis installe le fichier foo.jar sous le nom de fooBar.jar.</p>
<p>Elle garantit aussi que les fichiers jar (en fait, tous les fichiers d'extension .jar situés dans <filename>%p/share/java/%n</filename>) sont ajoutés à la variable d'environnement CLASSPATH. Ceci permet aux outils tels configure ou ant de détecter correctement les fichiers jar installés.</p>
</itemd></item>
<item><itemt>DocFiles</itemt>
<itemd>
<p>Ce champ fournit un moyen simple d'installer les fichiers README et COPYING dans le répertoire doc du paquet, soit <filename>%p/share/doc/%n</filename>. Sa valeur consiste en une liste de fichiers séparés par des espaces. Vous pouvez copier les fichiers à partir de sous-répertoires du répertoire de compilation, ils seront placés dans le répertoire lui-même et non pas dans un sous-répertoire. Les caractères joker reconnus par le shell sont autorisés. On peut aussi renommer des fichiers à la volée en faisant suivre le nom du fichier de deux-points (:), puis du nouveau nom. Exemple :<code>libgimp/COPYING:COPYING.libgimp</code>. Ce champ ajoute les commandes <code>install</code> appropriées au script InstallScript.</p>
</itemd></item>
<item><itemt>Shlibs</itemt>
<itemd>
<p><em>Introduit dans la version 0.11.0 de fink.</em> Ce champ déclare les bibliothèques partagées installées dans le paquet. 
<!-- start translation -->
There is one line for each shared library, which contains the <code>-install_name</code> of the library and information about its binary compatibility. 
Shared libraries that are &quot;public&quot; (i.e., provided for use by other packages) have, separated by whitespace after the filename, the <code>-compatibility_version</code>, versioned package dependency information specifying the Fink package which provides this library at this compatibility version, and the library architecture.
<!-- end translation -->
Cette architecture peut avoir pour valeur "32", "64", "32-64" ou même ne pas exister ; dans ce dernier cas, elle prend la valeur "32" par défaut. Les informations de dépendance doivent être spécifiées sous la forme <code> foo (>= version-revision)</code>, où <code>version-revision</code> représente la <em>première</em> version d'un paquet Fink qui rend disponible cette bibliothèque (avec cette version de compatibilité). La déclaration Shlibs revient à dire que le mainteneur du paquet garantit qu'une bibliothèque portant ce nom et ayant une version de compatibilité au moins égale à <code>-compatibility_version</code> sera présente dans toutes les versions postérieures de ce paquet Fink.
<!-- start translation -->
Shared libraries that are &quot;private&quot; are denoted by an exclamation mark preceeding the filename, and no compatilibity or versioning information is given. See the <xref chapter="policy" section="sharedlibs">Shared Library Policy</xref> for more information.
<!-- end translation -->
</p>
</itemd></item>
<item><itemt>RuntimeVars</itemt>
<itemd>
<p><em>Introduit dans fink 0.10.0.</em> Ce champ fournit un moyen pratique de donner une valeur statique à des variables d'environnement pendant l'exécution (si vous voulez avoir plus de latitude dans ce domaine, voir la <xref section="profile.d">section scripts profile.d</xref>). À partir du moment où le paquet est installé, ces variables sont définies par les scripts <filename>/opt/sw/bin/init.[c]sh</filename>.</p>
<p>La valeur de la variable peut contenir des espaces (seuls les espaces de fin de chaîne sont supprimés) ; l'interprétation des raccourcis a eu lieu sur ce champ. Exemple :</p>
<codeblock>RuntimeVars: &lt;&lt;
 UneVariable: %p/Valeur
 UneAutreVariable: toto tata
&lt;&lt;</codeblock>
<p>définit deux variables d'environnement 'UneVariable' et 'UneAutreVariable' ; leurs valeurs seront respectivement '/opt/sw/Valeur' (si votre préfixe est /opt/sw) et 'toto tata'.</p>
<p>Ce champ ajoute les commandes appropriées au script InstallScript. Ces commandes ajoutent une ligne setenv/export pour chaque variable aux scripts profile.d du paquet ; vous pouvez donc spécifier vos propres commandes, elles ne seront pas remplacées. Les lignes sont ajoutées en début de scripts, vous pouvez donc utiliser ces variables dans vos scripts.</p>
</itemd></item>
<item><itemt>SplitOff</itemt>
<itemd>
<p><em>Introduit dans fink 0.9.9.</em> Génère un second paquet à partir d'une seule exécution du couple compilation/installation. Pour avoir de plus amples informations sur la façon dont ce champ fonctionne, voir la <link url="#splitoffs">section splitoff</link> ci-dessous.</p>
</itemd></item>
<item><itemt>SplitOff<em>N</em></itemt>
<itemd>
<p><em>Introduit dans fink 0.9.9.</em> Similaire au champ <code>SplitOff</code>, utilisé pour générer un N-ième paquet à partir d'une seule exécution du couple compilation/installation. À partir d'une version CVS de fink postérieure à la version 0.19.2, vous pouvez utiliser des valeurs entières (non nécessairement consécutives) de N >= 2. Néanmoins, il ne peut pas y avoir de doublons.</p>
</itemd></item>
<item><itemt>Files</itemt>
<itemd>
<p><em>Introduit dans fink 0.9.9.</em> Utilisé <em>uniquement</em> avec un champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code>, ce champ indique quels fichiers et répertoires doivent être déplacés du répertoire d'installation %I du paquet parent vers le répertoire d'installation en cours %i. Notez que le déplacement a lieu après l'exécution des scripts InstallScript et DocFiles du paquet parent, mais avant l'exécution des mêmes scripts du paquet en cours d'installation.</p>
</itemd></item>
</itemtable>
<p><em>Phase de construction :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
<itemd>
<p>Ces champs correspondent à des scripts shell qui seront appelés lors de l'installation, la mise à jour ou la suppression du paquet. Fink ajoute automatiquement l'en-tête du script shell <code>#!/bin/sh</code> et appelle <code>set -e</code>, de façon à ce que tout échec d'une commande entraîne 'arrêt immédiat du script. Fink ajoute aussi <code>exit 0</code> à la fin du script. Pour signaler une erreur, utilisez exit avec un code non nul. Le premier paramètre (<code>$1</code>) contient une valeur indiquant l'action à faire. Exemples de valeurs possibles : <code>install</code>, <code>upgrade</code>, <code>remove</code> et <code>purge</code>. Notez qu'il existe d'autres valeurs, utilisées lors des reprises sur erreur et du remplacement d'un paquet par un autre.</p>
<p>Ces différents scripts sont appelés lors des évènements suivants :</p>
<ul>
<li>PreInstScript : lors de la première installation d'un paquet et avant la mise à jour d'un paquet à la même version.</li>
<li>PostInstScript : après le dépaquetage et la définition des variables spécifiques au paquet.</li>
<li>PreRmScript : avant la suppression et la mise à jour d'un paquet à une version ultérieure.</li>
<li>PostRmScript : après la suppression et la mise à jour du paquet à une version ultérieure.</li>
</ul>
<p>Soyons plus clair. Une mise à jour invoque à la fois les scripts ...Inst de la nouvelle version et les scripts ...Rm de l'ancienne version. Vous trouverez de plus amples informations à ce sujet dans le <link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">Chapitre 6</link> du Manuel des normes Debian.</p>
<p>L'interprétation des raccourcis a lieu dans ces scripts. Les commandes peuvent, en général, être lancées sans donner leur chemin complet.</p>
</itemd></item>
<item><itemt>ConfFiles</itemt>
<itemd>
<p>Liste de fichiers séparés par des espaces. Ces fichiers sont des fichiers de configuration modifiables par l'utilisateur. L'interprétation des raccourcis a lieu sur ce champ. Le chemin complet des fichiers doit être indiqué, comme dans <filename>%p/etc/%n.conf</filename>. Ces fichiers sont traités de façon spéciale par dpkg. Quand un paquet est mis à jour et que le fichier de configuration a changé à la fois sur le disque et dans le paquet, dpkg demande à l'utilisateur quelle version il veut utiliser et sauvegarde l'ancien fichier. Quand un paquet est supprimé avec "remove", les fichiers de configuration ne sont pas supprimés. Pour les supprimer, il faut utiliser "purge".</p>
</itemd></item>
<item><itemt>InfoDocs</itemt>
<itemd>
<p>Liste des documents Info que le paquet installe dans %p/share/info. 
Des commandes appropriées sont ajoutées aux scripts postinst et prerm pour mettre à jour le fichier de la hiérarchie Info <code>dir</code>. 
</p>

<!-- start translation -->
<p><em>Note:</em>  Only use the un-numbered file in the case of split Info
documents. E.g. if a package has:</p>
<codeblock>
foo.info
foo.info-1
foo.info-2
</codeblock>
<p>you should only use:</p>
<codeblock>
InfoDocs:  foo.info
</codeblock>
<!-- end translation -->

<p>
Cette fonctionnalité est en cours de développement, d'autres champs pourront être ajoutés à l'avenir pour une gestion plus précise.</p>
</itemd></item>
<item><itemt>DaemonicFile</itemt>
<itemd>
<p>Décrit un service pour <code>daemonic</code>. <code>daemonic</code> est utilisé par Fink pour créer et supprimer des éléments à lancer au démarrage pour les processus démon (par exemple les serveurs web). La description est ajoutée au paquet sous la forme d'un fichier nommé <code>%p/etc/daemons/<em>nom</em>.xml</code>, où <em>nom</em> est indiqué par le champ DaemonicName et est réduit, par défaut, au nom du paquet. L'interprétation des raccourcis a lieu sur le contenu de ce champ. Notez que vous devez ajouter <code>daemonic</code> à la liste des dépendances, si votre paquet utilise ce champ.</p>
</itemd></item>
<item><itemt>DaemonicName</itemt>
<itemd>
<p>Nom du fichier de description d'un service <code>daemonic</code>. Voir la description de DaemonicFile pour de plus amples informations.</p>
</itemd></item>
</itemtable>
<p><em>Autres informations :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>Homepage</itemt>
<itemd>
<p>URL de la page d'accueil du paquet en amont.</p>
</itemd></item>
<item><itemt>DescDetail</itemt>
<itemd>
<p>Description plus détaillée que celle figurant dans le champ <code>Description</code> (répond aux questions : qu'est-ce que c'est ?, comment l'utiliser?). Les lignes multiples sont autorisées. Comme ce champ sera affiché sans que la longueur des lignes soit adaptée à la largeur de la fenêtre d'affichage, vous devez insérer des sauts de ligne, de façon à ce que les lignes ne dépassent pas 78 caractères (si possible).</p>
</itemd></item>
<item><itemt>DescUsage</itemt>
<itemd>
<p>Information nécessaire à l'utilisation du paquet (répond à la question : comment l'utiliser ?). Exemple : "exécute wmaker.inst avant d'utiliser WindowMaker". Lignes multiples autorisées. Comme ce champ sera affiché sans que la longueur des lignes soit adaptée à la largeur de la fenêtre d'affichage, vous devez insérer des sauts de ligne, de façon à ce que les lignes ne dépassent pas 78 caractères (si possible).</p>
</itemd></item>
<item><itemt>DescPackaging</itemt>
<itemd>
<p>Notes sur la construction du paquet. Les éléments du type : "rustine pour le Makefile de sorte que tout aille au bon endroit" sont placés dans ce champ. Lignes multiples autorisées.</p>
</itemd></item>
<item><itemt>DescPort</itemt>
<itemd>
<p>Notes spécifiques au portage du paquet sur Darwin. Les éléments du type : "scripts config.guess et libtool scripts mis à jour, -no-cpp-precomp nécessaire" sont placés dans ce champ. Lignes multiples autorisées.</p>
</itemd></item>
</itemtable>
</section><section name="splitoffs"><title>Paquets multiples</title>
<p>À partir de la version 0.9.9 de fink, on peut utiliser un seul fichier .info pour construire plusieurs paquets. La phase d'installation commence, comme pour tout autre type de paquet, par l'exécution des scripts <code>InstallScript</code> et <code>DocFiles</code>. Si un champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code> est présent, il y a création d'un répertoire d'installation supplémentaire. À l'intérieur des champs <code>SplitOff</code> et <code>SplitOff<em>N</em></code>, le nouveau répertoire d'installation est désigné par %i, tandis que le répertoire d'installation du paquet parent est désigné par %I.</p>
<p>Chaque champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code> doit contenir un certain nombre de champs qui lui sont propres. En fait, cela ressemble à une description de paquet ordinaire, mais certains champs sont omis. Voici les champs qui peuvent y figurer (classés par catégorie) :</p>
<ul>
<li>Données initiales : seul le champ <code>Package</code> doit être spécifié, tout le reste est hérité du paquet parent. Vous pouvez modifier les champs <code>Type</code> et <code>License</code> en déclarant ces champs dans les champs <code>SplitOff</code> et <code>SplitOff<em>N</em></code>. On peut utiliser les raccourcis ; il est préférable de mentionner le nom du paquet parent sous la forme %N.</li>
<li>Dépendances : tous les champs sont autorisés.</li>
<li>Phases de décompression, d'application des rustines, de compilation : ces champs n'ont pas de signification dans ce contexte et seront ignorés s'ils sont présents.</li>
<li>Phases d'installation et de construction : tous les champs sont autorisés à l'exception des champs SplitOff (un champ SplitOff ne peut contenir lui-même un autre champ SplitOff).</li>
<li>Données supplémentaires : elles sont héritées du paquet parent, mais peuvent être modifiées en déclarant le champ dans les champs <code>SplitOff</code> ou <code>SplitOff<em>N</em></code>.</li>
</ul>
<p>Comme %n-%v-%r représente l'identifiant unique d'un paquet, on ne peut avoir le même champ <code>Package</code> (avec les mêmes champs <code>Version</code> et <code>Revision</code>) dans un <code>SplitOff</code> (ou dans un <code>SplitOff<em>N</em></code>) d'un paquet multiple. Si l'on utilise des variantes, il faut se rappeler que chaque variante est considérée comme un paquet indépendant des autres. Il s'ensuit que la disposition suivante est interdite :</p>
<codeblock>
Package: mime-base64-pm%type_pkg[perl]
Type: perl (5.8.1 5.8.6)
SplitOff: &lt;&lt;
  Package: mime-base64-pm-bin
&lt;&lt;
</codeblock>
<p>Lors de la phase d'installation, les champs <code>InstallScript</code> et <code>DocFiles</code> du paquet parent sont exécutés en premier. Puis vient l'exécution des champs <code>SplitOff</code> et <code>SplitOff<em>N</em></code>. Pour chacun de ces champs à tour de rôle, la commande <code>Files</code> déplace les fichiers et répertoires spécifiés, du répertoire d'installation %I du paquet parent dans le répertoire de l'installation en cours %i. Puis les scripts <code>InstallScript</code> et <code>DocFiles</code> des paquets <code>SplitOff</code> et <code>SplitOff<em>N</em></code> sont exécutés.</p>
<p>À l'heure actuelle, le champ <code>SplitOff</code>, s'il existe, est exécuté en premier, suivi des champs <code>SplitOff<em>N</em></code> par ordre numérique. Néanmoins, cela pourrait changer dans le futur. Il est donc conseillé de ne pas utiliser :</p>
<codeblock>
SplitOff: &lt;&lt;
  Description: certains headers
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: tous les autres headers
  Files: include/*
&lt;&lt;
</codeblock>
<p>qui ne fonctionne correctement que si <code>SplitOff</code> est exécuté avant <code>SplitOff2</code>. Il vaut mieux donner la liste explicite des fichiers pour chaque champ (ou utiliser des noms de fichier plus explicites).</p>
<p>Lors de la phase de construction du paquet, les scripts pre/post install/remove de chacun des paquets sont construits à partir des commandes spécifiques de la phase de construction desdits paquets.</p>
<p>Chaque paquet à construire doit placer les fichiers de licence dans %i/share/doc/%n (avec %n ayant une valeur différente pour chaque paquet). Notez que <code>DocFiles</code> copie les fichiers au lieu de les déplacer ; il est donc possible d'installer une même copie de la documentation dans chacun des paquets en utilisant <code>DocFiles</code> plusieurs fois.</p>
</section>
<section name="scripts"><title>Scripts</title>
<p>Les champs PatchScript, CompileScript et InstallScript vous permettent d'indiquer des commandes shell à exécuter. Le répertoire de construction (<filename>%b</filename>) est le répertoire en cours lors de l'exécution des scripts. Vous devez toujours utiliser des chemins relatifs ou des raccourcis pour les fichiers et répertoires de l'arborescence fink, et jamais des chemins absolus. Deux formats différents sont possibles pour ces champs.</p>
<p>Le champ peut être constitué d'une simple liste de commandes, un peu comme un script shell. Néanmoins, les commandes sont exécutées ligne après ligne via system(). Il en résulte que l'assignation de variables ou les changements de répertoire n'ont d'effet que pour les commandes résidant sur une même ligne. À partir d'une version CVS de fink postérieure à 0.18.2, vous pouvez ajuster la longueur des lignes de la même manière que dans les scripts shell : une barre oblique inversée (<code>\</code>) à la fin de la ligne indique que la ligne suivante est la suite de la ligne précédente.</p>
<p>Vous pouvez aussi insérer un script complet, en utilisant l'interpréteur que vous voulez. Comme avec tout autre script Unix, la première ligne doit commencer par <code>#!</code> suivi du chemin complet de l'interpréteur et des options désirées (exemple : <code>#!/bin/csh</code>, <code>#!/bin/bash -ev</code>, etc...). Dans ce cas, la totalité du champ *Script est déversée dans un fichier temporaire, qui est alors exécuté.</p>
</section>
<section name="patches"><title>Rustines</title>
<p>Si votre paquet nécessite une rustine pour compiler sous Darwin (ou pour fonctionner avec fink), donnez à la rustine le même nom que celui indiqué dans la description du paquet, en utilisant l'extension ".patch" au lieu de ".info", et placez-la dans le même répertoire que le fichier .info. Si vous utilisez le nom complet du paquet dans le nom du fichier, indiquez-le dans le champ d'une des façons suivantes (elles sont équivalentes) :</p>
<codeblock>Patch: %f.patch</codeblock>
<codeblock>PatchScript: patch -p1 &lt;%a/%f.patch</codeblock>
<p>Si vous utilisez les nouvelles conventions de nommage d'un paquet unique, utilisez %n au lieu de %f. Ces deux champs ne sont pas exclusifs l'un de l'autre ; vous pouvez utiliser les deux et ils seront tous deux exécutés. Dans ce cas, le script PatchScript sera exécuté en dernier.</p>
<p>Comme il se peut que vous ayez besoin du préfixe choisi par l'utilisateur dans le fichier rustine, il est conseillé d'utiliser une variable telle <code>@PREFIX@</code> au lieu de <code>/opt/sw</code> dans la rustine et d'utiliser ensuite :</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt;%a/%f.patch | patch -p1</codeblock>
<p>Les rustines doivent être en format unidiff et sont, en général, créées en utilisant :</p>
<codeblock>diff -urN &lt;répertoiredusourceoriginel&gt; &lt;répertoiredusourcemodifié&gt;</codeblock>
<p>Si vous utilisez emacs pour modifier les fichiers, vous devez ajouter <code>-x'*~'</code> à la commande diff ci-dessus, pour exclure les fichiers de sauvegarde générés automatiquement.</p>
<p>Il faut aussi noter que les très grosses rustines ne doivent pas être mises dans cvs. Elles doivent être placées sur un serveur web/ftp et référencées en utilisant le champ <code>SourceN:</code>. Si vous n'avez pas de site web, les administrateurs du projet fink peuvent mettre le fichier à disposition à partir du site web de fink. Si votre rustine fait plus de 30Kb, vous devez la traiter comme un téléchargement distinct.</p>
</section>
<section name="profile.d"><title>Scripts profile.d</title>
<p>Si votre paquet nécessite une initialisation à l'exécution (par exemple, pour définir des variables d'environnement), vous pouvez utiliser des scripts profile.d. Ces scripts sont sourcés par les scripts <filename>/opt/sw/bin/init.[c]sh</filename>. Normalement, tout utilisateur de fink charge ces scripts dans ses fichiers de démarrage de shell (<filename>.cshrc</filename> et équivalents). Votre paquet doit fournir deux variantes de scripts : l'une pour les shells compatibles avec sh (sh, zsh, bash, ksh, ...), l'autre pour les shells compatibles avec csh (csh, tcsh). Elles doivent être installées sous la forme <filename>/opt/sw/etc/profile.d/%n.[c]sh</filename> (où %n représente le nom du paquet). Il faut aussi positionner leurs bits de lecture et d'exécution (c'est-à-dire les installer avec -m 755), autrement elles ne seront pas chargées correctement.</p>
<p>Si vous n'avez besoin que d'initialiser certaines variables d'environnement (par exemple, définir QTDIR comme '/opt/sw'), vous pouvez utiliser le champ RuntimeVars, qui a été conçu exactement pour ce faire.</p>
</section>
</chapter>
</document>
