<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">

<document filename="index" lang="zh" >
<title>创建 Fink 软件包</title>
<shorttitle>打包</shorttitle>
<cvsid>$Id: packaging.zh.xml,v 1.29 2007/01/18 02:16:52 babayoshihiko Exp $</cvsid>

<preface>
<p>
本手册记录如何创建 Fink 软件包管理的软件包描述文件。
它还提供关于 Fink 发布的一些规则和指引。
描述文件格式和发布规则都在不断完善中，所以请查看&quot;最后修改&quot;信息和 CVS 标记来检查是否更新。
你现在阅读的是用于 <tt>fink</tt> 0.9.0 开发版软件包管理器之后的描述文件和规则。
</p>
<p>
如果你打算为 Fink 创建软件包，你可以订阅
<link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link>
邮件列表。
如果你希望帮助 Fink 项目，而你在这方面又有专长，你可以考虑选择接受一个
<link url="http://fink.sourceforge.net/pdb/nomaintainer.php">尚未有维护人员的软件包。</link>
</p>
</preface>


<chapter filename="intro">
<title>介绍</title>
<shorttitle>介绍</shorttitle>


<section name="def1"><title>什么是软件包？</title>
<p>
软件包是一个以原子状态（也就是说，它不可以被分割成更细小的可独立存在软件）存在的一个软件。
典型的软件包包括一个可执行的程序，必须的数据文件，供国际化和文档使用的消息目录。
在 Fink 中，软件包有两种形式：软件包描述文件和可安装二进制软件包文件。
</p>
<p>
软件包描述文件是一个可阅读的纯文本文件，它包括了构建一个软件包（即，创建二进制软件包文件）所需要的全部信息。
信息包括：元数据（比如软件包的名字，它的作用等），源代码的下载网址和应该如果配置，编译，封装软件包的指引。
描述文件可以还会附有一个补丁文件。
</p>
<p>
二进制软件包文件是一个构成软件包的实际文件的压缩档。这些实际文件包括可执行程序，数据文件，信息目录，函数库，头文件等等。
这种软件包问题还会包括软件包的一些元数据。
安装一个二进制软件包的过程主要就是解压缩而已，因为它实际上已经出于立刻可以使用的状态了。
由于 Fink 构建在 dpkg 软件包管理器上，二进制软件包文件采用 dpkg 的文件格式并具有 .deb 的扩展名。
</p>
</section>


<section name="ident"><title>识别一个软件包</title>
<p>
一个软件包由三个字串来标识：软件包名，版本号和修订版号。
他们均由小写字母（a-z），数字（0-9），减号（-; note: not allowed in the revision），加号（+）以及句点（.）组成。不允许使用其它的字符。
特别地，不能使用大写字母和下划线。
</p>
<p>
软件包名就是软件的名称，例如：openssh。
版本号，也称为上游版本号，是原始软件包的版本标识号。
在版本号中可以使用字母，例如：2.9p1。
fink 和 dpkg 都知道如何正确地给它们排序。
修订版号是一个递增的反映软件包描述被修改的计数。
它从 1 开始递增，让上游版本号发生改变以后，又回到 1 重新开始。
修订版号不可以包括减号。
完整的软件包名称是它们三项的连接，中间用减号分隔，例如：openssh-2.9p1-2。
</p>
</section>

</chapter>


<chapter filename="format">
<title>软件包描述文件</title>
<shorttitle>软件包描述文件</shorttitle>

<section name="trees"><title>文件树结构</title>
<p>
软件包描述文件保存在 <filename>/sw/fink/dists</filename> 目录树内的 <code>finkinfo</code> 目录中。
<filename>/sw/etc/fink.conf</filename> 中的 &quot;Trees&quot; 设置控制会控制应该读取那个目录。
软件包描述文件的名字必须要软件包全名加上 &quot;.info&quot; 扩展名组成。
从 fink 0.13.0 开始，为了简化软件包的升级，也可以允许简单地使用软件包加 &quot;.info&quot; 来组成。
<!-- start translation -->
As of fink 0.26.0, there are several different ways to specify the
filename: it is recommended to use the shortest version which is
consistent with other needed package files.  The filename takes
the form: the invariant packagename, optionally 
followed by the architecture, optionally followed by the
distribution, 
optionally followed by either version or version-revision, each delimited by 
hyphens, concluding with ".info".  
The "architecture" and "distribution" components are only allowed
if the corresponding field is present in the package, and if it specifies
exactly one value.
<!-- end translation -->
</p>
<p>
到软件包描述文件的目录树由几层目录组成。
自上而下顺序为：
</p>
<ul>
<li><code>dists</code> 是目录的起点。<code>dists</code>
对 Debian 工具来说是必须的。</li>
<li>发布类型。可以是 <code>stable</code>，
<code>unstable</code> 和 <code>local</code>。<code>local</code>
目录由本机的管理员／用户控制。<code>stable</code> 和 <code>unstable</code> 目录则是 Fink 的一部分。</li>
<li>目录树。<code>main</code> 目录树包含软件包的实际部分。加密功能的软件被放到一个称为 <code>crypto</code> 的单独的目录树中，使得需要删除的时候会容易一些。</li>
<li><code>finkinfo</code>
及 <code>binary-darwin-powerpc</code>。<code>finkinfo</code> 目录中包含了  Fink 软件包描述文件和补丁，而
<code>binary-darwin-powerpc</code> 则包含了 <code>.deb</code>
二进制软件包。</li>
<li>分组。<code>main</code>目录树按类别被分成几组以方便管理。<code>crypto</code> 目录树目前没有被分组。</li>
</ul>
</section>

<section name="format"><title>文件格式</title>
<p>
描述文件只是键－值对的简单列表，一个键－值对有时也称为一个“字段”。
每一行由一个以冒号（:）为结束的键开始，然后跟着是相对应的值，就象这样：
</p>
<codeblock>Key: Value</codeblock>
<p>
当你需要把一个分成几行书写的时候，可以有两种标记办法。
</p><p>
推荐的方式是通常用于在 shell 脚本 here-document 语法。这种方法第一行是键，然后跟着以 <code>&lt;&lt;</code> 为它的取值。
在这之后，在下一个 <code>&lt;&lt;</code> 之前的所有行会被视作实际的取值。
下面是一个例子：
</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
<p>
在这种格式下，缩进是可选的，但它可以改进可阅读性。
</p><p>
这种 here-document 语法格式可以嵌套使用。这通常使用于 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 字段。
这些字段包含其它字段（多行），因此通过这种语法可以使得子字段也可以具有多行。在子的 here-document 块中同样使用的 <code>&lt;&lt;</code> 作为终结符。
下面是一个例子：
</p>
<codeblock>
SplitOff: &lt;&lt;
  Package: %N-shlibs
  InstallScript: &lt;&lt;
    ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
  &lt;&lt;
&lt;&lt;
</codeblock>
<p>
另外一种旧的，已经过时的标记方法是参照 RFC 822 数据包头的分行方式。
以空白字符开始的行会被当作上一行的继续。
例子：
</p>
<codeblock>InstallScript: mkdir -p %i/share/man
 make install prefix=%i mandir=%i/share/man
 mkdir -p %i/share/doc/%n
 install -m 644 COPYING %i/share/doc/%n</codeblock>
<p>
注意上面续行中强制要求的缩进格式。
</p><p>
在两种格式中，空行或以井号（#）打头的行都会被忽略。
键（字段名）在 Fink 中是区分大小写的，你可以随便使用
<code>InstallScript</code>，<code>installscript</code> 或
<code>INSTALLSCRIPT</code>。
不过，建议使用首字母大写的方式以方便阅读。
对于那些使用布尔值的字段－&quot;true&quot;，&quot;yes&quot;，&quot;on&quot;，&quot;1&quot;（不区分大小写），都会被认为是真值，而其它的值则会被认为是假值。
</p>
</section>

<section name="percent"><title>百分号展开</title>
<p>
为了简化一些书写，Fink 在一些字段中支持一套展开（替换）规则。
为了避免含混，你可以使用大括号来指明确切是那些字母需要作为百分号展开。
例如，<code>%{n}</code> 与 <code>%n</code> 的含义是一样的。
目前支持的展开包括：
</p>
<itemtable labeld="" labelt="">
<item><itemt>%n</itemt>
<itemd>
<p>
当前软件包的名字（<em>n</em>ame）
</p>
</itemd></item>

<item><itemt>%N</itemt>
<itemd>
<p>
父软件包的名字（<em>N</em>ame），除非在 <code>SplitOff</code> 中，否则应该和 %n 相同
</p>
<p>
注意：如果父 <code>Package</code> 字段包含 %type_*[]，那些百分号扩展的值<em>将</em>被包括在 <code>SplitOff</code> 块的 %N 中(因为它们被包括在父字段的 %n 中)。
</p>
</itemd></item>

<item><itemt>%e</itemt>
<itemd>
<p>
软件包的额外版本标识（<em>e</em>poch）。它主要用于强行替代版本号的顺序，比方说你现在已经有一个 2.0Beta1 版，然后现在 2.0 版出来了，显然 2.0 版应该是一个更新的版本。但是 字符串比较的结果却是 2.0Beta1 &lt; 2.0。所以，要么你只能把 2.0 命名为 2.0Final，要么你使用 epoch 来强行制定版本的先后顺序。比方说：epcho 1, version 1.0 是一个比 epcho 0, version 2.0 更新的版本。
</p>
</itemd></item>

<item><itemt>%v</itemt>
<itemd>
<p>
软件包的版本号（<em>v</em>ersion）
</p>
</itemd></item>

<item><itemt>%r</itemt>
<itemd>
<p>
软件包的修订版号（<em>r</em>evision）
</p>
</itemd></item>

<item><itemt>%f</itemt>
<itemd>
<p>
完整的（<em>f</em>ull）软件包名，即 %n-%v-%r.
<!-- start translation -->
Note that the Epoch is not part of <code>%f</code>.
<!-- end translation -->
</p>
</itemd></item>

<item><itemt>%p, %P</itemt>
<itemd>
<!-- start translation -->
<p>
the <em>p</em>refix where Fink is installed, e.g. <filename>/sw</filename>. You must not assume all users have Fink installed in <filename>/sw</filename>; use <code>%p</code> to ge the correct path.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>%d</itemt>
<itemd>
<p>
要打包的全套文件将被构建于的目标（<em>d</em>estination）目录，例如：
<filename>/sw/src/fink.build/root-gimp-1.2.1-1</filename>。
这个临时目录在编译过程的安装阶段将作为根目录位置。
你不应该假设 <filename>root-%f</filename> 会在 <filename>%p/src</filename> 中，因为用户可以通过 <filename>/sw/etc/fink.conf</filename> 文件中的 <code>Buildpath</code> 字段来改变它的位置。
</p>
</itemd></item>

<item><itemt>%D</itemt>
<itemd>
<p>
父文件包的目标（<em>D</em>estination）目录（除非是在 <code>SplitOff</code> 中，否则和 %d 相同）
</p>
</itemd></item>

<item><itemt>%i</itemt>
<itemd>
<p>
安装态（<em>i</em>nstall-phase）的完整路径前缀，等于 %d%p。安装态是指从源代码编译安装到临时位置后的状态，然后我们需要把它封装成 .deb 包。
</p>
</itemd></item>

<item><itemt>%I</itemt>
<itemd>
<p>
父软件包的安装（<em>I</em>nstall）态路径前缀，等于 %D%P（除非是 <code>SplitOff</code> 中，否则应该和 %i 相等）
</p>
</itemd></item>

<item><itemt>%a</itemt>
<itemd>
<p>
补丁（p<em>a</em>tches）程序所在的路径
</p>
</itemd></item>

<item><itemt>%b</itemt>
<itemd>
<p>
构建（<em>b</em>uild）过程所在的目录，例如：<filename>/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>。
你不应该假设 <filename>%f</filename> 一定在 <filename>%p/src</filename> 中，因为用户可以通过 <filename>/sw/etc/fink.conf</filename> 文件中的 <code>Buildpath</code> 字段来改变它。
最内部的目录根据 <code>Source</code> 文件名来命名，或是 <code>SourceDirectory</code> 字段(如果存在的话)的值，或在 <code>NoSourceDirectory</code> 为 <code>true</code> 的时候不使用它。
</p>
<p>
注意：仅在没有其它选择的情况下才使用它。构建目录是脚本运行的当前目录；在命令中你应该使用相对路径。
</p>
</itemd></item>

<item><itemt>%c</itemt>
<itemd>
<p>
<em>c</em>onfigure 命令将使用的参数：<code>--prefix=%p</code> 加上 ConfigureParams 指定的其它参数。
<!-- start translation -->
(The behavior is different when the package
has <code>Type: perl</code>; in that case, the default flags for
building a perl package are used instead of <code>--prefix=%p</code>
in the definition of <code>%c</code>.)
<!-- end translation -->
</p>
</itemd></item>

<item><itemt>%m</itemt>
<itemd>
<p>
机器（<em>m</em>achine）体系架构类型字符串，这和
<code>uname -p</code> 的输出一致。目前 'powerpc' 代表 ppc 类的计算机，'i386' 代表 x86 类（在 0.12.1 之后的一个 CVS 版本开始引入）
</p>
</itemd></item>

<item><itemt>%%</itemt>
<itemd>
<p>
百分号字符（它部分展开后面跟着它的东西）。展开严格按照从左到右的顺序进行，所以 %%n 和软件包名没有关系，而只是字符串 %n。（从 fink-0.18.0 开始引入）
</p>
</itemd></item>

<item><itemt>%type_raw[<em>类型</em>], %type_pkg[<em>类型</em>],
%type_num[<em>类型</em>]</itemt>
<itemd>
<p>
对给定<em>类型</em>返回的代表子类型的伪哈希值。
查阅本文档后面关于 <code>Type</code> 字段的内容。
_raw 形式表明使用子类型字符串的精确形式，
_pkg 形式表明使用去除句点之后的形式(就好象 Fink 的语言版本软件包的命名约定一样)。(在 fink 的 CVS 0.19.2 后版本中引入)。
<!-- start translation -->
The _num form was introduced in fink-0.26.0
and removes all non-digits from the <code>Type</code> field.
<!-- end translation -->
</p>
</itemd></item>

<item><itemt>%{ni}, %{Ni}</itemt>
<itemd>
<p>
软件包的固定名称(<em>n</em>ame <em>i</em>nvariant)部分。
它们和 %n 和 %N 类似，除了所有 %type_pkg[] 和 %type_raw[] 被去掉。
(在 fink 的 CVS 0.19.2 后版本中引入)。
你应该使用 %{ni} 和 %{Ni} 以避免与 %n 和 %N 扩展相混淆。
</p>
</itemd></item>
<!-- start translation -->
<item><itemt>%{default_script}</itemt>
<itemd>
<p>
Valid only in <code>PatchScript</code>, <code>CompileScript</code>, and <code>InstallScript</code> fields, the default contents of
that type of field. The value is often dependent on
the <code>Type</code> field, and is always defined (though it may be
blank). When used in the <code>InstallScript</code> of a <code>SplitOff</code> (or <code>SplitOff<em>N</em></code>), this
expansion will yield the <em>parent's</em> default, even though the
default for <code>InstallScript</code> in a <code>SplitOff</code>
package is blank. (Introduced in fink-0.20.6)
</p>
</itemd></item>

<item><itemt>%{PatchFile}</itemt>
<itemd>
<p>
The full path to the file given in the <code>PatchFile</code> field.
(Introduced in fink-0.24.12)
</p>
</itemd></item>
<item><itemt>%lib</itemt>
<itemd>
<p>
If <code>Type: -64bit</code> is defined to be <code>-64bit</code>,
this expands to <em>lib/ppc64</em> on powerpc machines, and to
<em>lib/x86_64</em> on intel machines (the proper storage locations
for 64-bit libraries); otherwise, this expands to <em>lib</em>.
(Introduced in fink-0.26.0)
</p>
</itemd></item>
<!-- end translation -->
</itemtable>

</section>

</chapter>


<chapter filename="policy">
<title>打包相关规则</title>
<shorttitle>规则</shorttitle>

<section name="licenses"><title>软件包授权协议</title>
<p>
Fink 中包括的软件包包括很广范围的授权协议种类。
多数都对重新发布全部源代码有限制，尤其对发布二进制版本有限制。
有些软件包因为这些授权协议而不能提供二进制发行版。因此，很重要的一点是软件包的维护者需要仔细地检查他们维护的软件包的授权协议限制。
</p>
<p>
每个以二进制包形式发布的软件都必须包含一些授权协议。
它必须被安装在 doc 目录，
也就是说：<filename>%p/share/doc/%n</filename>。
（当然，在 InstallScript 中，应该用 %i 代替 %p。DocFiles 字段会自动处理这些细节。）
如果在原始的程序中没有明确的授权协议声明，那个包含一小段文字来说明这个软件包的状态。
多数的授权协议要求在发布版中包括一份授权协议。
Fink 的规则要求总是这么做，即使软件本身没有明确要求。
</p>
<p>
为了使得二进制发行版的维护可以自动化，所有准备发布的软件包都必须有一个 <code>License</code> 字段。
这个字段表明授权协议的性质，并被用于决定是否为它制作二进制发行版。
按照前面解释的原因，只有在实际的授权协议条文被放进二进制包中，这个字段才会起作用。</p>
<p>
要使得 <code>License</code> 字段有用，必须使用下面之一的预定义值。
如果你在打包的程序并不适合下面中的一种，请在开发者邮件列表中要求帮助。
</p>
<ul>

<li><code>GPL</code>－GNU 通用公开授权协议。这个协议要求与二进制包一起提供源代码。</li>
<li><code>LGPL</code>－GNU 较宽松通用公开授权协议。
这个协议要求与二进制包一起提供源代码。</li>
<li><code>GPL/LGPL</code>－这是一种混合使用 GPL 和 LGPL 的特殊情况，比如说可执行程序部分使用 GPL，而库部分则使用 LGPL。</li>

<li><code>BSD</code>－BSD 风格授权协议。
这包括：称为&quot;原始的&quot; BSD 授权协议，&quot;修改的&quot;" BSD
授权协议和 MIT 授权协议。Apache 授权协议也被认为是 BSD 的一种。这些协议下发布源代码是可选的。</li>

<li><code>Artistic</code>－对于 Artistic 授权协议及其派生授权协议。</li>

<li><code>Artistic/GPL</code>－在 Artistic 和 GPL 下的双重授权协议。</li> 

<li><code>GNU Free Documentation License</code> 和 <code>Linux
Documentation Project</code>－如果文档中的其中一个软件包明显地被指出是这两种授权协议之一。那么应该在原来的协议后面加上 <code>/GFDL</code> 或 <code>/LDP</code>，这应该是下面的组合之一：&quot;GFDL&quot;，&quot;GPL/GFDL&quot;，&quot;LGPL/GFDL&quot;，&quot;GPL/LGPL/GFDL&quot;，&quot;LDP&quot;，或&quot;GPL/LGPL/LDP&quot;。
</li>

<!-- start translation -->
<li><code>DFSG-Approved</code> - for software that meets the guidelines
of the <link url="http://www.debian.org/social_contract">Debian Social Contract</link>.
</li>
<!-- end translation -->

<li><code>OSI-Approved</code>－那些由<link url="http://www.opensource.org/">开放源码组织</link>所批准的开放源码授权协议。OSI 的要求之一是二进制文件和源代码的自由发放。这个值也用于对双重协议的软件包的遮蔽。</li>

<li><code>Restrictive</code>－限制性授权协议。
用于那些作者允许免费使用源代码，但不允许自由地重新发布的软件包。</li>

<li><code>Restrictive/Distributable</code>－针对那些允许发布源和二进制包的限制性授权协议。这应用那些提供源程序，允许对源程序和二进制包进行再发布，但是却有些限制性的条款使得它称为非开源协议的软件包。</li>

<li><code>Commercial</code>－对于限制性，商业授权协议。
应用商业软件包（比如：免费软件，共享软件），它们不允许对源程序或二进制程序进行自由的重发布。</li>

<li><code>Public Domain</code>－对于那些在公开域的软件包，即那些作者放弃对代码的版权的软件。这些软件包没有授权协议，任何人都可以随意使用它。</li>

</ul>

</section>

<!-- start translation -->
<section name="openssl"><title>The GPL and OpenSSL</title>
<p>
(Policy change effective April, 2005.)
</p>
<p>
Due to the apparent incompatibilty of the OpenSSL license with the GPL and 
LGPL licenses, fink packages which link to openssl but are licensed under 
the GPL or LGPL are marked as "Restrictive."  As a consequence, the Fink 
project will not distribute binaries of such packages, although users are 
free to compile them from source at their discretion.
</p>
<p>
Package maintainers are encouraged to record the original package license in 
the <code>DescPackaging</code> field.
</p>

</section>
<!-- end translation -->

<section name="prefix"><title>避免干扰基本系统</title>
<p>
Fink 是一个安装在基本系统之外的独立目录里面的外加的软件系统。
保证不要把文件安装到 Fink 的目录之外对一个软件包来说是非常重要的。
</p>
<p>
唯一的例外是没有其它的选择的情况下，比如：XFree86。
这种情况下，软件包必须在安装前检查现有的文件，如果发现可能要覆盖现有的文件，它应该拒绝安装。
软件包必须要保证它安装在 Fink 目录之外的文件要能够在删除软件包的时候同时被删除。或者留在那里保证不会造成危害（就是说，他们需要在调用它之前检查它是否在那里）。
</p>
</section>

<section name="sharedlibs"><title>共享函数库</title>
<p>
Fink 对于共享库有了新的规则，它从 2002 年 2 月开始生效。
本段内容讨论的是规则的第四版，它是与 Fink's 0.5.0 一同发布的
(<!-- start translation -->as well as some updates from December, 2006 to handle 64bit libraries<!-- end translation -->)。
我们首先以一个简要的概括开始，然后讨论更多的细节问题。
</p><p>
任何会产生共享库的软件包，无论它是⑴被放在稳定树中，或是⑵一个新的软件包，都应该使得他们的库满足 Fink 的规则。即：</p>
<ul>
<li>   使用 <code>otool -L</code> (或<!-- start translation --> otool64 -L for 64bit libraries<!-- end translation -->) 验证每个库的安装名（install_name），兼容性和当前版本号是正确的。</li>
<li>   把共享库放到一个单独的软件包（除了从 libfoo.dylib 连接 install_name 的以外），并在软件包中包括 <code>Shlibs</code> 字段</li>
<li>   把头文件以最终从 libfoo.dylib 的连接放到一个软件包中，并分类为： <code>BuildDependsOnly: True</code>，应该不会有其他软件包会依赖它。</li>
</ul>
<p>
  如果某个维护者因为某个原因而不能遵循这个规则，没有分离软件包的话，应该在 DescPackaging 字段中说明原因。
</p><p>
对于一些软件，可以通过一个主软件包和一个 -shlibs 软件包来组成；另外的一些情况下，你还需要第三个软件包。新的
<code>SplitOff</code> 字段正是为了简化这种情况。
</p><p>
当需要第三个软件包的时候，有两种不同的命名办法，取决于共享库是软件包的主要功能(情况一)，还是可执行程序是主要功能(情况二)。对于第一种情况，使用下面的命名模式：
</p>
<itemtable labeld="Contents" labelt="Package">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>共享库</p></itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd><p>头文件</p></itemd></item>
<item><itemt><code>foo-bin</code></itemt>
<itemd><p>二进制执行文件，等等</p></itemd></item>
</itemtable>

<p>对于第二种情况，使用下面的命名模式：</p>
<itemtable labeld="Contents" labelt="Package">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>共享库</p></itemd></item>
<item><itemt><code>foo-dev</code></itemt>
<itemd><p>头文件</p></itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd><p>二进制执行文件，等等</p></itemd></item>
</itemtable>

<p>
对于方法 2，升级一个现存软件包会比较困难：在升级的同时，你需要添加 <code>BuildDepends: foo-dev</code> 到每一个包含 <code>Depends: foo</code> 的软件包中。
另外一个需要记住的升级问题是：为了保证一个成功的升级，间接依赖于（依赖于另外一个软件包，而那个软件软件需要依赖于你）你这个软件包的软件也需要添加 <code>BuildDepends: foo</code> or <code>BuildDepends: foo-dev</code>。
添加 <code>BuildDepends</code> 字段的责任在于你。
</p>
<p><em>规则细节</em></p>
<p>
我们现在讨论更多的细节，我们首先讨论关于一个新移植的软件包的规则，然后转到讨论升级一个现存的软件的问题。我们使用 libpng，libjpeg 和 libtiff 软件包作为规则的实际例子。
</p><p>
已经移植到 Darwin 的软件应该尽可能编译共享库（当然，根据软件包的实际需要，维护者也可以选择编译静态库；如果他们愿意的话，也可以只提交包含静态库的版本）。
当编译共享库的时候，应该创建<em>两个</em>密切相关的 fink 软件包，分别名为 foo 
和 foo-shlibs。共享库放到 foo-shlibs 中，而头文件在放到 foo 中。这两个软件包可以用同一个 .info 文件产生，象下面描述的那样，使用 <code>SplitOff</code> 字段（事实上，通常需要从源程序中编译出不止两个软件包，这时可以使用 <code>SplitOff2</code>，<code>SplitOff3</code>…，等等）
</p><p>
每个有共享库的软件包都有一个<em>主版本号</em> N。当共享库的 API 不再后向兼容以后，才会去改变主版本号。Fink 使用下面的命名约定：如果上游的软件包叫做 bar，那么 fink 软件称为 barN 和 
barN-shlibs（只有在新软件包或主版本号发生改变的软件包上，才会严格应用这个规则）。例如，现存的 libpng 软件包的主版本号是 3，但当前版本的库的主版本号是 3。所以现在有四个软件包：libpng, libpng-shlibs, libpng3, libpng3-shlibs。
在 libpng 和 libpng3 之间只能同时安装一个，但 libpng-shlibs 和 libpng3-shlibs 则可以同时安装。
（注意创建这四个软件包只需要两个 .info 文件）
</p><p>
共享库本身和一些相关文件会被放到 barN-shlibs 软件包中；头文件和一些其它文件会被放到 barN 的软件包。两个软件包中间没有相同的文件，放在 barN-shlibs 的文件的路径应该包含主版本号 N。多数情况下，你的软件包在运行时需要的文件原本时安装到 <filename>%i/lib/bar/</filename> 或 
<filename>%i/share/bar/</filename> 目录中；你应该把安装路径调整到 <filename>%i/lib/bar/N/</filename> 或
<filename>%i/share/bar/N/</filename>。
</p><p>
所有依赖于主版本号为 N 的 bar 软件包的其它软件，需要使用依赖关系
</p>
<codeblock>
  Depends: barN-shlibs
  BuildDepends: barN
</codeblock>
<p>
当本依赖规则系统完全使用以后，将不允许其它软件包依赖于 barN 它自己（为了后向兼容，这种依赖关系允许存在于现存的软件包）。这通过在 barN 的软件包描述中的一个布尔字段：
</p>
<codeblock>
  BuildDependsOnly: True
</codeblock>
<p>
来告诉其它开发者。
</p><p>
如果你的软件包包括共享库和二进制文件，而且二进制文件需要在运行时使用（而不仅仅时编译时），那么这些二进制文件应该被分离到第三个软件包中，这个软件包命名为 barN-bin。其它软件包可以依赖于 barN-shlibs 及 barN-bin。
</p><p>
当编译主版本号为 N 的共享库时，很重要的是要使 <filename>%p/lib/bar.N.dylib</filename> 来作为 &quot;install_name&quot;。（你可以用 <code>otool -L</code> 或<!-- start translation --> otool64 -L for 64bit libraries<!-- end translation --> 来查看你的库的 install_name）。实际的库文件应该被安装在
</p>
<codeblock>
  %i/lib/bar.N.x.y.dylib
</codeblock>
<p>
而你的软件包应该创建符号链接
</p>
<codeblock>
  %i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
</codeblock>
<p>
如果还构建了静态库，那么它应该被安装在
</p>
<codeblock>
  %i/lib/bar.a
</codeblock>
<p>
如果软件包使用 libtool，这些事情通常会被自动处理，
但无论任何情况下，你都应该检查结果时候正确。你还应该检查你的共享库是否已经定义了正确的 current_version 和 compatibility_version 值（
<code>otool -L</code> 或 <code>otool64 -L</code> <!-- start translation -->for 64bit libraries<!-- end translation --> 应该也可以查询得到这些设置值）。
</p><p>
文件应该象下面一样分到两个文件包中
</p>
<ul>
<li>  在 barN-shlibs 软件包中：
<codeblock>
  %i/lib/bar.N.x.y.dylib
  %i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar/N/*
  %i/share/bar/N/*
  %i/share/doc/barN-shlibs/*
</codeblock></li>
<li>  在 barN 软件包中：
<codeblock>
  %i/include/*
  %i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar.a
  %i/share/doc/barN/*
  如果需要的话，包括其它文件
</codeblock></li></ul>
<p>
注意两个文件包都需要一些关于授权协议的文档，但包括文档文件的目录是不同的。
</p><p>
在实践中使用它是很容易的，这可以使用 
<code>SplitOff</code> 字段。下面是关于如何实现上面情况的例子（部分）：
</p>
<codeblock>
Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/bar.N.x.y.dylib lib/bar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;
</codeblock>
<p>
在 <code>SplitOff</code> 字段执行的时候，有关的文件和目录会被从主文件包的 %I 安装目录移动到剥离的文件包的 %i 目录（对于名字同样有类似的约定：%N 是主软件包的名字，%n 是当前软件包的名字）。
<code>DocFiles</code> 命令然后会把一份文档放到
<filename>%i/share/doc/barN-shlibs</filename> 中。
</p><p>
注意我们已经把当前版本的 barN-shlibs 包含为主软件包 barN（
%N-shlibs (= %v-%r) 的缩写）的依赖关系。
这可以确保版本会匹配，而且保证 barN
自动继承 &quot;inherits&quot; barN-shlibs 的所有依赖关系。
</p>
<!-- start translation -->
<p><em>The BuildDependsOnly field</em>
</p><p>
When libraries are being upgraded over time, it is often necessary to have
two versions of the header files available during a transition period,
with one version used for compiling some things and the other version
used for compiling others.  For this reason, the packages containing
header files must be constructed with some care.  If both foo-dev and
bar-dev contain overlapping headers, then foo-dev should declare
</p>
<codeblock>
  Conflicts: bar-dev
  Replaces: bar-dev
</codeblock>
<p>and similarly bar-dev declares Conflicts/Replaces on foo-dev.
</p><p>
In addition, both packages should declare
</p>
<codeblock>
  BuildDependsOnly: True
</codeblock>
<p>This inhibits others from writing packages which depend on foo-dev or
bar-dev, since any such dependency will prevent the smooth operation of the
Conflicts/Replaces method.
</p><p>
There are some packages containing header files for which it's not
appropriate to declare BuildDependsOnly to be true.  In that case,
the package should declare
</p>
<codeblock>
  BuildDependsOnly: False
</codeblock>
<p>and the reason must be given in the DescPackaging field.
</p><p>
The BuildDependsOnly field should only be mentioned in the package's .info
file if the package contains header files, installed into /sw/include.
</p><p>
As of fink 0.20.5, "fink validate" will issue a warning for any .deb
which contains header files and at least one dylib, and does not declare
BuildDependsOnly to be either true or false.  (It is possible that in
future versions of fink, this warning will be expanded to cover the case of
a .deb with header files and a static library as well.)
</p>
<!-- end translation -->
<p><em>Shlibs 字段：</em>
</p><p>
除了把共享库放到合适的软件包中外，作为规则版本 4，你还需要用 <code>Shlibs</code> 字段声明全部共享库。
这个字段每个共享库占一行，这行中包含库的 <code>-install_name</code>，<code>-compatibility_version</code>
<!-- end translation -->
，and the library architecture.  (The library architecture may either be &quot;32&quot;, &quot;64&quot;, or
&quot;32-64&quot;, and may be absent; the value defaults to &quot;32&quot; if it is absent.) 
<!-- end translation -->
以及版本依赖信息，这个信息指明在本兼容版本中提供库的 Fink 软件包。
依赖关系应该用 <code>foo (>= version-revision)</code> 的形式指明。其中
<code>version-revision</code> 指提供这个与（本版本兼容）的共享库的 Fink 软件包的<em>第一个</em>版本。例如，这样</p>
<codeblock>
  Shlibs: &lt;&lt;
    %p/lib/bar.1.dylib 2.1.0 bar1 (>= 1.1-2) 32
  &lt;&lt;
</codeblock>
<p>一个声明表示从 <em>bar1</em> 软件包的版本 1.1-2 开始，已经开始安装一个 <code>-install_name</code> 为 %p/lib/bar.1.dylib，<code>-compatibiliary_version</code> 为 2.1.0 的函数库。另外，这个声明还表示维护者承诺这个名字及 compatibility-version 至少为 2.1.0 以上的 (32bit) 函数库可以在 <em>bar1</em> 软件包的以后版本中找到。
</p><p>
注意在库的名字中使用 %p，这使得无论他们选择什么安装路径前缀，Fink 的所有用户都可以找到正确的 <code>-install_name</code> 代表的函数库。
</p><p>
当一个软件包被更新的时候，通常 <code>Shlibs</code> 字段会被简单地拷贝到软件包的下一个版本／修订版中。例外的情况是如果 <code>-compatibility_version</code> 增加了：那种情况下，依赖信息的版本号应该改变到当前的版本号／修订版号（这是使用新兼容版本号的第一个函数库）。
</p><p>
<em>当主版本号发生变化的时候应该做什么：</em>
</p><p>
如果主版本号从 N 改到了 M，你需要创建两个新的软件包 barM 和 barM-shlibs。 软件包 barM-shlibs 可以不覆盖 barN-shlibs，因为许多用户会同时安装这两个版本。在软件包 barM 中，你应该使用依赖关系
</p>
<codeblock>
  Conflicts: barN
  Replaces: barN
</codeblock>
<p>
类似地，你应该修改 barN 来包括依赖关系
</p>
<codeblock>
  Conflicts: barM
  Replaces: barM
</codeblock>
<p>
用户会看到在构建其它软件包的时候，根据不同的软件的设置，会选择连接 barN 或 barM 作为共享库。这样，我们实现 barN-shlibs 和 barM-shlibs 在系统里面的共存。
</p><p>
<em>How to upgrade an existing fink package:</em>
</p><p>
对于一个现用的 Fink 软件包，无论它是静态库还是共享库，升级的最好版本是为你的软件包创建一个新的版本 foo，以及一个新的软件包 foo-shlibs，来满足上述的规则要求。如果共享库以前已经安装(或者有些文件现在放到 foo-shlibs 中了)，那么这些软件包应该声明
</p>
<codeblock>
  Replaces: foo (&lt;&lt; earliest.compliant.version)
</codeblock>
<p>
这样可以使得升级对用户是透明的。(你<em>不</em>应该说&quot;Conflicts: foo&quot;，因为这样会使得升级无法进行)。
</p><p>
在你升级以后，那些声明 &quot;Depends: foo&quot; 的软件包仍然可以正常工作。不过，你应该连接这些软件包的维护者，要求他们尽快修改他们的软件包描述为  &quot;Depends: foo-shlibs, BuildDepends: foo&quot;。在他们修改完毕以前，你不能够创建使用新的主版本号的 fooM，fooM-shlibs 软件包。</p><p>
那些没有使用正确的 install_name 的现存软件包或者那些没有使用正确的名字或符号连接到共享库的软件包在升级的时候必须很小心，这需要逐个情况进行分析。如果你在使你的软件包在符合新规则上碰到困难，请在 fink-devel 邮件列表中进行讨论。</p><p>
<em>Packages containing both binary files and libraries:</em>
</p><p>
如果上游软件包包含二进制文件和库，那么在构建 fink 软件包的时候有些事情需要特别注意。有些情况下，那些二进制文件仅仅是一些类似 <code>foo-config</code> 的程序 ，它们只需要在构建的时候使用，而不需要在运行时使用。这种情况下，二进制文件可以和头文件一样包括在 <code>foo</code>
软件包中。
</p><p>
其它情况下，这些二进制文件可能需要在运行时被其它软件包使用，这时，它们需要被剥离到一个单独的文件包中，这个软件包的名字大约是 <code>foo-bin</code>。<code>foo-bin</code> 软件包应该依赖于 <code>foo-shlibs</code> 软件包，其它软件包的维护者最好能够使用：
</p>
<codeblock>
  Depends: foo-bin
  BuildDepends: foo
</codeblock>
<p>
来隐式地处理 foo-shlibs。
</p><p>
在升级的时候会有一个问题，因为用户不会被提示安装 <code>foo-bin</code>。要避免这个问题，在全部其它软件包维护者象上面所说的一样修改它们的软件包之前，你的 <code>foo</code> 软件包可以这样声明：
</p>
<codeblock>
  Depends: foo-shlibs (= exact.version), foo-bin
</codeblock>
<p>
这可以强制安装 foo-bin 在多数用户的系统里面，只要有一天其它软件包维护者也升级了依赖于 <code>foo</code> 的软件包。
</p>

</section>

<section name="perlmods"><title>Perl 模块</title>
<p>Fink 从 2003 年 5 月开始实施的对 perl 模块的规则，在 2004 年 4 月进行了修改。
</p><p>
传统上，关于 perl 模块的 Fink 软件包具有
<code>-pm</code> 后缀，并使用 <code>Type: perl</code> 
指令来构建，它把 perl 模块的文件保存在 <filename>/sw/lib/perl5</filename> 和/或
<filename>/sw/lib/perl5/darwin</filename>中。按照现行规则，这个存储位置仅允许用于那些与编译它们的 perl 程序版本无关的 perl 模块(同时也不应该依赖于那些不具备版本无关性的其它模块)。
</p><p>
那些版本相关的 perl 模块称为 XS 模块，
通常除了纯粹的 perl 子程序外，还包括编译好的 C 代码。有很多办法可以识别这个情况，包括存在带有 <code>.bundle</code> 后缀的文件等。
</p><p>
版本相关的 perl 模块必须使用标明版本号的 perl 程序来编译，比方说 <code>perl5.6.0</code>，而且必须把它的文件标准 perl 目录下面的一个标明版本号的子目录中，例如
<filename>/sw/lib/perl5/5.6.0</filename> 和 <filename>/sw/lib/perl5/5.6.0/darwin</filename>。习惯上，使用后缀 <code>-pm560</code> 的命名约定来代表针对 5.6.0 的 perl 模块。类似的存储和命名约定也会用于其它版本的 perl，包括 perl 5.6.1 (仅用于 10.2 代码树), perl 5.8.0 (仅用于 10.3 代码树), perl 5.8.1, perl 5.8.4, 和 perl 5.8.6。
</p><p>
<code>Type: perl 5.6.0</code> 指令会自动使用相应标定版本的 perl 程序，并把文件存储在正确的子目录中。
(这个指令从 fink 0.13.0 版本开始提供)。</p>
<p>按照 2003 年 5 月的规则，可以允创建一个 <code>-pm</code> 软件包，它实际是去加载 <code>-pm560</code> 或其它存在的相应版本的&quot;束&quot;软件包。按照 2004 年 4 月的规则，不再鼓励这样做，而且经过一个过渡期后，将会完全放弃这种做法。(唯一的例外是 <code>storable-pm</code> 软件包因为自举的需要仍然需要保持这种形式)。</p>
<!-- start translation -->
<p>As of fink 0.20.2, the system-perl virtual package automatically
"Provides" certain perl modules when the version of Perl present on
the system is at
least 5.8.0.  In the case of system-perl-5.8.1-1, these are:
<em>attribute-handlers-pm581, cgi-pm581, digest-md5-pm581, file-spec-pm581, 
file-temp-pm581, filter-simple-pm581, filter-util-pm581, getopt-long-pm581, 
i18n-langtags-pm581, libnet-pm581, locale-maketext-pm581, memoize-pm581, 
mime-base64-pm581, scalar-list-utils-pm581, test-harness-pm581, 
test-simple-pm581, time-hires-pm581.</em>
(This list was slightly different in fink 0.20.1: package maintainers are
encouraged to check to be sure that they are assuming the correct list.)
</p>
<p>
Users may have more than one version of perl installed at a time, so
any perl-versioned module packages must be written to allow more than
one version of themselves to be installed concurrently. One must use
care when installing manpages and binary or other script executables
in these packages in order to prevent installation conflicts due to
filename collisions. 
You are not allowed to have any files in a package whose name ends
with -pm<em>XYZ</em> that would have an identical pathname across
different <em>XYZ</em>. Using <code>Replaces</code> to allow the
same-named files to overwrite each other in different perl-versions of
these perl-module packages is no longer acceptable.
As a simple solution for manpages, starting in
March 2005, Fink has defined alternate locations in MANPATH:
<filename>%p/lib/perl5/X.Y.Z/man</filename> for each perl-X.Y.Z. You
no longer need to create mutually-exclusive -man or -doc SplitOff
packages. For
example, to avoid conflicts between uri-pm581 and uri-pm586, the
same-named <filename>URI.3pm</filename> manpage is installed
as <filename>%p/lib/perl5/5.8.1/man/man3/URI.3pm</filename> and
<filename>%p/lib/perl5/5.8.6/man/man3/URI.3pm</filename>,
respectively. Note that the default scripts provided by <code>Type:
perl X.Y.Z</code> have not changed, so you will have to locate the
manpages here manually in your <code>InstallScript</code>. If you
don't have a highly customized script, you can still use the default
one, and then simply move the files manually:
</p>
<codeblock>
%{default_script}
mv %i/share/man %i/lib/perl5/5.8.1
</codeblock>
<p>
That will move all manpages. If you wish to move only one section of
manpages (for example, only section 3, the module manpages, not script
manpages in section 1), a similar approach works:
</p>
<codeblock>
%{default_script}
mkdir -p %i/lib/perl5/5.8.1/man
mv %i/share/man/man3 %i/lib/perl5/5.8.1/man
</codeblock>
<p>
If you have executables, for example, demo or utility scripts
in <filename>%p/bin</filename>, you have several options. One example
is to put these files (and their associated manpages and/or other
related files) in a %N-bin splitoff package. Use of
<code>Conflicts</code> and <code>Replaces</code> fields ensures that
installation of different perl-version forms of these packages, which
contain files of the same name, is mutually excluve. The user can
install many different perl-versions of the runtime modules, and then
choose whichever one perl-version of the scripts he wants at a given
time. For example, Tk.pm comes with an
executable <filename>ptksh</filename>, so the set of tk-pm* packages
could be constructed as follows:
</p>
<codeblock>
Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.8.1 5.8.4 5.8.6)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
&lt;&lt;
SplitOff: &lt;&lt;
  Package: %N-bin
  Depends: %N
  Conflicts: %{Ni}5.8.1, %{Ni}5.8.4, %{Ni}5.8.6
  Replaces: %{Ni}5.8.1, %{Ni}5.8.4, %{Ni}5.8.6
  Files: bin share/man/man1
&lt;&lt;
&lt;&lt;
</codeblock>
<p>
An alternative arrangement is to rename the scripts and their manpages
to include perl-version information. This method means there is no
naming conflict at all, so one does not need the mutually-exclusive
%N-bin splitoffs:
</p>
<codeblock>
Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.8.1 5.8.4 5.8.6)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
  mv %i/bin/ptksh %i/bin/ptksh%type_raw[perl]
  mv %i/share/man/man1/ptksh.1 %i/share/man/man1/ptksh%type_raw[perl].1
&lt;&lt;
&lt;&lt;
</codeblock>
<p>
The user accesses ptksh for whichever perl she wants. For convenience,
one could use <code>update-alternatives</code> to allow users to be
able to access these by their generic (no perl-version) names as well.
</p>
<p>
Also as of March 2005, the location of manpages and modules installed
by fink packages for perl itself (packages perlXYZ and perlXYZ-core
other than the perl-version provided by Apple) has changed. As a
result of this relocation, other fink packages that supply updated
versions of core perl modules should not list any perlXYZ or
perlXYZ-core packages in the <code>Replaces</code> field.
</p>
<!-- end translation -->

</section>
<section name="emacs"><title>Emacs 规则</title>
<p>Fink 项目选择遵循 Debian 项目针对 emacs 的规则，但稍微有些差别。
（Debian 规则文档可以在
<link 
url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">
http://www.debian.org/doc/packaging-manuals/debian-emacs-policy</link> 找到）。
在 Fink 的规则中有两点区别。
首先，在 fink 中这个规则目前仅应用于 emacs20 和 emacs21 软件包，而不应用于 xemacs。（这在将来可能会有改变）。
第二，不象 Debian 的规则，Fink 软件包允许安装东西到 /sw/share/emacs/site-lisp 目录中。
</p>

</section>

</chapter>


<chapter filename="fslayout">
<title>文件系统布局</title>
<shorttitle>文件系统布局</shorttitle>


<preface>
<p>
下述的文件系统布局指南是 Fink 打包规则的一部分。
</p>
</preface>


<section name="fhs"><title>文件系统层次结构标准</title>
<p>
Fink 遵循<link
url="http://www.pathname.com/fhs/">《文件系统层次结构标准》(Filesystem Hierarchy
Standard)</link>，简称 FHS 的精神。
我们只能说遵循它的精神，是因为 FHS 是为操作系统提供者所涉及的，因此它是在 <filename>/</filename> 和
<filename>/usr</filename> 层次级别上来控制。而 Fink 只是一个附加的系统，它指控制它自己的安装目录(或安装前缀指定的目录)。
本章的例子使用默认的前缀 <filename>/sw</filename>。
</p>
</section>

<section name="dirs"><title>目录</title>
<p>
文件应该分类存放在层次结构中下列子目录中：
</p>

<itemtable>

<item><itemt><filename>/sw/bin</filename></itemt>
<itemd>
<p>
这个目录存放通常的可执行程序。里面没有子目录。
</p>
</itemd></item>

<item><itemt><filename>/sw/sbin</filename></itemt>
<itemd>
<p>
这个目录存放那些应该只由系统管理员使用的命令。
后台守护进程程序会放在这里。
里面没有子目录。
</p>
</itemd></item>

<item><itemt><filename>/sw/include</filename></itemt>
<itemd>
<p>
这个目录存放 C 和 C++ 头文件。
如果需要的话，可以创建子目录。
如果软件包安装的头文件可能与标准的 C 头文件发生混淆的话，这些头文件<em>必须</em>放到子目录中。
</p>
</itemd></item>

<item><itemt><filename>/sw/lib</filename></itemt>
<itemd>
<p>
这个目录存放那些系统架构相关的数据文件和函数库。
除非有特别的理由，否则静态和动态连接库应该直接保存在 <filename>/sw/lib</filename>。
这里通常还保存那些不应该由用户直接运行的可执行程序(否则的话，应该放在 libexec)。
</p>
<p>
软件包可以创建子目录来存放私有数据或可加载模块。
请确定使用那些对保持兼容性有利的目录名。
在目录名或目录层次中使用主版本号是个好办法，例如：<filename>/sw/lib/perl5</filename>
或 <filename>/sw/lib/apache/1.3</filename>。
Care should be taken when the host type is used to create
directories.
<code>powerpc-apple-darwin1.3.3</code> 这样的目录对兼容性是不利的，<code>powerpc-apple-darwin1.3</code> 或仅仅是
<code>powerpc-apple-darwin</code> 是个好些的选择。
</p>
</itemd></item>

<item><itemt><filename>/sw/lib/ppc64</filename>
<filename>/sw/lib/x86_64</filename></itemt>
<itemd>
<!-- start translation -->
<p>
This directory is for 64-bit libraries, with <filename>/sw/lib/ppc64</filename>
being used under powerpc architecture, and
<filename>/sw/lib/x86_64</filename> being used under i386 architecture.
Libraries which have been built 'fat' should be stored in
<filename>/sw/lib</filename> instead.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt><filename>/sw/share</filename></itemt>
<itemd>
<p>
这个目录是存放那些系统体系架构无关的数据文件。
那些 <filename>/sw/lib</filename> 中的规则也适用于这里。
下面描述一些通常的子目录。
</p>
</itemd></item>

<item><itemt><filename>/sw/share/man</filename></itemt>
<itemd>
<p>
这些目录中包括帮助页。它按照通常的分类方法进行组织。
在 <filename>/sw/bin</filename> 和
<filename>/sw/sbin</filename> 中的每个程序都应该有一个对应的帮助页。
</p>
</itemd></item>

<item><itemt><filename>/sw/share/info</filename></itemt>
<itemd>
<p>
这个目录包含 Info 格式(从 Texinfo 源文件产生)的文档。
<code>dir</code> 文件的维护是通过 Debian 版本的 <code>install-info</code> (<code>dpkg</code> 软件包的一部分) 来自动进行的。
适用 <code>InfoDocs</code> 描述字段来自动生成 <code>postinst</code> 和 <code>prerm</code> 软件包脚本的合适代码。
Fink 确保不会有软件包会安装它自己的 <code>dir</code> 文件。
这里不会有子目录。
</p>
</itemd></item>

<item><itemt><filename>/sw/share/doc</filename></itemt>
<itemd>
<p>
这个目录包括那些既不是帮助页，也不是 Info 的文档。
例如 README，LICENSE 和 COPYING 文件等。
每个软件包必须在这里创建一个子目录，以软件包的名字命名。
目录名不能包括版本号(除非它正好是软件包名的一部分)。
提示：使用 <code>%n</code> 就好了。
</p>
</itemd></item>

<item><itemt><filename>/sw/share/locale</filename></itemt>
<itemd>
<p>
这个目录包含国际化所需要的信息目录。
</p>
</itemd></item>

<item><itemt><filename>/sw/var</filename></itemt>
<itemd>
<p>
<filename>var</filename> 目录保存可变数据。
它包括队列目录，访问锁文件，状态数据库，游戏最高分和日志文件。
</p>
</itemd></item>

<item><itemt><filename>/sw/etc</filename></itemt>
<itemd>
<p>
这个目录保存配置文件。
对于那些需要在这里保存比较多文件(比方超过一两个的数目)的软件包，应该建立一个子目录。
子目录应该和软件包或者里面的程序同名，以方便识别。
</p>
</itemd></item>

<item><itemt><filename>/sw/src</filename></itemt>
<itemd>
<p>
这个目录用于保存和构建源代码。
软件包不应该在这个目录里面安装任何东西。
</p>
</itemd></item>

</itemtable>
</section>


<section name="avoid"><title>应该避免的事情</title>
<p>
除了上面提到的以外，在 <filename>/sw</filename> 中不应该有其它的目录。
特别地，不应该使用下面这些目录：
<filename>/sw/man</filename>，<filename>/sw/info</filename>，
<filename>/sw/doc</filename>，<filename>/sw/libexec</filename>，
<filename>/sw/lib/locale</filename>。
</p>
</section>


</chapter>

<chapter filename="compilers">
<title>Compilers</title>
<shorttitle>Compilers</shorttitle>

<preface>
<p>
Fink uses the gcc family of compilers, as provided by Apple computer
through the Apple Developer Connection. Different versions of gcc exist,
and usually more than one is available on a Mac OS X system.
</p><p>
This section explains some of the ways Fink deals with these different versions
of gcc. An email to the Fink mailing list has <link 
url="http://www.mail-archive.com/fink-devel@lists.sourceforge.net/msg11877.html"
>more explanation</link>.
</p>
</preface>

<section name="versions"><title>Compiler Versions</title>
<p>
As GCC has evolved,
there have been different fink "distributions" to cope with the changes.
</p>
<p>
Each Fink distribution has had certain default values for the gcc and g++
compilers, which any user compiling from source is expected to have
installed.  You can expect that direct calls to "gcc" and "g++" from
within your package will use these default values.  If you need to use
a different value (for example, during a transition to a new distribution,
your packages .info file must specify this using the versioned binaries
provided by Apple.  Exactly how you will do this depends on the build
system of your software, but for many packages, the <code>SetCC</code>
and <code>SetCXX</code> fink fields can be used for this puporse.
For example, you might change the g++ compiler to version 3.3 by the setting
<code>SetCXX: g++-3.3</code>.  Examine the output when building your
package to make sure that the correct compiler is being used.
</p><p>
The 10.1 distribution assumes that the compiler version is 2.95; the
10.2 distribution assumes that the compiler version is 3.1; the 10.2-gcc3.3
and 10.3 distributions assume tha the compiler version is 3.3.   The compiler
for the 10.4-transitional distribution is complicated: g++-3.3 is being
used along with gcc-4.0.  This will change again in the 10.4 distribution,
which will use both gcc-4.0 and g++-4.0.
</p>
<p>A new method was introduced for ensuring the correct g++ compiler starting
with the 10.4-transitional distribution.  During compilation, a directory
<code>/sw/var/lib/fink/path-prefix-g++-XXX</code> (where XXX is the version
number) is added to the PATH during compilation.  This directory contains
shell scripts which ensure that the correct version of g++ is used.
</p>

</section>
<section name="abi"><title>The g++ ABI</title>
<p>
The g++ ABI has changed 3 times during the lifetime of OS X: the ABI is
different for versions 2.95, 3.1, 3.3 and 4.0.  These different ABIs
are not compatible with each other, and any libraries which use C++
code and are linked to by your project must be compiled with the same
ABI as the one currently being used.
</p>
<p>
Fink keeps track of the g++ ABI by means of the GCC field.  This field
should be defined for any package which invokes the g++ or c++ compilers.
(It should NOT be defined for packages which don't invoke those compilers.)
Whenever an ABI upgrade occurs, all the dependencies of the packages must
be checked for their own GCC field.  When all of the dependencies have
been upgraded, the package itself may be upgraded.  The versions of the
dependencies must be changed to guarantee that users will have the correct,
updated, dependencies in place before they attempt to build the new version
of your package.
</p>
<p>
A small group of packages which depend only on each other can be left 
at the previous version of the ABI when the distribution changes, if they
are not ready to be upgrade.  When the upgrade is eventually done, they
must be all upgraded together with the correct versioning on all the
packages.  For this reason, it is best to upgrade most packages at
the time the distribution changes.
</p>
<p>
Fink uses the GCC field to ensure that users have the correct version of
the g++ compiler installed.  If the GCC field is defined by the package,
fink checks to see if the <code>gcc_select</code> command has been
set to the correct current value.  (This correct value is 3.3 for the 10.2
and 10.3 versions of OS X, and 4.0 for the 10.4 version of OS X.  The 
<code>gcc_select</code> command was not available prior to OS X 10.2.)
</p>

</section>

</chapter>

<chapter filename="reference">
<title>操作手册</title>
<shorttitle>操作手册</shorttitle>


<section name="build"><title>构建过程</title>

<p>要理解一些字段的含义，你需要有对 Fink 所采用的构建过程有些了解。它由五个阶段组成：解压，补丁，编译，安装和构建。下面的示例路径是关于安装在 <filename>/sw</filename> 的 gimp-1.2.1-1 软件包的。</p>
<p>在<em>解压阶段</em>，<filename>/sw/src/fink.build/gimp-1.2.1-1</filename> 这个目录会被创建，源代码压缩档会被在这里解压。多数情况下，这会创建一个名为 gimp-1.2.1 的目录，里面包括源代码；下面的操作步骤会在那个目录里面执行(即 <filename>/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>)。我们可以使用 SourceDirectory，NoSourceDirectory 和 Source<em>N</em>ExtractDir
这三个字段来控制有关细节。</p>
<p>在<em>补丁阶段</em>，源代码会被打上补丁，以使得可以在 Darwin 下面编译。由 UpdateConfigGuess，UpdateLibtool，Patch 和 PatchScrip 这几个字段所指明的操作将被按照顺序执行。</p>
<p>在<em>编译阶段</em>，源代码被配置和编译。通常这会以某些参数来调用 <code>configure</code> 脚本，然后执行一个 <code>make</code> 命令。
详细信息请查看 CompileScript 字段的描述。
<!-- start translation -->
If test suites are enabled
for the build (a new feature in fink 0.25, currently achieved by building in
maintainer mode), the TestScript will be run immediately after the
CompileScript.
<!-- end translation -->
</p>
<p>在<em>安装阶段</em>，软件包被安装到一个临时目录，<filename>/sw/src/fink.build/root-gimp-1.2.1-1</filename> (= %d)。(注意 &quot;root-&quot; 部分。)
所有通常应该安装到 <filename>/sw</filename> 的文件现在被安装在
<filename>/sw/src/fink.build/root-gimp-1.2.1-1/sw</filename> (= %i = %d%p)。 
详细信息请查看 InstallScript 字段的描述。</p>
<p>(<em>从 fink 0.9.9 开始，</em>可以通过 <code>SplitOff</code> 字段从一个软件包描述文件生成几个软件包。在安装阶段的尾段，会为每个软件包建立一个单独的安装目录，文件会被移到相应的目录中，)</p>
<p>在<em>构建阶段</em>，会根据临时文件夹的内容构建一个二进制安装包(.deb)文件。你不能直接影响这个步骤，但软件包描述里面的许多字段会用于生成 dpkg 的 <filename>control</filename> 文件。</p>
</section>

<section name="fields"><title>字段</title>

<p>我们在这里把字段分成几类。这里所描述的内容并不一定包括全部的字段。<code>:-)</code></p>
<p><em>初始化数据：</em></p>
<itemtable>
<item><itemt>Package</itemt>
<itemd>
<p>
软件包名。
可以包括小写字母，数字和这几个特殊字符：&quot;.&quot;'，
&quot;+&quot; 和 &quot;-&quot;。
不可以使用下划线(&quot;_&quot;),不可以使用大写字母。
这是一个必需字段。
</p>
<p>对这个字段，只可应用 %N、%{Ni}、%type_raw[] 和 %type_pkg[] 这几种百分号扩展。</p>
<p>
作为 Fink 的打包规则，给定的软件包应该总是使用相同的选项进行编译。
如果对一个软件包由多个变种(查阅关于 <code>Type</code> 字段的文档)，你必须在 <code>Package</code> 字段中加入特定变种的信息(查阅关于 %type_pkg[] 百分号展开的文档)。
这样每个变种会由一个唯一的名称，软件包名字会指明包含了哪些变种的选项。
注意在 <code>Package</code> 字段使用 %type_pkg[] 和 %type_raw[] 百分号展开是新的功能，并与旧的 fink 版本严重不兼容，所以这些软件包的描述应该嵌入在 <code>InfoN</code> (N>=2)字段中。
</p>
</itemd></item>

<item><itemt>Version</itemt>
<itemd>
<p>
上游版本号。与 Package 字段具有同样的限制。
这是一个必需字段。
</p>
<!-- start translation -->
<p>
  Note that some programs use nonstandard version numbering schemes
  that may cause sorting confusion or that contain characters that are
  not allowed in this field. In these situations, when writing the
  Fink package, you must convert the upstream value to one that is
  acceptable and that allows the versions to be arranged in the
  correct order. When in doubt about how version strings will be
  sorted, you can use the <code>dpkg</code> command at a shell
  prompt. For example,
</p>
<codeblock>
  dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo "true"
</codeblock>
<p>
  will print &quot;true&quot; because version string &quot;1.2.1&quot;
  is less than &quot;1.3&quot;. See the <code>dpkg</code> manpage for
  more details.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>Revision</itemt>
<itemd>
<p>
软件包的修订版号。
当你对一个相同的上游版本提供一个新的描述文件的时候，需要增加它。
修订版号从 1 开始。
这是一个必需字段。
</p>
<!-- start translation -->
<p>
  Fink's policy is that <em>any</em> time you make a change to the
  <filename>.info</filename> file that results in changes to the
  binary (compiled) form of a package (the <filename>.deb</filename>
  file), you <em>must</em> increase <code>Revision</code>. This
  includes changing the <code>Depends</code> or other package lists,
  and adding,
  removing, or renaming splitoff packages or shifting files among
  them. When migrating a package to a new tree (from 10.2 to 10.3, for
  example) involves such changes, you should
  increase <code>Revision</code> by 10 (or some other large number) in the newer tree in order to
  leave space for future updates to the package in the older
  tree.
</p>
<!-- end translation -->
</itemd></item>
<item><itemt>Architecture</itemt>
<itemd>
<!-- start translation -->
<p>
A comma-separated list of CPU architecture(s) for which the package
(and any splitoff packages) are intended.
At present, the only valid values for architecture are <code>powerpc</code>
and <code>i386</code>. If this field is present and not blank after
conditional handling, fink will ignore the package description(s) if
the local machine architecture is not listed. If the field is omitted
or the value is blank, all architectures are assumed.
(Introduced in a post-0.24.11 CVS version of fink.)
</p>
<p>
At present, the most common use of this field will be for packages which
require a compiler earlier than gcc-4.0 (or packages which depend on such
packages), which should be declared to have architecture 
<code>powerpc</code>.
</p>
<p>
This field supports the standard conditional syntax for any value in
the value list and percent-expansions can be used (see
the <code>Depends</code> field for more information). In this manner,
certain variants can be restricted to certain architectures. For
example:
</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.1 5.8.4 5.8.6)
  Architecture: (%type_pkg[perl] = 581) powerpc
</codeblock>
<p>
will result in the field for the foo-pm581 variant
being <code>powerpc</code> and the field being blank for all other
variants. Remember that omitting a certain architecture value does not
mean that the package is not for that architecture.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>Epoch</itemt>
<itemd>
<p>
<em>从 fink 0.12.0 开始。</em>
这个可选字段可以用来指明软件包关键版本号(如果没有提供，默认值为 0).更多信息参考<link
url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian
规则手册</link>.
<!-- start translation -->
Because Fink and some of the underlying Debian tools use
name-version-revision as the unique identifier of a package, you must
not create a package that differs from another solely by its epoch.
<!-- end translation -->
</p>
</itemd></item>

<item><itemt>Description</itemt>
<itemd>
<p>
对软件包的一个简单描述(有关它是什么东西的问题。)这是一个会显示在列表中的一行描述，所以它要简单明了。它应该少于 45 字符，必需少于 60 字符。在这个字段里面不需要重复软件包的名字-它总会被显式正确的上下文中。这是一个必需字段。
</p>
</itemd></item>

<item><itemt>Type</itemt>
<itemd>
<p>
这可以设为 <code>bundle</code>。
束(Bundle)软件包可以用于一套相关的软件包归类在一起。
它们只有依赖管理，但没有代码和安装文件。
对于束文件包，Source，PatchScript，CompileScript，InstallScript 以及其它相关的字段都会被忽略。
</p>
<p>
<code>nosource</code> 是一个很类似的类型。
它表明没有源程序压缩档，所以不会有东西被下载，解压阶段只是创建一个空目录。
不过，补丁，编译和安装阶段则会正常执行。
这样你可以通过补丁放进全部代码，或者只是在 InstallScript 中创建一些目录。
从 fink 0.18.0 开始，你可以通过设置 <code>Source: none</code> 来获得同样的效果。这样你可以把 &quot;Type&quot; 字段用于其它目的(比如：<code>Type: perl</code>，等等)。
</p>
<p>
从 fink 0.9.5 开始，开始有 <code>perl</code> 类型，它会对编译和安装脚本使用另外一套默认值。
从 fink 0.13.0 开始，有个这种类型的变种，
<code>perl $version</code>，其中 $version 是 perl 的一个版本号，它由句点分开的三个数字组成，例如： 
<code>perl 5.6.0</code>。
</p>
<p>
在 fink-0.19.2 后的一个 CVS 版本开始，language/language-version use 被通用化，以允许使用任意维护者定义的类型以及相应的子类型，并对一个给定的软件包可以使用多于一种类型。
类型和子类型均为不包含空白字符的任意字符串(但不应该使括号、逗号、花括号和百分号)；不会进行百分号展开，类型(并非子类型)数值会被转换成小写。
多种类型值(每个类型可以有一个用空白字符分开的可选的子类型)可以用逗号分隔的列表指定。
</p>
<p>
另外，存在“变种”的概念，即一个 .info 文件描述一族相关的使用不同编译选项的软件包。
这个过程的关键是使用一系列子类型。
我们不使用单个字符串，而是使用括号中的一列用空格分开的字符串。
Fink 会对每种子类型克隆软件包描述文件，并在其中使用其中一个子类型。
例如：
</p>
<codeblock>Type: perl (5.6.0 5.8.1)</codeblock>
<p>
提供两个软件包描述，其中一个作为 <code>Type: perl 5.6.0</code>，另外一个作为 <code>Type: perl 5.8.1</code>。
特殊的子类型清单 &quot;(boolean)&quot; 代表一个包含它自己和一个句点的清单，因此下面的两种形式是相同的：
</p>
<codeblock>
Type: -x11 (boolean)
Type: -x11 (-x11 .)
</codeblock>
<p>
子类型清单展开/软件包克隆是递归的；如果在子类型清单中有多个类型，你会活得所有可能的组合：
</p>
<codeblock>Type: -ssl (boolean), perl (5.6.0 5.8.1)</codeblock>
<p>
可以使用 %type_raw[] 和 %type_pkg[] 伪哈希值来在其它字段中访问特定的变种子类型。
这里是两个示范的 .info 片段：
</p>
<codeblock>
Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.6.0 5.8.1)
Depends: perl%type_pkg[perl]-core
 &lt;&lt;
</codeblock>
<codeblock>
Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [ &quot;%type_raw[-x11]&quot; == &quot;-x11&quot; ]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;
</codeblock>
<!-- start translation -->
<p>
Starting in fink 0.26.0, there is a special <code>Type: -64bit</code>
which controls a new percent expansion <code>%lib</code> and also
changes the default value of <code>LDFLAGS</code>.  When combined
with the new construction %type_num[], this allows a single .info file
to build both a 32-bit version of a library and a 64-bit version.
Here's some sample code:
</p>
<codeblock>
Info2: &lt;&lt;
Package: foo%type_pkg[-64bit]
Type: -64bit (boolean)
Depends: (%type_raw[-64bit] = -64bit) 64bit-cpu
ConfigureParams: --libdir='${prefix}/%lib'
SplitOff: &lt;&lt;
 Package: %N-shlibs
 Files: %lib/libfoo.*.dylib
 Shlibs: &lt;&lt;
    %p/%lib/libfoo.1.dylib 1.0.0 %n (>= 1.0-1) %type_num[-64bit]
  &lt;&lt;
&lt;&lt;
&lt;&lt;
</codeblock>
<!-- end translation -->
</itemd></item>

<item><itemt>License</itemt>
<itemd>
<p>
本字段给出软件包发布所依据的授权协议的性质。它必须是本文档前面<xref
chapter="policy" section="licenses">软件包授权协议</xref>中所描述的值之一。 另外，只有软件包确实满足打包规则在这方面的要求时，比如已经在软件包的 doc 目录安装了一份授权协议，才能够设置这个字段。
</p>
</itemd></item>

<item><itemt>Maintainer</itemt>
<itemd>
<p>
负责本软件包的人的姓名和电子邮件地址。这是一个必需字段，而且必需是下面格式的一个名字和地址：
</p>
<codeblock>Firstname Lastname &lt;user@host.domain.com&gt;</codeblock>
</itemd></item>

<item><itemt>InfoN</itemt>
<itemd>
<p>
本字段允许 fink 在软件包描述文件中实现后向兼容的语法改变。
一个给定版本的 fink 被配置为能够处理某个最大的 &quot;N&quot; 整数值。
任意在更高的 InfoN 字段的软件包会被忽略，所以这种机制仅在有需要的时候才使用，否则那些使用较旧版本的用户就会被没有必要地区别出去了。
要使用这个机制，把整个软件包描述放到合适的 InfoN 字段中间。
参考前面的 &quot;File Format&quot; 部分了解多行字段的语法。
<!-- start translation -->
Here are the features added for each InfoN level, along with the
earliest version of fink that supports it:
</p>
<ul>
<li>
<code>Info2</code> (fink>=0.20.0): Ability to use percent-expansions
in the main <code>Package</code> field of the .info file and the
ability to use the <code>%type_*</code> percent-expansions in
the <code>Package</code> field of <code>SplitOff</code>
(and <code>SplitOff<em>N</em></code>) packages.
</li>
<li>
<code>Info3</code> (fink>=0.25.0): Can indent nicely in .info files,
no more support for RFC-822 multi-lines, and can put comments in
pkglist fields.
</li>
</ul>
<!-- end translation -->

</itemd></item>

</itemtable>
<p><em>依赖关系：</em></p>
<itemtable>

<item><itemt>Depends</itemt>
<itemd>
<p>
在本软件包构建前必需安装的软件包的列表。
在这个字段中会进行百分号展开(也包括这部分中的其它软件包列表字段：BuildDepends、Provides、Conflicts、Replaces、Recommends、Suggests 和 Enhances)。
通常，它只是以逗号分割软件包名清单，但 Fink 现在也和 dpkg 一样支持替代软件包和版本子句。
一个体现全部特性的例子是：
</p>
<codeblock>Depends: daemonic (&gt;= 20010902-1), emacs | xemacs</codeblock>
<p>
注意，其实没有办法去表达真正的可选依赖关系。
如果一个软件包在有和没有另外一个软件包的情况下都可以工作，你必需要么确定即使有那个软件包存在的情况下都不会去使用它，或者把它添加到依赖关系字段中。
如果你想提供给用户两种选择，你应该使用两个软件包，例如：wget 和 wget-ssl。
</p>
<p>操作顺序：在逗号分隔的列表中的每个软件包(或替代关系的集合)中，逻辑&quot;OR&quot;(可替代项的列表)具有比逻辑&quot;AND&quot;更优先的操作次序。不象算术中可以使用括号，没有办法特别在 <code>Depends</code> 或类似的字段中指明某个软件包组具有优先的次序。</p>
<p>
从 fink 的 0.18.2 后 CVS 版本开始，你可以使用条件依赖关系。它通过在软件包名字前面放置
<code>(string1 op string2)</code> 来指定。首先会对这两个字符串进行通常的百分号展开，然后这两个字符串(都不能为空)会按照 <code>op</code> 运算符进行比较：&lt;&lt;， &lt;=，=，!=，&gt;&gt;，&gt;=。只有在比较的结果为真的时候，后面的软件包才会被认为是一个依赖关系。
</p><p>
你可以使用这个格式来简化维护几个类似的软件包的工作。例如，elinks 和 elinks-ssl 包里面都可以这样写：
</p>
<codeblock>Depends: (%n = elinks-ssl) openssl097-shlibs, expat-shlibs</codeblock>
<p>
这和在 elinks 中写：
</p>
<codeblock>Depends: expat-shlibs</codeblock>
<p>
elinks-ssl 中写：
</p>
<codeblock>Depends: openssl097-shlibs, expat-shlibs</codeblock>
<p>是等价的。</p>
<p>作为替代的语法格式，如果 <code>string</code> 不为空的话，你也可以指定 <code>(string)</code> 为&quot;true&quot;。例如：</p>
<codeblock>
package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11
</codeblock>
<p>会把软件包 X11 设为 nethack-x11 变量的一个依赖关系，而不是 nethack。</p>
<!-- start translation -->
<p>
  Note that when using Depends/BuildDepends for shared library packages
  for which more than one major-version is available, you must
  <em>not</em> do the following:
</p>
<codeblock>
  Package: foo
  Depends: id3lib3.7-shlibs | id3lib3.7-shlibs
  BuildDepends: id3lib3.7-dev | id3lib4-dev
</codeblock>
<p>
  even if your package could work with either library. Pick one
  (preferably the highest version that can be used successfully) and
  use it consistently in your package.
</p>
<p>
  As explained in the <xref chapter="policy"
  section="sharedlibs">Shared Library Policy</xref>, only one of the
  -dev packages can be installed at a time, and each has links of the
  same name that could point to different filenames in the associated
  -shlibs package. When compiling package foo, the actual filename (in
  the -shlibs package) gets hard-coded into the foo binary. That means
  the resulting package needs the specific -shlibs package associated
  with the -dev that was installed at compile-time. As a result, one
  cannot have a <code>Depends</code> that indicates that either one
  will suffice.
</p>
<p>
In the past, non-essential packages implicitly depended on the
essential ones; this is no longer true.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>BuildDepends</itemt>
<itemd>
<p>
<em>从 fink 0.9.0 开始。</em>
只在编译时需要的依赖关系的清单。
这可以用于列出构建软件包必须使用工具(比如 flex)。它支持和 Depends 相同的语法。
<!-- start translation -->
If a build is being done
with test suites enabled, the dependencies in the <code>TestDepends</code>
field will be added to this list.
<!-- end translation -->
</p>
</itemd></item>

<item><itemt>Provides</itemt>
<itemd>
<p>
一个逗号分隔的软件包名字清单，它表示本软件包会&quot;提供&quot;那些软件包的功能。
如果一个名为 &quot;pine&quot; 的软件包指明 <code>Provides: mailer</code> 的话，那么只要安装了&quot;pine&quot;，所有对&quot;mailer&quot;的依赖关系都会被认为已经满足。
你通常会把这些软件包名字同时列在 &quot;Conflicts&quot; 和 &quot;Replaces&quot; 字段。
</p>
<!-- start translation -->
<p>
Note that there is no versioning data associated with Provides
items. They do not inherit from the parent package that contains the
Provides list nor is there a syntax for specifing an arbitrary version
in the Provides field itself. Further, a dependency that contains a
version specification is not satisfied by a package that Provides that
needed package name. As a result, having many variants provide a common surrogate package may be harmful, because it precludes the use of versioned dependencies. For example, if foo-gnome and foo-nognome both have "Provides: foo", another package with "Depends: foo (> 1.1)" will not work.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>Conflicts</itemt>
<itemd>
<p>
一个逗号分隔的软件包名清单，这些软件包不应该和本软件安装在同一台机器上。
对于虚拟软件包，可以把它们代表的软件包的名字列在这里，它们会被自动正确处理。这个也支持和 Depend 字段类似的版本相关的依赖关系，但没有替换选择(这也不符合逻辑)。如果一个软件被列为它自己的 Conflicts 字段中，它将被从中清除(不会有特别的提示)，这个功能在 fink 的 0.18.2 后 CVS 版本中提供。
</p>
<p>
<em>注意：</em>Fink 自己本身会忽略这个字段。不过，它会被传递给 dpkg 并做相应的处理。概括来说，它仅影响运行时，而不应该构建时。
</p>
</itemd></item>

<!-- start translation -->
<item><itemt>BuildConflicts</itemt>
<itemd>
<p>
A list of packages that must not be installed while this package is
being compiled. This can be used to prevent <code>./configure</code>
or the compiler from seeing undesired library headers or to avoid use
of a version of a tool that is known to be broken (for example, a bug
in a certain version of sed).  If a build is being done
with test suites enabled, the packages in the <code>TestConflicts</code>
field will be added to this list.
</p>
</itemd></item>
<!-- end translation -->

<item><itemt>Replaces</itemt>
<itemd>
<p>
这和 &quot;Conflicts&quot; 同时使用，当软件包不仅仅替代冲突的软件包的功能，还会有一些共同的文件的时候。
没有这个字段的话，dpkg 会按安装的时候报错，因为这些文件还由别的软件包所拥有。
它也可以作为一个提示说，这两个软件是真正的完全替代的，一个可以完全替代另外一个。如果一个软件列为它自己的 Replaces，它会被自动(没有提示)地从中清除(从 fink 的 0.18.2 后 CVS 版本开始提供)。
</p>
<p>
<em>注意：</em>Fink 自己本身会忽略这个字段。不过，它会被传递给 dpkg 并做相应的处理。概括来说，它仅影响运行时，而不应该构建时。
</p>
</itemd></item>

<item><itemt>Recommends, Suggests, Enhances</itemt>
<itemd>
<p>
这些字段以其它依赖关系的风格，指明一些额外的软件包关系。这三个关系不会影响通过<code>dpkg</code> 或 <code>apt-get</code> 的实际安装过程。
它们由 <code>dselect</code> 或其它前端程序来帮助用户作出合理的选择。
</p>
</itemd></item>

<item><itemt>Pre-Depends</itemt>
<itemd>
<p>
对 Depends 字段进行更强的要求的特殊变量。
本字段只有在开发者邮件列表中经过讨论，并被大部分人同意需要这样做以后才可以使用。
</p>
</itemd></item>

<item><itemt>Essential</itemt>
<itemd>
<p>
一个表明是关键软件包的布尔值。
所有的非关键软件包都隐含地依赖于关键软件包。
<code>dpkg</code> 会拒绝从系统中删除关键软件包，除非设置了特别的标识来覆盖它。
<!-- start translation -->
In the past, non-essential packages implicitly depended on the
essential ones; this is no longer true.
<!-- end translation -->
</p>
</itemd></item>

<item><itemt>BuildDependsOnly</itemt>
<itemd>
<p>
<em>从 fink 0.9.9 开始。</em>
一个布尔值，它表明没有其它软件包会依赖于它，它们应该只是 BuildDepend。
<!-- start translation -->
Unlike usual boolean fields, <code>BuildDependsOnly</code> is
tri-state: leaving it undefined (not specifying it at all) is
different than defining it as logically false. See the <xref
chapter="policy" section="sharedlibs">Shared Library Policy</xref> for
more information.
</p>
<p>As of fink 0.20.5, the presence or absence of this field, and its value
if present, are recorded into the .deb
file when the package is built.  Therefore, <em>if you change the value of
BuildDependsOnly or if you add or remove it,
you must increase the revision number</em> of the package.
</p>
<!-- end translation -->
</itemd></item>

</itemtable>
<p><em>解压阶段：</em></p>
<itemtable>

<item><itemt>CustomMirror</itemt>
<itemd>
<p>
镜像站点的列表。每个镜像站点占一行，格式如下：<code>&lt;location&gt;: &lt;url&gt;</code>。
<em>location</em> 可以是洲代号(例如 <code>nam</code>)，也可以是国家代号(比如 <code>nam-us</code>)，或者其它的东西；镜像站点会按照它的顺序来进行尝试。
例如：
</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&gt;&gt;</codeblock>
<!-- start translation -->
<p>
  The standard continent and country codes are listed in
  <filename>/sw/lib/fink/mirror/_keys</filename>, which is part of the
  fink or fink-mirrors package.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>Source</itemt>
<itemd>
<p>
源代码压缩档的 URL。它应该是一个 HTTP 或 FTP URL，但 Fink 本身并不关心这一点-它只是把它传递给 wget。这个字段对镜像站点的 URL 标记模式：
<code>mirror:&lt;mirror-name&gt;:&lt;relative-path&gt;</code>。
这会在 Fink 的配置中寻找 <em>mirror-name</em> 镜像的设置，然后添加  <em>relative-path</em> 部分，并把结果作为实际的 URL。已知的 <em>mirror-name</em> 被列在 <filename>/sw/lib/fink/mirror/_list</filename> 中。它是 fink 或 fink-mirror 软件包的一部分。另一方面，使用 <code>custom</code> 作为 <em>mirror-name</em> 会使 Fink 使用 <code>CustomMirror</code>
字段。
在 URL 使用前，会进行百分号展开。
记住 %n 包括所有 %type_ 变种数据，所以你可能会希望在这里使用 %{ni}(也许还包括一些特定的 %type_ 展开)。
</p>
<p>
从 0.18.0 开始，<code>Source: none</code> 具有特别的含义。它标识不需要下载源文件。参考
<code>Type</code> 字段的描述获取更多信息。
<code>gnu</code> 这个值代表
<code>mirror:gnu:%n/%n-%v.tar.gz</code>；<code>gnome</code> 则代表
<code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code>。默认值是 <code>%n-%v.tar.gz</code> (即一个手工指定的下载)。
<!-- start translation -->
This implicitly-defined <code>Source</code> form is deprecated
(explicitly-stated simple filename/manual download is still okay).
</p><p>
Sources that are only needed in order to run test suites should
use <code>TestSource</code> and related fields, inside the
<code>InfoTest</code> block.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>Source<em>N</em></itemt>
<itemd>
<p>
如果一个软件包包含几个压缩档，在这些额外的字段中说明它们呢，从 N = 2 开始。所以，第一个压缩档(它应该是所谓的&quot;主&quot;压缩档)会被放在 <code>Source</code>，第二个压缩档则作为 <code>Source2</code>，依此类推。这里的规则和 Source 是一样的，区别只是 &quot;gnu&quot; 和 &quot;gnome&quot; 捷径不会被展开-那样做并没有意义。从 fink 的 0.19.2 后的一个 CVS 版本开始，你可以使用任意(不需要连续)的 N &gt;= 2 的整数值。不过，你仍然要保证它们是不重复的。
</p>
</itemd></item>

<item><itemt>SourceDirectory</itemt>
<itemd>
<p>
在压缩档被解压到一个目录里面的时候必须使用，但目录名会和压缩档的基本部分不同。
通常，一个名为 &quot;foo-1.0.tar.gz&quot; 会产生一个名为 &quot;foo-1.0&quot; 的目录。如果它产生不同名字的目录，用这个参数指明它。对这个字段会应用百分号展开。
</p>
</itemd></item>

<item><itemt>NoSourceDirectory</itemt>
<itemd>
<p>
把这个布尔值参数设为真的话，压缩档不会展开到一个单独的目录中。
通常，一个名为 &quot;foo-1.0.tar.gz&quot;
会产生一个名为 &quot;foo-1.0&quot; 的目录。如果它只是把文件解压到当前目录，使用这个参数并把它设为真。
</p>
</itemd></item>

<item><itemt>Source<em>N</em>ExtractDir</itemt>
<itemd>
<p>
通常，一个辅助压缩档会被解压到主压缩档相同的目录中。如果你需要把它解压到一个特别的子目录中，使用这个字段来指明它。
正如一般人想象的一样，Source2ExtractDir 对应于 Source2 压缩档。查阅 ghostscript，vim 和 tetex 作为使用的例子。
</p>
</itemd></item>

<item><itemt>SourceRename</itemt>
<itemd>
<p>
这个字段可以在下载过程中改变源程序压缩档的名字。它经常用于在服务器上用目录来区别不同的版本，但压缩档的名字却都是相同的场合。例如：
<filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename>。要解决这个问题，你可以使用：
</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
<p>
对于上面的例子，这会使得下载的源代码压缩档保存在
<filename>/sw/src/coolapp-1.2.3.tar.gz</filename>，以满足我们的一般命名约定。
</p>
</itemd></item>

<item><itemt>Source<em>N</em>Rename</itemt>
<itemd>
<p>
这和 <code>SourceRename</code> 字段是一模一样的，除了它是用来重命名与 <code>Source<em>N</em></code> 字段对应的压缩档外。参考其它有关的部分来了解使用的例子。
</p>
</itemd></item>

<item><itemt>Source-MD5</itemt>
<itemd>
<p>
<em>从 fink 0.10.0 开始。</em>
在这个字段中，你可以指定源程序文件的 MD5 校验值。
这个信息会被 Fink 用来检测是否使用了错误的源文件版本，也就是说，
那些和维护者所使用的版本不同的软件包。通常引起这个问题的原因是：未完全下载的压缩档；上游维护者在未通知的情况下修改了源代码；木马或类似的攻击；等等。
</p>
<p>
典型的使用例子是：
</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
<p>
要计算校验值，可以使用 <code>md5sum</code> 工具。如果你希望检查压缩档 <filename>/sw/src/apache_1.3.23.tar.gz</filename> 的校验值，
你可以运行下面的命令(下面还包括命令的输出结果)：
</p>
<codeblock>fingolfin% md5sum /sw/src/apache_1.3.23.tar.gz 
4499443fa1d604243467afe64522abac  /sw/src/apache_1.3.23.tar.gz</codeblock>
<p>
正如你所看见的一样，靠左边的数值就是你需要的结果。
</p>
</itemd></item>

<item><itemt>Source<em>N</em>-MD5</itemt>
<itemd>
<p>
<em>从 fink 0.10.0 开始。</em>
这个字段和 <code>Source-MD5</code> 字段完全一样，除了它是指定与 <code>Source<em>N</em></code> 字段对应的压缩档的 MD5 校验值。
</p>
</itemd></item>

<item><itemt>TarFilesRename</itemt>
<itemd>
<p>
<em>从 fink 0.10.0 开始。</em>
这个字段只对那些使用 tar 格式的源程序文件有效。
</p>
<p>
通过这个字段，你可以在解压压缩档的时候，重命名给定的源程序压缩档里面的文件。这是针对 HFS+ 文件系统大小写不敏感的特性的一个解决办法。比方说在标准的 Mac OS X 环境下 <filename>install</filename> 和 <filename>INSTALL</filename> 这两个文件会发生冲突。通过这个字段，你可以不需要重新建立一个新的压缩档(过去需要这样做)就可以避免这个问题。
</p>
<p>
这个字段中，你只需要简单第列出需要重命名的文件。你可以使用通配符。
默认情况下，这些文件名后面会被加上 <code>_tmp</code>。你可以通过使用在 <code>Files</code> 和 <code>DocFiles</code>
字段中的相同语法来修改这个默认行为，就是在原来的文件名后面加上一个冒号，然后再加上新的文件名。
例如：
</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: directory/INSTALL:directory/INSTALL.txt</codeblock>
</itemd></item>

<item><itemt>Tar<em>N</em>FilesRename</itemt>
<itemd>
<p>
<em>从 fink 0.10.0 开始。</em>
这和 <code>TarFilesRename</code> 字段一致，除了它作用于与 <code>Source<em>N</em></code> 字段对应的压缩档以外。
</p>
</itemd></item>

</itemtable>

<!-- Patch Phase -->
<p><em>补丁阶段：</em></p>
<itemtable>

<item><itemt>UpdateConfigGuess</itemt>
<itemd>
<p>
一个布尔值。如果为真的话，构建目录中的 config.guess 和 config.sub
会被替换为了解 Darwin 的版本。这发生在补丁阶段，并在 PatchScript
运行之前。<em>仅仅</em> 在你确定必须这么做的时候才使用它，即，当配置脚本以 &quot;unknown host&quot; 而失败的时候。
</p>
</itemd></item>

<item><itemt>UpdateConfigGuessInDirs</itemt>
<itemd>
<p>
<em>从 0.9.0 后 CVS 版本开始。</em>
这是一些子目录的清单。
这和 UpdateConfigGuess 完成相同的工作，但只对那些在几个子目录里面的  config.guess 文件是过期的情况下使用。
以前，你需要在 PatchScript 中手工拷贝/移动那里面的文件。
而有了这个新的字段以后，你可以仅仅是列出目录。
使用 <code>.</code> 来更新处于构建目录本身的文件。
</p>
</itemd></item>

<item><itemt>UpdateLibtool</itemt>
<itemd>
<p>
这是一个布尔值。如果为真的话，那么构建目录里面的 ltconfig 和 ltmain.sh 文件会被替换为与 Darwin 兼容的版本。
这发生在补丁阶段，在 PatchScript 脚本运行之前。
<em>仅仅</em>在你肯定需要软件包需要它的时候才这样做。
有些软件包会因为替换不正确版本的 libtool 脚本而被破坏。
查看<link
url="http://fink.sourceforge.net/doc/porting/libtool.php">libtool
网页</link>获取更进一步的信息。
</p>
</itemd></item>

<item><itemt>UpdateLibtoolInDirs</itemt>
<itemd>
<p>
<em>从 0.9.0 后 CVS 版本开始。</em>
一个子目录的清单。
它和 UpdateLibtool 的作用一样，但只对那些源代码中几个目录中有过期的 libtool 1.3.x 脚本的软件包有用。
以前你需要在 PatchScript 脚本中手工拷贝/移动这些文件。
有了这个新的字段以后，你只需要指定这些目录。
使用 <code>.</code> 来更新在构建目录本身里面的文件。
</p>
</itemd></item>

<item><itemt>UpdatePoMakefile</itemt>
<itemd>
<p>
一个布尔值。
为真的话，在 <filename>po</filename> 目录中的 <filename>Makefile.in.in</filename> 文件会被替换为打过补丁的版本。
这发生在补丁阶段，并在 PatchScript 脚本运行之前。
</p>
<p>
打过补丁的版本可以识别 DESTDIR 并确保信息目录是在 <filename>/sw/share/locale</filename>，而不是 <filename>/sw/lib/locale</filename>。
在使用这个字段之前，确定你不会破坏软件包以及的确有这个必要。
你可以运行 <code>diff</code> 命令来找出软件包的版本和 Fink 的版本的区别(在
<filename>/sw/lib/fink/update</filename>)。
</p>
</itemd></item>

<item><itemt>Patch</itemt>
<itemd>
<!-- start translation -->
<p>
应用于 <code>patch -p1
&lt;<em>patch-file</em></code> 命令的补丁文件的名字。这应该只是一个文件名；正确的路径会被自动添加(the same directory where the <code>.info</code> file
 is located)。 在本字段中会应用百分号展开。所以典型的设置值只是
<code>%f.patch</code> 或 <code>%n.patch</code>。补丁会在 PatchScript 脚本运行之前 in a separate step 应用(如果有的话)。
</p>
<!-- end translation -->
<p>
记住 %n 包括所有 %type_ 变种数据，所以你可能需要在这里使用 %{ni} (也许需要包括一些特定的 %type_ 展开)。
维护一个单独的补丁文件，然后在 <code>PatchScript</code> 字段中列出与变种有关的修改会比对每个变种使用单独的补丁文件容易些。
</p>
</itemd></item>

<item><itemt>PatchFile</itemt>
<itemd>
<p>
The same syntax as the <code>Patch</code> field. The full path to this
file is available using the <code>%{PatchFile}</code> percent
expansion--do not use <code>%a</code> to access this file.
Unlike <code>Patch</code>, <code>PatchFile</code> is applied as part
of <code>PatchScript</code>. Fink checks that the listed file exists,
is readable, and that its checksum matches
the <code>PatchFile-MD5</code> field.
</p>
<p>
You may not use both <code>Patch</code> and <code>PatchFile</code> in
the same package description. Any package that
uses <code>PatchFile</code> must declare at least
<code>BuildDepends: fink (>= 0.24.12)</code>. Giving a higher version
requirement is allowed if it is necessary for other reasons.
</p>
</itemd></item>

<item><itemt>PatchFile-MD5</itemt>
<itemd>
<p>
The MD5 checksum of the file given in the <code>PatchFile</code>
field. This field is required if <code>PatchFile</code> is used.
(Introduced in fink-0.24.12)
</p>
</itemd></item>

<item><itemt>PatchScript</itemt>
<itemd>
<p>
在补丁阶段运行的一系列命令。这是对软件包打补丁或修改软件包的地方。
参阅下面关于<xref chapter="reference" section="scripts">脚本的注意事项</xref>。
在命令运行之前，会进行<xref chapter="format" section="percent">百分号展开</xref>。
If a <code>PatchFile</code> field exists, the
default <code>PatchScript</code> is:
</p>
<codeblock>
patch -p1 &lt; %{PatchFile}
</codeblock>
<p>
If there is no <code>PatchFile</code>, the default is blank. If you
have an explicit <code>PatchScript</code>, you must apply
the <code>PatchFile</code> explicitly.
</p>
</itemd></item>

</itemtable>
<p><em>编译阶段：</em></p>
<itemtable>

<!-- start translation -->
<item><itemt>Set<em>ENVVAR</em></itemt>
<itemd>
<p>
在编译和安装阶段设置一些环境变量。这可以用于传递一些编译器标志等信息到  configure 脚本和 Makefile 文件。目前支持的变量包括：
CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, DYLD_LIBRARY_PATH, JAVA_HOME,
LD_PREBIND, LD_PREBIND_ALLOW_OVERLAP, LD_FORCE_NO_PREBIND, LD_SEG_ADDR_TABLE,
LD, LDFLAGS, LIBRARY_PATH, LIBS, MACOSX_DEPLOYMENT_TARGET, MAKE, 
MFLAGS, MAKEFLAGS。
你指定的值也会应用前面说过百分号展开。一个常见的例子是：
</p>
<codeblock>SetCPPFLAGS: -no-cpp-precomp</codeblock>
<p>
Some environment variables have default preset values.
If you specify a value for one of these, it will be
prepended to the default value.
The preset variables (and their default values) are:
</p>
<codeblock>
CPPFLAGS: -I%p/include
LDFLAGS: -L%p/lib
</codeblock>
<p> Starting in fink 0.26.0, there is one exception to these defaults:
if <code>Type: -64bit</code> is set to <code>-64bit</code>, then the
default value of <code>LDFLAGS</code> is <code>-L%p/%lib -L%p/lib</code> 
instead.</p>
<p>
In addition, starting in fink 0.17.0, the following values are set for
the 10.4-transitional distribution and earlier (but are not set for
the 10.4 distribution and later):
</p>
<codeblock>
LD_PREBIND: 1
LD_PREBIND_ALLOW_OVERLAP: 1
LD_SEG_ADDR_TABLE: $basepath/var/lib/fink/prebound/seg_addr_table
</codeblock>
<p>
Finally, MACOSX_DEPLOYMENT_TARGET is set to a default value depending
on which version of OSX is being run, but setting a value for it for 
a package will override (rather than prepend to) the default value.
</p>
</itemd></item>
<!-- end translation -->

<!-- start translation -->
<item><itemt>NoSet<em>ENVVAR</em></itemt>
<itemd>
<p>
When set to a true value, deactivates the default values for the preset
variables (such as
CPPFLAGS, LDFLAGS, CXXFLAGS  mentioned above). For 
example, if you want LDFLAGS to
remain unset, specify <code>NoSetLDFLAGS: true</code> .
</p>
</itemd></item>
<!-- end translation -->

<item><itemt>ConfigureParams</itemt>
<itemd>
<p>
传递给 configure 脚本的额外参数(查阅
CompileScript 字段的说明获取详细信息)。
<!-- start translation -->
For packages not of <code>Type: Perl</code>, the parameter
<code>--prefix=%p</code> is prepended to this value.
As of fink > 0.13.7, this field will also work with perl modules
<code>Type: Perl</code>; the default perl Makefile.PL
string is prepended to the value supplied for <code>ConfigureParams</code>.
</p>
<p>
If a build is being done
with test suites enabled, the value of the <code>TestConfigureParams</code>
field will be appended to the normal <code>ConfigureParams</code> value.
</p>
<p>
  Starting in fink-0.22.0, this field supports conditionals. The
  syntax is the same as that used in the <code>Depends</code> and
  other package-list fields. The conditional expression only applies
  to the whitespace-delimited &quot;word&quot; immediately following
  it. For example
</p>
<codeblock>
Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) --with-x11 --disable-shared
</codeblock>
<p>
  will always pass the <code>--mandir</code> and <code>--disable-shared</code> flags, but only pass <code>--with-x11</code> in the -x11 variant.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>GCC</itemt>
<itemd>
<!-- start translation -->
<p>
This field specifies the GCC-ABI used by C++ code in this package.
(It is needed because that ABI has changed twice, and any libraries
which you link to containing C++ code must be compiled with the same ABI
you are currently using.)
</p><p>
The allowed values are:
<code>2.95.2</code> (or <code>2.95</code>),
 <code>3.1</code>,
 <code>3.3</code>,
and <code>4.0</code>.
Our understanding is that the GCC authors intend to stabilize the GCC-ABI
at some point; we can hope that it won't change again.
</p><p>
The GCC field does not have a default value, per se, since it is ignored
if it is not set.  However, for each tree, there is an expected value
for GCC corresponding to the default g++ compiler for that tree.
The expected values for the various package trees are:
<code>2.95</code> in the 10.1 tree, <code>3.1</code> in the 10.2 tree,
 <code>3.3</code> in the 10.2-gcc3.3, 10.3, and 10.4-transitional
trees, and <code>4.0</code> in the (upcoming) 10.4 tree.
</p><p>
Note that when the GCC value is different from the expected value, the compiler
must be specified within the package (typically by setting the CC or CXX
flags), and a dependency on one of the (virtual) gcc packages should be
specified.
</p>
<p>对于 fink 0.13.8，如果使用了这个标志，会使用 <code>gcc_select</code> 来检测 gcc 的版本，如果检测到错误的版本，fink 会出错退出。
</p>
<p>
This field was added to fink to aid maintainers
in tracking the transition between the gcc
compilers, which introduced a binary incompatibility between libraries
that involve C++ code which is not reflected in the versioning
scheme.
</p>
<!-- end translation -->
</itemd></item>

<item><itemt>CompileScript</itemt>
<itemd>
<p>
在编译阶段运行的一系列命令。这里是放置配置和编译软件包的命令的地方。
参阅下面关于<xref chapter="reference" section="scripts">脚本的注意事项</xref>。
在命令运行之前，会进行<xref chapter="format" section="percent">百分号展开</xref>。
通常默认值是：
</p>
<codeblock>./configure %c
make</codeblock>
<p>
这对于使用 GNU autoconf 的软件包是恰当的。
对于那些是 perl (通过 Type 字段指定)类型，但却没有指明 perl 版本的软件包，默认的替代值是：
</p>
<codeblock>perl Makefile.PL PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5 \
 INSTALLARCHLIB=%p/lib/perl5/darwin \
 INSTALLSITELIB=%p/lib/perl5 \
 INSTALLSITEARCH=%p/lib/perl5/darwin \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>如果是指定版本的 <code>perl $version</code> 类型(比如 <code>$version</code> 可能是 5.6.0)，
默认值是：
</p>
<codeblock>perl$version Makefile.PL \
 PERL=perl$version PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5/$version \
 INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%p/lib/perl5/$version \
 INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<!-- start translation -->
<p>where <code>$perlarchdir</code> is "darwin" for versions 5.8.0 and 
earlier, and is 
"darwin-thread-multi-2level" for versions 5.8.1 and later.</p>
</itemd></item>

<item><itemt>NoPerlTests</itemt>
<itemd> 
<p>
<em>从 fink 0.13.7 之后开始。</em>
一个针对 perl 模块软件包的布尔值。如果为真的话，<code>CompileScript</code> 的 <code>make test</code> 部分会对那些指定的 perl 模块忽略。
</p>
</itemd></item>

</itemtable>
<p><em>Test Suites:</em></p>
<itemtable>

<item><itemt>InfoTest</itemt>
<itemd>
<p>
<em>Introduced in fink 0.25.</em>
This field encapsulates information that will only be used when performing
a build with test suites enabled.  It contains other fields.
If present, this field <em>must</em> contain a <code>TestScript</code>.
All other fields are optional.  The following fields are allowed inside
<code>InfoTest</code>:
</p><ul>
<li><code>TestScript</code>: A script which runs the test suite.  This script should exit
    with status 0 if the suite passes, 1 to indicate warnings, or any other
    value to indicate failures serious enough to be considered fatal.
    Because of this tri-state logic, you should explicitly set an exit value in
    this script.  For instance, <code>make check</code> is a bad script,
    since it will exit with status 1 if the check target doesn't exist.
    <code>make check || exit 2</code> would be a better script.</li>
<li><code>TestConfigureParams</code>: A value which will be appended to <code>ConfigureParams</code>.</li>
<li><code>TestDepends</code> and <code>TestConflicts</code>: Lists of packages that will be added to the <code>BuildDepends</code> or <code>BuildConflicts</code> lists.</li>
<li><code>TestSource</code>: Extra sources necessary to run the test suite.  All of the
    affiliated fields are also supported, so you <em>must</em> also specify
    <code>TestSource-MD5</code>, and you may also have
    <code>TestSourceN</code> and corresponding <code>TestSourceN-MD5</code>,
    <code>TestTarFilesRename</code>, etc.</li>
<li><code>TestSuiteSize</code>: Describes approximately how long the test suite takes to
    run.  Valid values are <code>small</code>, <code>medium</code>, and <code>large</code>.
    This field is currently ignored.</li>
<li>Any other standard field.  If a field is specified both inside and outside
<code>InfoTest</code>, the value inside <code>InfoTest</code> will replace
the other value when test suites are active.</li>
</ul><p>Here's an example:
</p><codeblock>InfoTest: &lt;&lt;
    TestScript: make check || exit 2
    TestConfigureParams: --enable-tests
&lt;&lt;</codeblock>
</itemd></item>
</itemtable>
<!-- end translation -->

<p><em>安装阶段：</em></p>
<itemtable>

<item><itemt>UpdatePOD</itemt>
<itemd>
<p>
<em>从 fink 0.9.5 开始。</em>
一个针对 perl 模块软件包的布尔值。
为真的话，它会添加代码到 install，postrm 和 postinst
脚本来维护 perl 软件包所提供的 .pod 文件。
这包括在中央的<filename>/sw/lib/perl5/darwin/perllocal.pod</filename>文件中添加和删除 .pod 数据。
(如果类型是以 <code>perl $version</code> 这样包括特定版本的形式给出，例如 5.6.0，那么这些脚本会被用于处理在
<filename>/sw/lib/perl5/$version/perllocal.pod</filename> 的中央 .pod 文件。)
</p>
</itemd></item>

<item><itemt>InstallScript</itemt>
<itemd>
<p>
一系列在安装阶段运行的命令。
这是把软件包的需要文件拷贝到正确的地方的指令。
参阅下面关于<xref chapter="reference" section="scripts">脚本的注意事项</xref>。
在命令运行之前，会进行<xref chapter="format" section="percent">百分号展开</xref>。
通常的默认值是：
</p>
<codeblock>make install prefix=%i</codeblock>
<p>
这么默认值对使用 GNU autoconf 的软件包是合适的。
对于那些 perl (通过 Type 字段指明) 模块类型的软件包，
如果没有指定 perl 版本的话，
默认的值为：
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
 INSTALLARCHLIB=%i/lib/perl5/darwin \
 INSTALLSITELIB=%i/lib/perl5 \
 INSTALLSITEARCH=%i/lib/perl5/darwin \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3</codeblock>
<p>如果类型是指定版本 <code>perl $version</code> (比如 $version 为 5.6.0)的 perl 模块，
默认值为：
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
 INSTALLARCHLIB=%i/lib/perl5/$version/darwin \
 INSTALLSITELIB=%i/lib/perl5/$version \
 INSTALLSITEARCH=%i/lib/perl5/$version/darwin \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3</codeblock>
<p>
如果软件包支持的话，首选会使用 <code>make install
DESTDIR=%d</code>。
</p>
</itemd></item>

<item><itemt>AppBundles</itemt>
<itemd>
<!-- start translation -->
<p>
<em>Introduced in a post-0.23.1 version.</em>
This field installs the specified application bundle(s) into
<filename>%p/Applications</filename>.  It will also create a
symlink to the <filename>/Applications/Fink</filename> directory.
Example:
</p>
<!-- end translation -->
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
</itemd></item>

<item><itemt>JarFiles</itemt>
<itemd>
<p>
<em>从 fink 0.10.0 开始。</em>
这个字段和 DocFiles 有些类似。它安装指定的 jar
文件到 <filename>%p/share/java/%n</filename> 目录中。
例如：
</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
<p>
这将安装全部原来在 lib 目录中 jar 文件，同时会把
foo.jar 安装为 fooBar.jar。
</p>
<p>
它同时确保这些 jar 文件(尤其是：所有在 <filename>%p/share/java/%n</filename> 目录中以 .jar 结尾的文件)
被添加到 CLASSPATH 环境变量中。
这使得象
configure 或 ant 之类的工具能够正确地检测到已安装的 jar 文件。
</p>
</itemd></item>

<item><itemt>DocFiles</itemt>
<itemd>
<p>
这个字段提供一个安装软件包中 doc 目录中<filename>%p/share/doc/%n</filename> README 或 COPYING
文件的方便方法。
它的值是一些以空格分开的文件清单。
你可以从构建目录的子目录拷贝文件，但最后它们应该拷贝到 doc 目录本身，而不是它的子目录。
可以使用 Shell 通配符。
也可以在拷贝的同时重命名某个文件，这可以在一个冒号后面添加新的文件名来实现，
比如 <code>libgimp/COPYING:COPYING.libgimp</code>。
这个字段的功能是通过在 InstallScript 中添加合适的 <code>install</code> 命令。
</p>
</itemd></item>

<item><itemt>Shlibs</itemt>
<itemd>
<p>
<em>从 fink 0.11.0 开始。</em>
这个字段声明软件包中要安装的共享库。
每个共享库占一行，每行包括以空格分开的三或四项：
共享库的 <code>-install_name</code>(安装名)，
<code>-compatibility_version</code>(兼容版本号)，
和版本相关的指明提供这个兼容版本的 Fink 软件包的依赖信息，
<!-- start translation -->
the library architecture.  (The library architecture may either be "32", "64", or
"32-64", and may be absent; the value defaults to "32" if it is absent.)  
<!-- end translation -->
依赖信息应该以下面的形式描述：<code> foo (&gt;= version-revision)</code> 其中 
<code>version-revision</code> 指提供(这个兼容版本)函数库的 Fink 软件包的 <em>第一个</em>版本。
Shlibs 声明表明维护者承诺这个名字和至少
<code>-compatibility_version</code>的兼容版本号的函数库会在这个 Fink 软件包的新版本中找到。
</p></itemd></item>

<item><itemt>RuntimeVars</itemt>
<itemd>
<p>
<em>从 fink 0.10.0 开始。</em>
这个字段提供设置运行时环境变量为一些静态值的简便方法(如果你需要更灵活的方式，参考 <xref section="profile.d">profile.d 脚本部分</xref>)。在你的软件包安装以后，这些变量会通过 <filename>/sw/bin/init.[c]sh</filename> 脚本设置。
</p>
<p>
你的环境的值可以包括空格(尾部的连续空格会被截断)；另外，百分号展开也会进行。例如：
</p>
<codeblock>RuntimeVars: &lt;&lt;
 SomeVar: %p/Value
 AnotherVar: foo bar
&lt;&lt;</codeblock>
<p>
会设置两个环境变量 &quot;SomeVar&quot; 和 &quot;AnotherVar&quot;，它们的值相应地被设置为 &quot;/sw/Value&quot; (或你选择的前缀)以及 &quot;foo bar&quot;。
</p>
<p>
这个字段通过添加合适的命令到 InstallScript 来实现。
这些命令为每个变量添加一行 setenv/export 到软件包的 profile.d 脚本，所以你也提供你自己，它们不会被覆盖。这些行被作为脚本考虑，你可以在你的脚本中使用这些变量。
</p>
</itemd></item>

<item><itemt>SplitOff</itemt>
<itemd>
<p>
<em>从 fink 0.9.9 开始。</em>
在同一个编译/安装过程中产生第二个软件包。
有关详细信息，查看下面单独的
<link url="#splitoffs">剥离(splitoff)部分</link>。
</p>
</itemd></item>

<item><itemt>SplitOff<em>N</em></itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.9.</em>
这和 <code>SplitOff</code> 一样，用于从同一个编译/安装过程产生第三、第四个等等软件包。
从 fink 0.19.2 后的一个 CVS 版本开始，你可以使用 N &gt;=2 的任意整数值。不过，你仍然要保证它们是互不重复的。
</p>
</itemd></item>

<item><itemt>Files</itemt>
<itemd>
<p>
<em>从 fink 0.9.9 开始。</em>
<em>仅</em>
在 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 字段内使用，
它用于指定哪些文件和目录需要从父文件包的安装目录 %I 移动到当前安装目录 %i。 注意这在父文件包的 InstallScript 和 DocFiles 之后，但在当前文件包的 InstallScript 和 Docfiles 之前执行。
</p>
</itemd></item>

</itemtable>
<p><em>构建阶段：</em></p>
<itemtable>

<item><itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
<itemd>
<p>
这些字段指明当软件包安装、升级或删除的时候执行的 shell 脚本。
Fink 会自动添加脚本的头部
<code>#!/bin/sh</code>，并调用 <code>set -e</code>，所以任何失败的命令都会导致脚本的立即终止。
Fink 还会在最后添加一个 <code>exit 0</code>。
要指明错误，从脚本中以一个非零值退出。
第一个参数 (<code>$1</code>) 被设为一个指明应该采用什么操作的值。
一些可能的值包括 <code>install</code>，<code>upgrade</code>，<code>remove</code> 和 <code>purge</code>。
注意还有更多的值，用于错误回退或因为另外一个文件包而删除的情况。
</p>
<p>
脚本会在下面的时候被调用：
</p>
<ul>
<li>PreInstScript: 当软件包第一次安装和升级到这个版本时。</li>
<li>PostInstScript: 解压和设置软件包之后。</li>
<li>PreRmScript: 软件包被删除或升级到新版本之前。</li>
<li>PostRmScript: 软件包被删除或升级到新版本之后。</li>
</ul>
<p>
更清楚地说，升级过程包括：新版本的 Inst scripts，和旧版本的 Rm scripts。
细节可以在 Debian 规则手册找到，
<link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">第六章</link>.
</p>
<p>
脚本中会进行百分号展开。
命令通常会不使用完整路径来调用。
</p>
</itemd></item>

<item><itemt>ConfFiles</itemt>
<itemd>
<p>
以空格分开的用户可以编辑的配置文件的列表。
Percent expansion  is performed on this field.
这些文件必须以绝对路径指明，例如，<filename>%p/etc/%n.conf</filename>。
这些文件会被 dpkg 特别对待。
当软件包被升级，而软件包和磁盘上的文件相比被改动过的话，用户会被询问使用哪个版本，以及是否需要进行备份。
当一个软件包被删除后，配置文件仍然还保留在磁盘上。
只有 &quot;purge&quot; 会删除配置文件。
</p>
</itemd></item>

<item><itemt>InfoDocs</itemt>
<itemd>
<p>
软件包安装在 %p/share/info 目录的信息文件的清单。
这会在 postinst 和 prerm 脚本中添加合适的代码来维护 Info 目录的文件 <code>dir</code>文件。
这个特性仍然在增加过程，将来可能会加入更多的字段以获得更精细的控制。
</p>
</itemd></item>

<item><itemt>DaemonicFile</itemt>
<itemd>
<p>
给出 <code>daemonic</code> 的服务描述。
<code>daemonic</code> 被 Fink 用于创建和删除 daemon 进程的
StartupItems (例如 web 服务器)。
描述会被作为一个名为 <code>%p/etc/daemons/<em>name</em>.xml</code> 的文件添加到软件包中，这里 <em>name</em> 由 DaemonicName 字段指定，默认为软件包名字。
对本字段的内容可以进行百分号展开。
注意如果你的软件包需要使用它的时候，你必须添加 <code>daemonic</code> 到依赖关系清单中。
</p>
</itemd></item>

<item><itemt>DaemonicName</itemt>
<itemd>
<p>
<code>daemonic</code> 服务描述文件的名字。
查看 DaemonicFile 字段的描述获取更多的信息。
</p>
</itemd></item>

</itemtable>
<p><em>额外数据：</em></p>
<itemtable>

<item><itemt>Homepage</itemt>
<itemd>
<p>
软件包上游提供者的首页 URL。
</p>
</itemd></item>


<item><itemt>DescDetail</itemt>
<itemd>
<p>
一个相比 <code>Description</code> 字段更详细的描述(内容包括它是什么，我可以用它来做什么？)。
这里允许使用多行。因为这个字段在显示的时候不会由自动单词绕回，你应该手工插入分行符，使得每行不超过 79 个字符(如果可能的话)。
</p>
</itemd></item>

<item><itemt>DescUsage</itemt>
<itemd>
<p>
这是对如果使用软件有关的信息(我怎么使用它？)。
就好象 &quot;在使用 WindowMaker 运行 wmaker.inst 一次&quot; 这样的信息。可以使用多行。因为这个字段在显示的时候不会由自动单词绕回，你应该手工插入分行符，使得每行不超过 79 个字符(如果可能的话)。
</p>
</itemd></item>

<item><itemt>DescPackaging</itemt>
<itemd>
<p>
关于软件包的注解。类似 &quot;对 Makefile 进行修正已使得正确放置所有的文件&quot; 之类的信息会放在这里。可以使用多行。
</p>
</itemd></item>

<item><itemt>DescPort</itemt>
<itemd>
<p>
这是专门针对移植到 Darwin 的软件包的。
象 &quot;config.guess 和 libtool 脚本已被更新，需要使用 -no-cpp-precomp
&quot; 之类的信息会被放在这里。可以使用多行。
</p>
</itemd></item>

</itemtable>
</section>

<section name="splitoffs"><title>剥离分支(SplitOffs)</title>
<p>从 fink 0.9.9 开始，可以用一个单独的 .info 文件来构建多个软件包。
安装阶段和正常的类似，执行
<code>InstallScript</code> 和 <code>DocFiles</code> 命令。
如果存在 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 字段，会触发额外一个安装目录的创建。
在 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 字段里面，新的安装目录以 %i 代表，
而父文件包的原始安装目录则用 %I 代表。
</p>
<p>
每个 <code>SplitOff</code> 和 <code>SplitOff<em>N</em></code> 字段必须包含它自己的一系列字段。
事实上，它由一个备有包含字段的一个完整的软件包描述组成。下面是在子描述里面可以包含的内容(分类说明)：
</p>
<ul>
<li>初始化数据：只需要指明 <code>Package</code> 字段，其它的内容都可以从父软件包进行继承。你可能需要通过声明 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 内的字段修改 <code>Type</code> 和 <code>License</code> 字段。可以使用百分号扩展，而且通常使用 %N 来引用父软件包的名字会很方便。</li>
<li>依赖关系：所有的依赖关系有关的字段都可以使用。</li>
<li>解压阶段，补丁阶段，编译阶段：这些字段是无关的，会被忽略。</li>
<li>安装阶段，构建阶段：全部的字段都可以使用(除了 SplitOff 不能包括新的 SplitOff 以外)。</li>
<li>额外数据：这会从父软件包继承，但可以通过在 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 中声明这些字段而进行修改。</li>
</ul>
<p>
<!-- end translation -->
Because %n-%v-%r is treated as the unique identifier of a package, you
must not have the same <code>Package</code> (at the
same <code>Version</code> and <code>Revision</code>) listed as
a <code>SplitOff</code> (or <code>SplitOff<em>N</em></code>) of
multiple packages. If you use variants, remember that each variant is
considered an independent package, so the following package layout is
forbidden:
<!-- start translation -->
</p>
<codeblock>
Package: mime-base64-pm%type_pkg[perl]
Type: perl (5.8.1 5.8.6)
SplitOff: %lt;%lt;
  Package: mime-base64-pm-bin
%lt;%lt;
</codeblock>
<p>
在安装阶段，父文件包的 <code>InstallScript</code> 和 
<code>DocFiles</code> 会被首先执行。
然后处理 <code>SplitOff</code> 和 <code>SplitOff<em>N</em></code> 字段。对每个这种字段，<code>Files</code> 命令会导致命令中所列的文件和目录会从父文件包的安装目录 %I 移到当前的安装目录 %i。然后给定 <code>SplitOff</code> 或 <code>SplitOff<em>N</em></code> 软件包的 <code>InstallScript</code>
和 <code>DocFiles</code> 会被执行。
</p>
<p>
目前，<code>SplitOff</code> 会被首先执行(如果存在的话)，然后是按照 N 的顺序执行每个 <code>SplitOff<em>N</em></code>。
不过，在将来这可能会被改变。因此，例如：
</p>
<codeblock>
SplitOff: &lt;&lt;
  Description: Some header files
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: All other header files
  Files: include/*
&lt;&lt;
</codeblock>
<p>
只有 <code>SplitOff</code> 在 <code>SplitOff2</code> 之前处理才是正确的。
比较安全的作法是在每个块中都显式列出每个文件(或使用更明确的文件名描述)。
</p>
<p>
在构建阶段，每个软件包的安装/删除的前/后脚本会通过相应软件包构建阶段的命令来生成。
</p><p>
每个被构建的软件包都要求把授权协议文件存放到 %i/share/doc/%n (当然对于每个软件包 %n 有不同的取值)目录中。
注意
<code>DocFiles</code> 是拷贝文件而不是移动它们，所以可以通过多次使用 <code>DocFiles</code> 命令而把一个相同文档拷贝安装在几个不同的地方。
</p>


</section>

<section name="scripts"><title>脚本</title>

<p>PatchScript，CompileScript 和 InstallScript 字段允许你指定需要执行的 shell 命令。
构建目录(<filename>%b</filename>)是脚本执行的当前目录。
你应该总是使用相对路径名或百分号扩展来引用 fink 目录结构中的文件和目录，而不应该是绝对路径的形式。 
它有两种形式。
</p><p>
这个字段可以是命令的简单罗列。它和一个
shell 脚本类似。不过，命令是通过 system() 调用执行的，每次一行，所以设置环境变量和更改路径只对同一行有效。从 fink 0.18.2 后的 CVS 版本开始，你可以用与普通 shell 脚本类似的方法来绕回太长的行：
在一行末尾的反斜线 (<code>\</code>) 表明下一行是一个续行。
</p><p>
作为替代方案，你可以在这里嵌入一个完整的脚本，使用你选择的解析器。
对于任何 Unix 脚本，第一行必须以 <code>#!</code> 开始，后面紧跟解析器的完整路径名以及需要的标志(例如 <code>#!/bin/csh</code>，<code>#!/bin/bash -ev</code>等等)。在这种情况下，整个
*Script 字段会被写到一个临时文件，然后被执行。
</p>
</section>

<section name="patches"><title>补丁</title>

<p>如果你的软件包需要补丁采可以在 Darwin 上编译(或与 Fink 配合)，
把补丁命名为与软件包描述文件相同的名字，使用 &quot;.patch&quot; 来取代 &quot;.info&quot; 作为扩展名，并把它放在和 .info 文件相同的目录下面。
如果你在文件名中使用完整的软件包名，那么使用下面的任意一种方式(它们是等效的)：</p>
<codeblock>Patch: %f.patch</codeblock>
<codeblock>PatchScript: patch -p1 &lt;%a/%f.patch</codeblock>
<p>如果你使用比较新的简单软件包命名约定，使用 %n
来代替 %f。这两个字段不是互斥的，你可以两个都使用，它们都会被执行。这种情况下，PatchScript 会在后面被执行。
<!-- start translation -->
Alternately, you can use the
newer <code>PatchFile</code> instead of <code>Patch</code> and apply
with an implicit or explicit <code>PatchScript</code>--see the
descriptions of the <code>PatchFile</code>
and <code>PatchScript</code> fields for more information.
<!-- end translation -->
</p>

<p>因为你可能会在补丁文件中允许用户选择安装前缀，建议在补丁文件中使用类似 <code>@PREFIX@</code> 的变量来代替 <code>/sw</code>，然后使用：</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt;%a/%f.patch | patch -p1</codeblock>
<p>补丁文件应该是 unidiff 格式，而且一般应该通过：</p>
<codeblock>diff -urN &lt;originalsourcedir&gt; &lt;patchedsourcedir&gt;</codeblock>
<p>命令产生。</p>
<p>如果你用过 emacs 编辑文件，你可以在上面的 diff 命令中加上 <code>-x'*~'</code> 来派出自动产生的后备文件。</p>
<p>另外需要注意的是非常大的补丁不应该放到 CVS 中。
它们应该被放到一个 web/ftp 服务器，并使用
<code>SourceN:</code> 字段来指明。如果你自己没有网站，fink 项目管理员可以把它放到 fink 自己的网站上。如果你的补丁大于 30Kb，你应该考虑把它作为一个单独的下载。
</p>
</section>

<section name="profile.d"><title>Profile.d 脚本</title>

<p>
如果你的软件包需要一些运行时的初始化(例如，设置环境变量)，你可以使用 profile.d 脚本。
这些脚本片段由 <filename>/sw/bin/init.[c]sh</filename> 脚本所运行。通常，所有 fink 的用户都会把这些脚本放到它们的起动文件(<filename>.cshrc</filename> 或类似的文件)中。
你的软件包必须为两个变种都提供脚本：一个给 sh 兼容的 shells (sh, zsh, bash, ksh, ...) 而另一个给 csh 兼容的 shells (csh, tcsh)。它们应该被安装在 <filename>/sw/etc/profile.d/%n.[c]sh</filename> (和往常一样，%n 代表软件包名)。
另外，它们的可读和可执行属性都应该被设置(即，用 -m 755 参数安装它们)，否则它们不能被正确加载。
</p>
<p>
如果你只需要设置一些环境变量(例如，把 QTDIR 设置为 '/sw')，你可以使用 RuntimeVars 字段来比较方便地实现这个所说的功能。
</p>
</section>


</chapter>


</document>
