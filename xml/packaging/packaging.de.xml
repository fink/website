<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">

<document filename="index" lang="de" >
<title>Ein Fink-Paket erstellen</title>
<shorttitle>Paket erstellen</shorttitle>
<cvsid>$Id: packaging.de.xml,v 1.10 2024/12/20 6:46:11 nieder Exp $</cvsid>

<preface>
<p>
Diese Anleitung beschreibt, wie man eine Paketbeschreibung für den Paketmanager
Fink erstellt.
Es beschreibt ebenso die Richtlinien für die Fink-Distribution.
Sowohl das Format der Paketbeschreibung als auch die Distributionspolitik sind
in Entwicklung. Achten sie also auf "Last changed"-Informationen und CVS Tipps
zu dieser Seite, wenn es um Aktualisierungen geht.
Diese Beschreibung hier bezieht sich auf Formate und Richtlinien für Version
0.9.0 und höher des Paketmanagers <tt>Fink</tt>.
</p>
<p>
Beabsichtigen sie Pakete für Fink zu erstellen, ist es sinnvoll die Mailing-Liste
<link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link>
zu abonnieren.
Wenn sie einfach bei Fink mithelfen wollen und sie sich fit fühlen, können sie
<link url="http://pdb.finkproject.org/pdb/nomaintainer.php">ein Paket aus dieser
Liste übernehmen</link>, das derzeit ohne Betreuer ist.
</p>
</preface>

<chapter filename="intro">
<title>Einführung</title>
<shorttitle>Einführung</shorttitle>

<section name="def1"><title>Was ist ein Paket?</title>
<p>
Ein Paket besteht aus Software, die eine abgeschlossene Einheit bildet. Ein
typisches Paket enthält ein Program, dafür benötigte Dateien und Kataloge mit
Meldungen für die Internationalisierung und Dokumentation. In Fink können Pakete
in zwei Formen vorliegen: Die Paketbeschreibung und die binäre, direkt
installierbare Paket-Datei.
</p>
<p>
Die Paketbeschreibung ist eine lesbare Textdatei, die alles enthält, um das
Paket zu erstellen, d. h. die binäre Paket-Datei zu erzeugen.
Die Paketbeschreibung enthält Meta-Daten (Paketnamen und Beschreibungsprosa),
die URL des Quell-Codes und die Instruktionen für die Konfiguration, das
Compilieren und das "Einpacken" des Pakets. Zu der Paketbeschreibung kann auch
eine Patch-Datei gehören.
</p>
<p>
Die binäre Paket-Datei is ein Dateiarchiv, das die eigentlichen Dateien des
Pakets enthält, also das Binärprogram, Dateien, Kataloge mit Meldungen,
Bibliotheken, Include-Dateien, usw.
Die Paket-Datei enthält auch Meta-Daten über das Paket.
Installation eines binären Pakets bedeutet im wesentlichen Auspacken des
Inhalts, weil alles bereits vorbereitet ist.
Fink nutzt den Paketmanager dpkg. Deshalb haben die binären Paket-Datei das
Format dpkg und den Datei-Suffix .deb.
</p>

</section>

<section name="ident"><title>Identifikation eines Pakets</title>
<p>
Die Identifikation eines Pakets ergibt sich aus drei Zeichnfolgen: Paketname,
Version und Revision.
Alle können Kleinbuchstaben, Zahlen, Bindestriche (nicht in der Revision),
Pluszeichen und Punkte enthalten. Andere Zeichen sind nicht erlaubt.
Insbesondere Großbuchstaben und Unterstriche sind nicht erlaubt.
</p>
<p>
Der Paketname is einfach der Name der Software, z. B. openssh.
Die Version, auch Upstream-Version genannt, ist die Version des ursprünglichen
Software-Pakets.
Buchstaben sind in der Version erlaubt, z. B. 2.9p1.
Sowohl Fink als auch dpkg wissen, wie man diese richtig sortiert.
Die Revision ist ein Zähler, der erhöht wird, wenn sich die Paketbeschreibung
ändert.
Sie beginnt mit 1 und sollte auf 1 zurückgesetzt werden, wenn sich die
Upstream-Version ändert.
Die Revision darf keine Bindestriche enthalten.
Der vollständige Name ergibt sich aus der Verkettung der drei mit Bindestrichen
dazwischen, z. B. openssh-2.9p1-2.
</p>

</section>

</chapter>

<chapter filename="format">
<title>Paketbeschreibungen</title>
<shorttitle>Paketbeschreibungen</shorttitle>

<section name="trees"><title>Verzeichnis-Layout</title>
<p>
Paketbeschreibungen werden aus dem Verzeichnis <code>finkinfo</code> gelesen,
der sich im Verzeichnis <filename>/opt/sw/fink/dists</filename> befindet. Die
Einstellung "Trees" in der Datei <filename>/opt/sw/etc/fink.conf</filename>
bestimmt, welche Verzeichnisse gelesen werden.
Der Name der Paketbeschreibungsdatei besteht aus dem vollständigen Paketnamen
und dem Suffix ".info".
Ab Fink 0.26.0 gibt es mehre Möglichkeiten für den Dateinamen: Empfohlen wird
der kürzeste Name, der konsistent mit anderen Paketen ist, die benötigt werden.
Der Dateiname hat folgende Form: der unveränderliche Paketname, optional die
Architektur, optional die Distribution, optional Version oder Version-Revision,
alle durch Bindestriche getrennt und abgeschlossen mit ".info".
Die Komponenten "Architektur" und "Distribution" sind nur erlaubt, wenn die
entsprechenden Felder auch in der Beschreibung vorkommen und exakt einen Wert
zugewiesen haben.
</p>
<p>
Der Baum der Paketveschreibungen ist in mehreren Ebenen von Verzeichnissen
organisiert. Die Verzeichnisse von oben nach unten:
</p>
<ul>
<li><code>dists</code> ist der Anfang. Das Verzeichnis <code>dists</code>
  wird für die Debian Tools benötigt. In neueren Version von Fink ist dies ein
  Symlink zu einem Verzeichnis mit einem distributionsbezogenem Namen.</li>
<li>Die Distributionen. Es gibt <code>stable</code>, <code>unstable</code> und
  <code>local</code>. Das Verzeichnis <code>local</code> wird vom lokalen
  Administrator/Nutzer verwaltet. Die Verzeichnisse <code>stable</code> und
  <code>unstable</code> gehören Fink.</li>
<li>Der Baum. Der Baum enthält die meisten Pakete. Vor dem 1. Juli 2010 wurde
  cryptographische Software in einem separaten Baum namens <code>crypto</code>
  gehalten. Aber jetzt sind diese Pakete auch im Baum <code>main</code>.</li>
<li><code>finkinfo</code>vs. <code>binary-darwin-powerpc</code>.
  <code>finkinfo</code> enthält die Fink-Paketbeschreibungen und Patch-Dateien,
  während das Verzeichnis <code>binary-darwin-powerpc</code> die binären
  <code>.deb</code> Pakete enthält.</li>
<li>Sections. Das Verzeichnis <code>main</code> ist weiter thematisch
  unterteilt, damit es handhabbar bleibt.</li>
</ul>

</section>

<section name="format"><title>Datei-Format</title>
<p>
Die Paketbeschreibungsdateien sind einfache Listen von Schlüssel-Wert-Paaren,
auch Felder genannt.
Jede Zeile beginnt mit einem Schlüssel, der mit einem Doppelpunkt (:)
abgeschlossen wird. Darauf folgt direkt der Wert, also so:
</p>
<codeblock>Schlüssel: Wert</codeblock>
<p>
Es gibt zwei Schreibweisen für Felder, die sich über mehrere Zeilen
erstrecken.
</p>
<p>
Die bevorzugte Schreibweise is so wie die here-document-Syntax in
Shell-Skripten. Bei dieser Syntax beginnt die erste Zeile mit dem Schlüssel,
gefolgt von <code>&lt;&lt;</code> als Wert.
Alle nachfolgenden Zeilen werden als eigentlicher Wert behandelt bis eine Zeile
folgt, die nur <code>&lt;&lt;</code> enthält.
Das Beispiel von oben sieht nun so aus:
</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
<p>
Einrückungen in diesem Format sind optional, können aber für eine erhöhte
Lesbarkeit verwendet werden.
</p>
<p>
Die here-document-Syntax kann verschachtelt sein. Dies wird oft in den Feldern
<code>SplitOff</code> oder <code>SplitOff<em>N</em></code> verwendet.
Diese Felder enthalten weitere Felder (mehrere Zeilen) und diese Syntax erlaubt,
dass auch diese Unterfelder ihrerseits mehrere Zeilen hat. Derselbe Abschluss
mit <code>&lt;&lt;</code> wird bei dem sub-here-document benutzt.
Hier ein Beispiel:
</p>
<codeblock>SplitOff: &lt;&lt;
  Package: %N-shlibs
  InstallScript: &lt;&lt;
    ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
  &lt;&lt;
&lt;&lt;</codeblock>
<p>
In diesem Format werden Leerzeilen und Zeilen mit einem Hash (#) am Zeilenanfang
ignoriert. Groß-und Kleinschreibung wird beim Schlüssel (Feldnamen) nicht
beachtet, d. h. man kann <code>InstallScript</code>, <code>installscript</code>
oder <code>INSTALLSCRIPT</code>schreiben, wie man will. Allerdings wird die
erste Form mit Großbuchstaben wegen Lesbarkeit empfohlen.
Einige Felder akzeptieren boolesche Werte. Hier werden "true", "yes", "on" und
"1" (auch in Großschreibung) als wahr interpretiert, alle anderen Werte als
falsch.
</p>

</section>

<section name="percent"><title>Prozent-Erweiterungen</title>
<p>
Zur Vereinfachung unterstützt Fink einen Satz an Erweiterungen, die in einigen
Feldern angewendet werden.
Mehrdeutigkeiten kann man verhinder, indem man mit geschweiften Klammern genau
anzeigt, welche Buchstaben für eine Prozent-Erweiterung genommen werden sollen.
<code>%{n}</code> hat zum Beispiel die gleiche Bedeutung wie <code>%n</code>.
Folgende Erweiterungen stehen zur Verfügung:
</p>

<itemtable labeld="" labelt="">

<item><itemt>%n</itemt>
<itemd>
<p>Der <em>n</em>ame des Pakets</p>
</itemd></item>

<item><itemt>%N</itemt>
<itemd>
<p>
Der <em>N</em>ame des Elternpakets (der selbe wie %n außer innerhalb eines
<code>SplitOff</code>)
</p>
<p>
Anmerkung: Wenn ein Eltern-<code>Paket</code>-Feld %type_*[] enthält, dann
<em>werden</em> die Werte der Prozent-Erweiterung in %N in einem
<code>SplitOff</code>-Block mit eingeschlossen. (Schließlich sind sie Teil von
%n bei den Eltern.)
</p>
</itemd></item>

<item><itemt>%e</itemt>
<itemd>
<p>Die <em>e</em>poche des Pakets</p>
</itemd></item>

<item><itemt>%v</itemt>
<itemd>
<p>
Die <em>v</em>ersion des Pakets. Beachten sie, dass die Epoche nicht zu
<code>%v</code> gehört.
</p>
</itemd></item>

<item><itemt>%V</itemt>
<itemd>
<p>
Die vollständige <em>V</em>ersion des Pakets, die automatisch die Epoche
enthält, wenn vorhanden. Beachten sie, dass diese Prozent-Erweiterung nur für
Pakete zur Verfügung steht, deren <code>InfoN</code>-Ebene mindestens 4 ist.
</p>
</itemd></item>

<item><itemt>%r</itemt>
<itemd>
<p>Die <em>r</em>evision des Pakets</p>
</itemd></item>

<item><itemt>%f</itemt>
<itemd>
<p>
Der vollständige (<em>f</em>ull) Paketname (%n-%v-%r). Beachten sie, dass die
Epoche nicht zu <code>%f</code> gehört.
</p>
</itemd></item>

<item><itemt>%p, %P</itemt>
<itemd>
<p>
Der <em>p</em>refix wo Fink installiert ist, also <filename>/opt/sw</filename>.
Sie dürfen nicht annehmen, dass alle Nutzer Fink in <filename>/opt/sw</filename>
installiert haben, nutzen sie immer <code>%p</code> für den korrekten Pfad.
</p>
</itemd></item>

<item><itemt>%d</itemt>
<itemd>
<p>
Im Verzeichnis <em>d</em>estination wird der Baum für ein Paket erstellt, z. B.
in <filename>/opt/sw/src/fink.build/root-gimp-1.2.1-1</filename>. Dieses
temporäre Verzeichnis dient als Wurzelverzeichnis während der Installationsphase
beim Compilieren eines Pakets. Sie sollten nicht annehmen, dass
<filename>root-%f</filename> in <filename>%p/src</filename> ist, denn ein Nutzer
kann dieses Verzeichnis mit dem Feld <code>Buildpath</code> in der Datei
<filename>/opt/sw/etc/fink.conf</filename> ändern.
</p>
</itemd></item>

<item><itemt>%D</itemt>
<itemd>
<p>
Das Verzeichnis <em>D</em>estination für das Elternpaket (das selbe wie %d außer
innerhalb eines <code>SplitOff</code>)
</p>
</itemd></item>

<item><itemt>%i</itemt>
<itemd>
<p>Der vollständige <em>i</em>nstallationsphase-Präfix, äquivalent zu %d%p</p>
</itemd></item>

<item><itemt>%I</itemt>
<itemd>
<p>
Der <em>I</em>nstall-Präfix des Elternpakets, äquivalent zu %D%P (das selbe wie
%i außer innerhalb eines <code>SplitOff</code>)
</p>
</itemd></item>

<item><itemt>%a</itemt>
<itemd>
<p>
Der Pfad, wo sich die P<em>a</em>tches befinden. Ab Fink-0.29.0 sollte diese
Variable nicht mehr benutzt werden. Nutzen sie <code>%{PatchFile}</code>, um auf
die <filename>.patch</filename>-Datei zuzugreifen. Die Unterstützung für
<code>%a</code> wird in der Zukunft entfernt werden.
</p>
</itemd></item>

<item><itemt>%b</itemt>
<itemd>
<p>
Das Verzeichnis <em>b</em>uild, also
<filename>/opt/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>.
Sie sollten nicht annehmen, dass sich <filename>%f</filename> in
<filename>%p/src</filename> befindent, denn ein Nutzer kann dieses Verzeichnis
über das Feld <code>Buildpath</code> in der Datei
<filename>/opt/sw/etc/fink.conf</filename> ändern.
Das innerste Verzeichnis wird nach dem Dateinamen der
<code>Quelle</code> benannt oder dem Wert des Felds <code>SourceDirectory</code>
(falls vorhanden) oder wird nicht verwendet wenn das Feld
<code>NoSourceDirectory</code> auf <code>true</code> gesetzt ist.
</p>
<p>
Anmerkung: Nutzen sie dies nur, wenn es gar nicht anders geht. Das Verzeichnis
build ist das aktuelle Verzeichnis, wenn Skripte ausgeführt werden; sie sollten
in Kommandos relative Pfadnamen verwenden.
</p>
</itemd></item>

<item><itemt>%c</itemt>
<itemd>
<p>
Die <em>c</em>onfigure Parameter: <code>--prefix=%p</code> plus alles, was mit
ConfigureParams angegeben wurde. (Das Verhalten ist anders, wenn das Paket das
Feld <code>Type: perl</code> gesetzt hat. In diesem Fall werden die
Voreinstellungen für das Erstellen von Perl-Paketen anstatt von
<code>--prefix=%p</code> in der Definition von <code>%c</code> verwendet.)
</p>
</itemd></item>

<item><itemt>%m</itemt>
<itemd>
<p>
Die Zeichenfolge für die Architektur der <em>m</em>achine. Dies ist nicht länger
durch den Typ der Maschine bestimmt, sondern eine Wahl des Nutzers bei der
Installation zwischen den Architekturen, die auf der Hardware des Nutzers
laufen können. Mögliche Werte sind 'powerpc' für PowerPC-Macs und 'i386' oder
'x86_64' für Intel-Macs. Die Auswahl 'x86_64' steht auf Intel-Macs nur zur
Verfügung, wenn der Mac 64-bit Bibliotheken und Programme ausführen kann.
(Dieser Werf wurde etwa in Fink-0.12 eingeführt, die aktuellen Beschreibung gilt
für Fink-0.29.5 und später.)
</p>
</itemd></item>

<item><itemt>%%</itemt>
<itemd>
<p>
Das Zeichen Prozent (Ein Zeichen, das nicht erweitert wird, was auch immer
danach folgt). Die Erweiterung erfolgt streng von links nach rechts. Damit hat
%%n nichts mit dem Paketnamen zu tun, sondern bedeutet die Zeichenfolge %n. (In
Fink-0.18.0 eingeführt)
</p>
</itemd></item>

<item><itemt>%type_raw[<em>type</em>], %type_pkg[<em>type</em>],
%type_num[<em>type</em>]</itemt>
<itemd>
<p>
pseudo-hashes, die den Subtyp für den angegebenen <em>type</em> zurückgeben.
Lesen sie die Dokumentation für das Feld <code>Type</code> weiter unten in
diesem Dokument. Die Form _raw ist die exakte Zeichenfolge des Subtyps, während
bei der Form _pkg alle Punkte entfernt wurden (entsprechend Finks Konventionen
für Paketnamen mit Sprachversionen und andere kluge Verwendungen). (Eingeführt
in einer post-0.19.2 CVS-Version von Fink.) Die Form -num wurde in Fink-0.26.0
eingeführt und entfernt alle Zeichen außer Zahlen aus dem Feld <code>Type</code>.
</p>
<p>
Beachten sie, dass <code>(%type_pkg[type])</code> direkt als Bedingung verwendet
werden kann, wenn das Feld <code>Type</code> den <em>type</em> als "Boolean"
deklariert. (Der boolesche Wert ist wahr oder falsch, je nachdem wie der
Subtype ausgerechnet wird.)
</p>
</itemd></item>

<item><itemt>%{ni}, %{Ni}</itemt>
<itemd>
<p>
Der <em>i</em>nvariante Teil des Paket<em>n</em>amens. Sie sind wie %n and %N,
außer dass alle Teile von %type_pkg[] und %type_raw[] gelöscht sind.
(Eingeführt in einer post-0.19.2 CVS-Version von Fink) Sie sollten %{ni} und
%{Ni} verwenden, um Verwechslungen mit den Erweiterungen %n und %N zu verhindern.
</p>
</itemd></item>

<item><itemt>%{default_script}</itemt>
<itemd>
<p>
Nur in den Feldern <code>PatchScript</code>, <code>CompileScript</code> und
<code>InstallScript</code> gültig. Es enthält den voreingestellten Inhalt dieser
Felder. Der Wert hängt oft vom Feld <code>Type</code> ab und ist immer definiert
(Er kann aber leer sein). Wird diese Erweiterung im <code>InstallScript</code>
eines <code>SplitOff</code> (oder <code>SplitOff<em>N</em></code>) verwendet,
gibt sie die Voreinstellung der Eltern zurück, selbst wenn die Voreinstellung
für das <code>InstallScript</code> in einem <code>SplitOff</code>-Paket leer
ist. (Eingeführt in Fink-0.20.6)
</p>
</itemd></item>

<item><itemt>%{PatchFile}</itemt>
<itemd>
<p>
Der vollständige Pfad zu der Datei, die im Feld <code>PatchFile</code> angegeben
ist. (Eingeführt in Fink-0.24.12)
</p>
</itemd></item>

<item><itemt>%{PatchFile<em>N</em>}</itemt>
<itemd>
<p>
Der vollständige Pfad zu der Datei, die im Feld <code>PatchFile<em>N</em></code>
angegeben ist. (Eingeführt in Fink-0.30.0)
</p>
</itemd></item>

<item><itemt>%lib</itemt>
<itemd>
<p>
Ist der <code>Type: -64bit</code> als <code>-64bit</code> definiert, wird dies
unter der PowerPC-Architektur zu <em>lib/ppc64</em> erweitert und zu
<em>lib/x86_64</em> unter der i386-Architektur (Der korrekte Speicherort für
64-bit Bibliotheken auf einem 32-bit System); anderfalls wird es zu <em>lib</em>
erweitert. (Eingeführt in Fink-0.26.0)
</p>
<p>
Beachten sie, dass <code>%lib</code> im Feld <code>ConfigureParams</code>
nicht erlaubt ist, außer wenn die <code>InfoN</code>-Ebene mindestens 4 ist.
</p>
</itemd></item>

</itemtable>

</section>

</chapter>

<chapter filename="policy">
<title>Richtlinien zur Estellung von Paketen</title>
<shorttitle>Richtlinien</shorttitle>

<section name="licenses"><title>Paket-Lizenzen</title>
<p>
Die Pakete in Fink stehen unter sehr verschiedenen Lizenzen.
Die meisten beinhalten Restriktionen im Hinblick auf Weiterverteilung der
kompletten Quellen und vor allem der Binärprogramme.
Einige Pakete können wegen solcher Restriktionen nicht Teil von Finks
Binär-Distribution sein.
Deshalb ist es sehr wichtig, dass man als Betreuer eines Pakets die Lizenzen
seines Pakets sorgfältig prüft.
</p>
<p>
Jedes Paket, das als Binärpaket verteilt werden soll, muss eine Kopie der Lizenz
enthalten.
Die Kopie muss im Verzeichnis doc installiert werden,
also in <filename>%p/share/doc/%n</filename>.
(Im InstallScript muss natürlich %i anstelle von %p verwendet werden.
Das Feld DocFiles erledigt dies automatisch.)
Gibt es keine explizite Lizenz in den originalen Quellen, fügen sie eine
kleine Textdatei bei, in der sie die Situation des pakets beschreiben.
Die meisten Lizenzen verlangen, dass jede Distribution die Lizenz enthält.
Finks Richtlinien ist, dies immer zu tun, auch wenn es nicht explizit verlangt
wird.
</p>
<p>
Für die automatische Verwaltung der binären Distributions ist es erforderlich,
dass jedes Paket, das damit verteilt werden soll, auch das Feld
<code>License</code> gesetzt hat.
Dieses Feld beschreibt die Art der Lizenz und entscheidet darüber, ob ein
Paket in die binäre Distribution aufgenommen wird oder zurück gehalten wird.
Das Feld soll auch nur präsent sein, wenn das binäre Paket auch den eigentlichen
Text der Lizenz enthält, wie oben beschrieben.
</p>
<p>
Das Feld <code>License</code> ist nur brauchbar, wenn einer der folgenden
vordefinierten Werte benutzt wird.
Erstellen sie ein Paket, das nicht in eine dieser Kategorien fällt, dann fragen
sie auf der developer Mailing-Liste um Hilfe.
</p>
<ul>
<li><code>GPL</code> - die GNU General Public Lizenz.
  Diese Lizenz verlangt, dass der Quell-Code am selben Ort wie das Programm
  zur Verfügung steht.</li>
<li><code>LGPL</code> - die GNU Lesser General Public Lizenz.
  Diese Lizenz verlangt, dass der Quell-Code am selben Ort wie das Programm
  zur Verfügung steht.</li>
<li><code>GPL/LGPL</code> - Dies ist ein Spezialfall für Pakete, bei denen ein
  Teil (z. B. das Programm) unter der GPL steht und ein anderer Teil (z. B. die
  Bibliothek) unter der LGPL steht.</li>
<li><code>BSD</code> - für Lizenzen im BSD-Stil.
  Sie umfasst die sogenannte "originale" BSD-Lizenz, die "modifizierte"
  BSD-Lizenz und die MIT-Lizenz. Auch die Apache-Lizenz zählt als BSD-Lizenz.
  Die Distribution der Quellen ist bei diesen Lizenzen optional.</li>
<li><code>Artistic</code> - für die Artistic-Lizenz und davon abgeleitete.</li>
<li><code>Artistic/GPL</code> - Duale Lizenz nach Artistic und GPL.</li>
<li><code>GNU Free Documentation Lizenz</code> und <code>Linux Documentation
  Project</code> - steht die Dokumentation zu einem Paket explizit unter einer
  dieser Lizenzen, dann hängen sie <code>/GFDL</code> oder <code>/LDP</code> an.
  Das ergibt eine der folgenden Kombinationen: "GFDL", "GPL/GFDL", "LGPL/GFDL",
  "GPL/LGPL/GFDL", "LDP" oder "GPL/LGPL/LDP".
</li>
<li><code>DFSG-Approved</code> - für Software, die folgende Richtlinien einhält:
  <link url="http://www.debian.org/social_contract">Debian Social
  Contract</link>.
</li>
<li><code>OSI-Approved</code> - für andere Open-Source-Lizenzen, die von
  folgender Initiative akzeptiert wurde:
  <link url="http://www.opensource.org/">Open Source Initiative</link>
  Eine der Bedingungen von OSI ist, dass die Verteilung von Binärprogrammen und
  Quellen frei erlaubt ist. Dieser Wert kann auch als Schirm für Pakete mit
  Doppellizenz verwendet werden.</li>
<li><code>Restrictive</code> - für einschränkende Lizenzen.
  Benutzen sie diese Lizenz für Pakete, die man von ihren Autoren als Quell-Code
  zur freien Benutzung erhalten kann, aber nicht frei verteilen darf.</li>
<li><code>Restrictive/Distributable</code> - für einschränkende Lizenzen, die
  aber die Verteilung von Quellen und Binärprogrammen erlauben.
  Benutzen sie diese Lizenz für Pakete, die man von ihren Autoren als Quell-Code
  zur freien Benutzung erhalten kann und auch die Verteilung von Quell-Code und
  Binärprogramm erlauben, aber sonstige Einschränkungen haben, die sie zu
  non-open-source-Lizenzen machen.</li>
<li><code>Commercial</code> - für einschränkende, kommerzielle Lizenzen.
  Benutzen sie diese Lizenz für kommerzielle Pakete (z. B. Freeware oder
  Shareware), die die freie Verteilung von Quell-Code oder BinärProgrammen
  nicht zulassen.</li>
<li><code>Public Domain</code> - für Pakete, die Gemeingut sind, d. h. deren
  Autoren ihr Urheberrecht an dem Code aufgegeben haben. Diese Pakete haben
  überhaupt keine Lizenz und jeder kann damit machen, was er will.</li>
</ul>

</section>

<section name="openssl"><title>Die GPL und OpenSSL</title>
<p>(Änderung der Richtlinien ab April 2005.)</p>
<p>
Wegen einer offensichtlichen Inkompatibilität zwischen der OpenSSL-Lizenz und
den GPL- und LGPL-Lizenzen werden Pakete, die OpenSSL-Bibliotheken linken aber
unter der GPL- oder LGPL-Lizenz stehen, als "Restrictive" klassiert. Als
Konsequenz davon wird das Fink-Projekt solche Pakete nicht als Binär-Pakete
anbieten, obwohl es Nutzern frei steht, die Pakete aus den Quellen zu erstellen.
</p>
<p>
Paket-Betreuer sind aufgefordert, die Original-Lizenz des Pakets im Feld
<code>DescPackaging</code> zu vermerken.
</p>

</section>

<section name="prefix"><title>Störungen des Basis-Systems</title>
<p>
Fink ist eine zusätzliche Distribution, die in einem extra Verzeichnis, getrennt
vom Basis-System (OS X) installiert wird.
Es ist von von entscheidender Bedeutung, dass ein Paket keine Dateien außerhalb
von Finks Verzeichnis installiert.
</p>
<p>
Ausnahmen können nur dann gemacht werden, wenn es wirklich nicht anders möglich
ist, z. B. bei XFree86.
In diesen Fällen muss das Paket vor der Installation überprüfen, ob Dateien
vorhanden sind und die Installation verweigern, wenn es vorhandene Dateien
überschreiben würde.
Das Paket muss auch sicher stellen, dass alle Dateien, die außerhalb von Finks
Verzeichnis installiert werden, auch wieder gelöscht werden, wenn das Paket
entfernt wird oder dass sie keinen Schaden verursachen, wenn sie verbleiben (d.
h., dass sie die Präsenz von Programmen überprüfen müssen, bevor sie sie
aufrufen und ähnliches).
</p>

</section>

<section name="sharedlibs"><title>Dynamische Bibliotheken</title>
<p>
Im Februar 2002 traten Finks Richtlinien zu dynamischen Bibliotheken in Kraft.
Dieser Abschnitt der Dokumentation beschreibt die Version 4 dieser Richtlinien
(die mit der Veröffentlichung von Finks 0.5.0 Distribution zusammen fällt.), wie
im Dezember 2006 modifiziert um 64-bit Bibliotheken und im Januar 2008 um
private Bibliotheken zu behandeln. (Außerdem wurde die Diskussion im Juni 2008
aktualisiert, um veraltete Referenzen zu löschen, die aus einer Übergangszeit
stammte, in der die Richtlinien zu dynamischen Bibliotheken implementiert
wurde.) Wir beginnen mit einer kurzen Zusammenfassung und werden die Details
danach diskutieren.
</p>
<p>
Jedes Paket, das dynamische Bibliotheken erstellt, sollte Finks Richtlinien dazu
einhalten. Das bedeutet:
</p>
<ul>
<li>Überprüfen sie mit <code>otool -L</code> (oder <code>otool64 -L</code> für
    64-bit Bibliotheken auf 10.4) dass der install_name jeder Bibliothek und die
    aktuelle Versionsnummer korrekt sind.</li>
<li>Verschieben sie alle öffentlichen dynamischen Bibliotheken gehören in ein
  extra Paket (außer den Links von der libfoo.dylib auf den install_name) und
  fügen sie in diesem Paket das Feld <code>Shlibs</code> hinzu.</li>
<li>Verschieben die Header-Dateien und die finalen Links von der libfoo.dylib in
  ein Paket, das als <code>BuildDependsOnly: True</code> klassifiziert ist und
  planen sie, dass kein anderes Paket von diesem abhängt.</li>
</ul>
<p>
Beachten sie bitte, dass ein Paket auch private dynamische Bibliotheken
installieren kann, die nicht von andern Paketen verlinkt werden sollen. In
diesem Fall müssen die Bibliotheken in ein extra Paket, das aver ebenfalls
das Feld <code>Shlibs</code> haben muss. Außerdem sollte man vermeiden, einen
finalen Link von der libfoo.dylib in das Haupt-Bibliotheksverszeichnis
<filename>%i/lib</filename> (oder seinem 64-bit Äquivalenz) zu legen. So soll
verhindert werden, dass diese Bibliothek unabsichtlich verlinkt wird.
</p>
<p>
Sollte ein Paketbetreuer gute Gründe haben, von dieser Richtlinie abzuweichen,
sollten diese im Feld <code>DescPackaging:</code> eingetragen werden.
</p>
<p>
Für einige Pakete kann alles mit einem Hauptpaket und einem -shlibs-Paket gelöst
werden. In anderen Fällen braucht man noch mindestens ein drittes Paket. Mit dem
neuen Feld <code>SplitOff</code> geht das recht leicht.
</p>
<p>
Werden drei Pakete benötigt, kann man sie auf zwei Arten benennen, je nachdem ob
die Bibliotheken (Option 1) oder die Binärprogramme (Option 2) das wichtigste am
Paket sind. Bei Option 1 sieht das Layout so aus:
</p>

<itemtable labeld="Contents" labelt="Package">

<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>Dynamische Bibliotheken</p></itemd></item>

<item><itemt><code>foo</code></itemt>
<itemd><p>Header-Dateien</p></itemd></item>

<item><itemt><code>foo-bin</code></itemt>
<itemd><p>Binärprogramme, usw.</p></itemd></item>

</itemtable>

<p>während bei Option 2 das Layout so aussieht:</p>

<itemtable labeld="Contents" labelt="Package">

<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>Dynamische Bibliotheken</p></itemd></item>

<item><itemt><code>foo-dev</code></itemt>
<itemd><p>Header-Dateien</p></itemd></item>

<item><itemt><code>foo</code></itemt>
<itemd><p>Binärprogramme, usw.</p></itemd></item>

</itemtable>

<p><em>Die Richtlinien im Detail</em></p>
<p>
Wir werden nun die Dinge im Detail diskutieren. Als Beispiel können sie sich
die Pakete libpng, libjpeg und libtiff anschauen.
</p>
<p>
Software, die nach Darwin oder OS X portiert wird, sollte wenn immer auch
möglich dynamische Bibliotheken erstellen. (Paketbetreuern steht es frei, auch
statische Bibliotheken zu erstellen, wenn das für ihr Paket angemessen ist oder
auch ein Paket zu erstellen, das nur statische Bibliotheken enthält.)
Immer wenn dynamische Bibliotheken erzeugt werden, von denen man erwartet, dass
sie von anderen Paketen benutzt werden, sollten <em>zwei</em> Pakete mit den
Namen foo und foo-shlibs erstellt werden. Die dynamische Bibliotheke gehört in
foo-shlibs und die Header-Dateien in foo. Beide Pakete können in einer Datei
foo.info mit Hilfe des Felds <code>SplitOff</code> erzeugt werden, wie weiter
unten beschrieben.
(Tatsächlich müssen oft mehr als zwei Pakete aus den Quellen erzeugt werden. Das
kann leicht über die Felder <code>SplitOff2</code>, <code>SplitOff3</code> usw.
erreicht werden.)
</p>
<p>
Jedes Softwarepaket mit dynamischen Bibliotheken braucht eine
<em>Hauptversionsnummer</em> N, die in den Namen der Bibliothek eingefügt wird
(z. B. <filename>libbar.N.dylib</filename>).
Diese Hauptversionsnummer soll sich nur ändern, wenn sich die API der
Bibliothek so ändert, dass sie nicht mehr rückwärts-kompatibel ist. Fink benutzt
folgende Konvention für die Namensgebung: Ist der Upstream-Name bar, erhalten
die Fink-Pakete die namen barN und barN-shlibs. (Diese Regel gilt streng nur für
neue Pakete und Pakete, bei denen sich die Hauptversionsnummer ändert.) Ist z.
B. die Hauptversionsnummer des vorliegenden Pakets libpng eine 2 und die Nummer
der neuen Version eine 3, dann macht man daraus folgende vier Pakete: libpng,
libpng-shlibs, libpng3 und libpng3-shlibs.
Nur jeweils eines der Pakete libpng oder libpng3 kann installiert sein.
(Beachte, dass nur zwei2 .info-Dateien für die vier Pakete benötigt werden.)
</p>
<p>
Die eigentliche dynamische Bibliothek und einige dazu gehörige Dateien kommen
in das Paket barN-shlibs. Die "include" und andere Dateien kommen in das Paket
barN. Diese beiden Paketen haben keine gemeinsamen Dateien und alle Dateien in
barN-shlibs müssen die Hauptversionsnummer in Namen ihres Pfades haben. In
vielen Fällen braucht das Paket zur Laufzeit Dateien, die typischerweise in
<filename>%i/lib/bar/</filename> oder <filename>%i/share/bar/</filename>
installiert sind. Sie sollten deshalb die Installationspfade auf
<filename>%i/lib/bar/N/</filename> oder <filename>%i/share/bar/N/</filename>
einstellen.
</p>
<p>
Alle anderen Pakete, die von bar mit der Hauptversionsnummer N abhängen,
brauchen folgende Felder:
</p>
<codeblock>  Depends: barN-shlibs
  BuildDepends: barN</codeblock>
<p>
Es ist für andere Pakete nicht erlaubt, direkt von barN abzuhängen. (Auch wenn
es noch einige Pakete mit solchen Abhängigkeiten aus der Zeit vor Februar 2002
geben kann). Dies wird in der Paketbeschreibung von barN mit dem boolschen Feld
BuildDependsOnly an die Betreuer anderer Pakete signalisiert:
</p>
<codeblock>  BuildDependsOnly: True</codeblock>
<p>
Enthält ihr Paket sowohl dynamische Bibliotheken und Binärdateien und die
Binärdateien werden zur Laufzeit benötigt und nicht nur bei der Erzeugung des
Pakets, dann müssen die Binärdateien zusätzlich zum Paket barN-shlibs in ein
drittes Paket mit dem Namen barN-bin gepackt werden.
</p>
<p>
Erstellt man eine dynamische Bibliothek mit der Hauptversionsnummer N, ist es
wichtig, dass der "install_name" der Bibliothek
<filename>%p/lib/libbar.N.dylib</filename> ist. (Sie können den "install_name"
mit dem Befehl <code>otool -L</code> oder <code>otool64 -L</code> für 64-bit
Bibliotheken auf 10.4 heraus finden.) Die tatsächliche Bibliothek kann an einer
anderen Stelle installiert sein.
</p>
<codeblock>  %i/lib/libbar.N.x.y.dylib</codeblock>
<p>und ihr Paket erzeugt symbolische Links:</p>
<codeblock>  %i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib</codeblock>
<p>
aus dem install_name-Pfad und vom linking-Pfad zu der tatsächlichen
Bibliothek. (Das erste wird nicht benötigt, wenn die Bibliotheke tatsächlich
beim install_name-Pfad installiert ist, was zunehmend der Fall ist.)
</p>
<p>Wird auch eine statische Bibliothek erzeugt, wird sie hier installiert:</p>
<codeblock>  %i/lib/libbar.a</codeblock>
<p>
Verwendet das Paket libtool, wird dies alles automatisch erledigt, aber man
sollte auf jeden Fall überprüfen, dass dies auch korrekt gemacht wurde. Sie
sollten auch überprüfen, ob die current_version und die compatibility_version
für ihre dynamischen Bibliotheken richtig definiert wurden. (Diese werden
ebenso mit den Abfragen <code>otool -L</code> oder <code>otool64 -L</code> für
64-bit Bibliotheken angezeigt.)
</p>
<p>Die Dateien wird wie folgt zwischen den beiden Paketen aufgeteilt:</p>
<ul>
<li>im Paket barN-shlibs:
<codeblock>  %i/lib/libbar.N.x.y.dylib
  %i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/bar/N/*
  %i/share/bar/N/*
  %i/share/doc/barN-shlibs/*</codeblock></li>
<li>im Paket barN:
<codeblock>  %i/include/*
  %i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar.a
  %i/share/doc/barN/*
  andere Dateien, falls vorhanden</codeblock></li>
</ul>
<p>
Beachten sie, dass beide Pakete die Dokumentation zu ihren Lizenzen benötigen,
die Verzeichnisse mit den DocFiles aber unterschiedlich sind.
</p>
<p>
Das macht man in der Praxis am einfachsten mit dem Feld <code>SplitOff</code>.
Das folgende Beispiel zeigt die wichtigsten Teile:
</p>
<codeblock>Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/libbar.N.x.y.dylib lib/libbar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;</codeblock>
<p>
Bei der Bearbeitung des Felds <code>SplitOff</code> werden die angegebenen
Dateien und Verzeichnisse aus dem Installationsverzeichnis %I des Hauptpakets in
das Installationsverzeichnis %i des SplitOff-Pakets verschoben. (Die Konvention
für Namen ist ähnlich: %N ist der Name des Hauptpakets und %n der Name des
aktuellen Pakets.)
Das Feld/Kommando <code>DocFiles</code> kopiert die Dokumentationsdateien in das
Verzeichnis <filename>%i/share/doc/barN-shlibs</filename>.
</p>
<p>
Beachten sie, dass die exakte Version von barN-shlibs als Abhängigkeit im
Hauptpaket barN steht (das mit %N-shlibs (= %v-%r) abgekürzt werden kann).
Damit wird sicher gestellt, dass die Versionen passen und dass das Paket barN
automatisch alle Abhängigkeiten von barN-shlibs "erbt".
</p>
<p><em>Das Feld BuildDependsOnly</em></p>
<p>
Werden Bibliotheken im Laufe der Zeit aktualisiert, ist es oft notwendig, zwei
Versionen der Header-Dateien während der Übergangsphase zur Verfügung zu haben.
Eine Version für das Übersetzen von dem einen und eine für das Übersetzen von
etwas anderem. Deshalb muss man bei der Erstellung der Pakete etwas aufpassen.
Enthalten die Pakete foo-dev und bar-dev überlappende Header, dann muss in
foo-dev folgendes deklariert werden:
</p>
<codeblock>  Conflicts: bar-dev
  Replaces: bar-dev</codeblock>
<p>und genau so, aber umgekehrt, in bar-dev.</p>
<p>
Darüber hinaus sollten beide Pakete das Feld BuildDependsOnly gesetzt haben.
</p>
<codeblock>  BuildDependsOnly: True</codeblock>
<p>
Dies verhindert, dass man Pakete erstellt, die von foo-dev oder bar-dev
abhängen, denn so etwas würde das problemlose Funktionieren des Methode
Conflicts/Replaces verhindern.
</p>
<p>
Es gibt manche Pakete mit Header-Dateien, für die es nicht in Ordnung ist,
BuildDependsOnly als wahr zu setzen. In diesen Fällen sollten sie das Feld
explizit auf falsch setzen:
</p>
<codeblock>  BuildDependsOnly: False</codeblock>
<p>und den Grund dafür im Feld DescPackaging angeben.</p>
<p>
Das Feld BuildDependsOnly sollte nur bei solchen Paketen stehen, die
Header-Dateien in <filename>%i/include</filename> (oder einem Unterverzeichnis)
installieren.
</p>
<p>
Ab Fink 0.20.5 erzeugt der Befehl "fink validate" eine Warnung für jede
.deb-Datei, die Header-Dateien und mindestens eine dynamische Bibliothek
enthält und das Feld BuildDependsOnly weder auf wahr noch falsch setzt.
(Es ist durchaus möglich, dass Fink in Zukunft dies auf Fälle von
.deb-Dateien ausdehnt, die Header-Dateien und statische Bibliotheken
enthält.)
</p>
<p>
Das Ziel der Reichtlinien über dynamische Bibiliotheken ist, dass die
Kompatibilität zwischen den Bibliotheken un dProgrammen in verschiedenen
Paketen gewährleistet ist.  Manche Pakete können Bibliotheken enthalten,
die gar nicht dafür gedacht sind, von anderne Programmen benutzt zu
werden.  Ein häufige Situation ist, dass eine Gruppe von Programmen eine
Backend-Bibliothek mit Hilfsprogrammen haben oder ein Programm, das mehrere
Plugins für bestimmte Features hat.  Da diese Bibliotheken quasi privat
für das Paket sind, braucht man dafür kein extra SplitOff -shlibs und auch
kein <code>BuildDependsOnly</code>.
</p>
<p><em>Das Feld Shlibs</em></p>
<p>
Zusätzlich dazu, dass dynamische Bibliotheken in ein extra Paket gehören,
müssen ab Version 4 dieser Richtlinien alle dynamische Bibliotheken im
Feld <code>Shlibs</code> eingetragen werden. Dieses Feld hat für jede dynamische
Bibliothek nur eine Zeile mit dem <code>-install_name</code> der Bibliothek.
Ist die Bibliothek öffentlich, steht in der Zeile auch die
<code>-compatibility_version</code>, Informationen zur Abhängigkeit mit Version
darüber, welches Fink-Paket die Bibliothek mit dieser
<code>-compatibility_version</code> enthält und die Architektur der Bibliothek.
(Die Architektur der Bibliothek kann "32", "64" oder "32-64" sein oder ganz
fehlen. Ist sie nicht explizit angegeben, wird die Voreinstellung genommen, d.h.
"32" für PowerPC und i386 und "64" für x86_64.) Die Abhängigkeit sollte in der
Form <code>foo (>= version-revision)</code> angegeben sein, wobei sich
<code>foo (>= version-revision)</code> auf die <em>erste</em> Version des
Finkpakets bezieht, das diese Bibliothek (mit der compatibility version) zur
Verfügung stellte. Das folgende Beispiel
</p>
<codeblock>  Shlibs: &lt;&lt;
  %p/lib/libbar.1.dylib 2.1.0 bar1 (>= 1.1-2) 32
  &lt;&lt;</codeblock>
<p>
ist eine (32-bit) Bibliothek mit dem <code>-install_name</code>
%p/lib/libbar.1.dylib und der <code>-compatibility_version</code> 2.1.0, die
in der Version 1.1-2 des Pakets <em>bar1</em> zum ersten Mal angeboten wurde.
Außerdem impliziert die Deklaration, dass der Betreuer versichert, dass auch in
späteren Versionen des Pakets <em>bar1</em> eine 32-bit Bibliothek mit diesem
Namen und einer Kompatibilitätsversion von mindestens 2.1.0 angeboten wird.
</p>
<p>
Beachten sie die Verwendung von %p im Pfad der Bibliothek. Dadurch wird der
richtige <code>-install_name</code> von allen Finknutzern gefunden, egal ob sie
/opt/sw oder einen anderen Präfix für Fink ausgewählt haben.
</p>
<p>
Wird ein Paket aktualisiert, kann meistens das Feld <code>Shlibs</code> einfach
in die nächste Version/Revision des Pakets kopiert werden. Nur wenn sich die
Kompatibilitätsversion erhöht, muss die Versionsnummer in der Abhängigkeit
auf die aktuelle Version/Revision geändert werden, denn hier muss die
Version/Revision stehen, in der die neue Kompatibilitätsversion der Bibliothek
zum ersten Mal angeboten wird.
</p>
<p>
Für private Bibliotheken ist die Syntax für den Eintrag im Feld
<code>Shlibs</code> eine andere:
</p>
<codeblock>  Shlibs: &lt;&lt;
    !%p/lib/%N/libbar.1.dylib
  &lt;&lt;</codeblock>
<p>
Das Ausrufungszeichen am Anfang steht für private Bibliothek. Weitere
Informationen über die Bibliothek sind nicht relevant und werden deshalb weg
gelassen.
</p>
<p>
Beachten sie, dass in diesem Beispiel die private Bibliothek in ein eigenes
Unterverzeichnis <filename>%N</filename> (das nach dem Namen des Pakets benannt
wurde) des Verzeichnisses <filename>%i/lib</filename> verschoben wird. Dies ist
unsere Empfehlung als zusätzlicher Schutzmechanismus, der verhindert, dass
andere Pakete diese Bibliothek aus Versehen verlinken.
</p>
<p>
<em>Was muss ich machen, wenn sich die Nummer der Hauptversion ändert?</em>
</p>
<p>
Ändert sich die Nummer der Hauptversion von N auf M, muss man zwei neue Pakete
barM und barM-shlibs erstellen. Das Paket barM-shlibs darf keine gemeinsamen
Dateien mit dem Paket barN-shlibs haben, weil viele Nutzer die beiden Pakete
gleichzeitig installieren werden. Im Paket barM sollte man folgende
Abhängigkeiten deklarieren:
</p>
<codeblock>  Conflicts: barN
  Replaces: barN</codeblock>
<p>
Im Paket barN muss man in entsprechender Weise, also umgekehrt, folgendes
einfügen
</p>
<codeblock>  Conflicts: barM
  Replaces: barM</codeblock>
<p>
Bei der Erstellung von anderen Paketen werden die Pakete barN und barM
ausgetauscht, je nachdem, welches von den beiden benötigt wird. Die Pakete
barN-shlibs und barM-shlibs bleiben hingegen die ganze Zeit installiert.
</p>
<p><em>Pakete mit Bibliotheken und Binärdateien:</em></p>
<p>
Enthält eine Upstream-Paket gleichzeitig Binärdateien und öffentliche
Bibliotheken, muss man bei der Erstellung der Finkpakete aufpassen. Manchmal
sind die Binärdateien lediglich <code>foo-config</code>, die nur in der
Erstellungs-Phase des Pakets benötigt werden und nie zur Laufzeit. In solchen
Fällen können diese Dateien zusammen mit den Header-Dateien in das Paket
<code>foo</code>.
</p>
<p>
In anderen Fällen werden die Binärdateien von anderen Paketen auch zur Laufzeit
benutzt. Dann müssen sie in ein separates Finkpaket abgetrennt werden, das man
z. B. <code>foo-bin</code> nennen kann. Das Paket <code>foo-bin</code> sollte
vom Paket <code>foo-shlibs</code> abhängen. Betreuer anderer Pakete sollten
aufgefordert werden, die Abhängigkeit von <code>foo-bin</code> in ihrem Paket
zu deklarieren:
</p>
<codeblock>  Depends: foo-bin
  BuildDepends: foo</codeblock>
<p>Damit ist die Abhängigkeit von foo-shlibs implizit enthalten.</p>
<p>
Allerdings ist die Aktualisierung in dieser Situation ein Problem, denn ein
Nutzer wird nicht aufgefordert werden, das Paket <code>foo-bin</code> zu
installieren. Eine Lösung, bis alle anderen Paketbetreuer ihre Pakete
wie oben beschrieben aktualisiert haben, können sie folgende Abhängigkeit in
ihrem Paket <code>foo</code> deklarieren:
</p>
<codeblock>  Depends: foo-shlibs (= exact.version), foo-bin</codeblock>
<p>
Dies erzwingt die Installation des Paket <code>foo-bin</code> auf den meisten
Systemen, solange bis die anderen Paketbetreuer ihre Pakete, die von
<code>foo</code> abhängen, aktualisiert haben.
</p>
<p>
Ab Fink 0.28.0 (veröffentlich im Januar 2008) hat sich das Format für einen
Eintrag im Feld <code>Shlibs</code> für private dynamische Bibliotheken
geändert. (Beachten sie bitte die obigen Erläuterungen zu den Unterschieden
zwischen privaten und öffentlichn dynamischen Bibliotheken.) Die Richtlinien für
dynamische Bibliotheken war schon immer so, dass alle dynamische Bibliotheken
aufgezählt werden müssen. Die Änderung betrifft nur das Feld
<code>Shlibs</code>. Da private Bibliotheken nicht von anderen Paketen benutzt
werden, ist es auch nicht notwendig, die Kompatibilitätsversion oder andere
Versionsinformationen anzugeben. Statt dessen wird ein Ausrufungszeichen
verwendet. Ist z. B. <filename>libquux.3.dylib</filename> der
<code>install_name</code> einer privaten dynamischen Bibliothek, würde sie so
aufgelistet werden:
</p>
<codeblock>  Shlibs: &lt;&lt;
    !%p/lib/libquux.3.dylib
  &lt;&lt;</codeblock>

</section>

<section name="perlmods"><title>Perl-Module</title>
<p>
Die erste Version von Finks Richtlinien zu Perl-Modulen wurde im Mai 2003
implementiert und erhielt im April 2004 die erste Revision.
</p>
<p>
Ursprünglich hatten Fink-Pakete für Perl-Module den Suffix <code>-pm</code> und
wurden mit der Direktive <code>Type: perl</code> erstellt. Damit wurden die
Dateien der Module in <filename>/opt/sw/lib/perl5</filename> und/oder
<filename>/opt/sw/lib/perl5/darwin</filename> abgespeichert.
Nach den aktuellen Richtlinien gilt dies nur noch für Module, die unabhängig von
der Perlversion übersetzt wurden und die auch nicht von anderen
versionsabhängigen Modulen abhängen.
</p>
<p>
Versionsabhängige Perl-Module sind die sogenannten XS-Module, die oft
übersetzten C Code und Perl-Routinen enthalten. Man kann sie auf verschiedene
Weisen erkennen, z. B. daran, die sie eine datei mit dem Suffix
<code>.bundle</code> enthalten.
</p>
<p>
Ein versionsabhängiges Perl-Modul muss mit einer bestimmten binären Version von
Perl erstellt werden, z. B. <code>perl5.12.3</code>. Die erzeugten Dateien
müssen dann in einem versionierten Unterverzeichnis des
Standard-Perlverzeichnisses abgespeichert werden, z. B.
<filename>/opt/sw/lib/perl5/5.12.3</filename> und
<filename>/opt/sw/lib/perl5/5.12.3/darwin</filename>. Es ist Konvention, die Pakete
mit dem Suffix <code>-pm5123</code> zu benennen, wenn sie für die Version 5.12.3
von Perl erstellt wurden. Entsprechende Konventionen für das Abspeichern und
die Namen von Modulen sind perl 5.10.0 (nur für 10.6), perl 5.12.4 (but für
10.7) und perl 5.16.2 (nur für 10.7).
</p>
<p>
Die Direktive <code>Type: perl 5.12.3</code> führt automatisch dazu, dass
das versionierte binäre Perl verwendet wird und speichert die Dateien in den
richtigen Unterverzeichnissen ab. (Diese Direktive steht in Fink ab der Version
0.13.0 zur Verfügung.)
</p>
<p>
Die Richtlinien vom Mai 2003 erlaubten es, ein Paket <code>-pm</code> zu
erstellen, das eigentlich ein Paket-"Bündel" ist, das die Variante
<code>-pm560</code> oder je nach Verfügbarkeit eine andere lädt. Die Richtlinien
vom April 2004 raten davon ab und nach einer Übergangsphase wurde diese
Möglichkeit komplett verboten.
</p>
<p>
Ab der Version 0.20.2 von Fink stellt das Paket system-perl automatisch
bestimmte Perl-Module zur Verfügung, je nach Version von system-perl. Der Code,
mit der die Liste erstellt wird, steht in der Datei <code>VirtPackage.pm</code>,
die Bestandteil des Pakets <code>fink</code> ist.
</p>
<p>
Da verschiedene system-perl unterschiedliche Module zur Verfügung stellen, wird
Paketbetreuern empfohlen, dass sie die Liste überprüfen, wenn sie eines der
Perl-Module verwerden.
</p>
<p>
Ab der Version 0.13.0 von Fink überprüft das Kommando
<code>fink validate</code> bei einer <code>.deb</code>-Datei, ob das Finkpaket
ein XS-Module ist, das in einem nichtversionierten Verzeichnis abgespeichert ist
und gibt eine entsprechende Warnung aus.
</p>
<p>
Nutzer können mehrere Versionen von Perl gleichzeitig installiert haben. Deshalb
müssen versionsabhängige Modulpakete so geschireben sein, dass mehrere Versionen
des Pakets installiert sein können. Besondere aufpassen muss man bei der
Installation von man-Pages und binären oder anderen Programmen, damit wegen
Namenskollissionen keine Installationskonflikte auftreten.
Man darf in einem Paket, dessen Namen auf -pm<em>XYZ</em> endet, keine Dateien
haben, die für verschiedene <em>XYZ</em> die gleichen Pfadnamen haben. Auch ein
<code>Replaces</code> für das einfache Überschreiben der Dateien wird nicht mehr
akzeptiert. Ab März 2005 definiert Fink als einfache Lösung zusätzliche Plätze
im MANPATH: <filename>%p/lib/perl5/X.Y.Z/man</filename> für jedes perl-X.Y.Z.
Deshalb muss man keine extra SplitOff-Pakete -man oder -doc mehr erstellen, die
sich jeweils gegenseitig ausschließen. Die Konflikte zwischen uri-pm5124 und
uri-pm5162 werden z. B. so aufgelöst, dass die gleich man-Page
<filename>URI.3pm</filename> jeweils unter
<filename>%p/lib/perl5/5.12.4/man/man3/URI.3pm</filename> oder
<filename>%p/lib/perl5/5.16.2/man/man3/URI.3pm</filename> abgespeichert wird.
Beachten sie bitte, dass sich die Standard-Skripte für
<code>Type: perl X.Y.Z</code> nicht geändert haben und man deshalb die man-Pages
selbst im <code>InstallScript</code> suchen muss. Ist das Skript nicht
hochgradig kompliziert, dann kann man das Standard-Skript verwenden und die
Dateien einfach mit mv verschieben:
</p>
<codeblock>%{default_script}
mv %i/share/man %i/lib/perl5/5.12.4</codeblock>
<p>
Dies verschiebt alle man-Pages. Will man nur einen Abschnitt der man-Pages
verschieben (z. B. nur Abschnitt 3, die man-Pages für die Module und nicht die
man-Pages für Skripte in Abschnitt 1), funktioniert folgendes:
</p>
<codeblock>%{default_script}
mkdir -p %i/lib/perl5/5.12.4/man
mv %i/share/man/man3 %i/lib/perl5/5.12.4/man</codeblock>
<p>
Hat man Programme, z. B.Demo- und Hilfs-Skripte, in <filename>%p/bin</filename>,
gibt es mehrere Optionen. Eine ist, die Dateien zusammen mit den dazugehörigen
man-Pages und so weiter in ein SplitOff-Paket %N-bin zu packen. Mit den Feldern
<code>Conflicts</code> und <code>Replaces</code> muss man für den gegenseitigen
Austausch bei der Installation der Dateien für verschiedene Perlversionen
sorgen. Der Nutzer kann viele verschiedene Perlversionen der Laufzeit-Module
installieren und dann zu einer bestimmten Zeit die gewünschte Perlversion des
Skripts auswählen. Das Paket Tk.pm kommt z. B. mit dem Programm
<filename>ptksh</filename>. Der Satz an tk-pm* Paketen kann man wie folgt
erzeugen:
</p>
<codeblock>Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4 5.16.2)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
&lt;&lt;
SplitOff: &lt;&lt;
  Package: %N-bin
  Depends: %N
  Conflicts: %{Ni}5.12.3, %{Ni}5.12.4, %{Ni}5.16.2
  Replaces: %{Ni}5.12.3, %{Ni}5.12.4, %{Ni}5.16.2
  Files: bin share/man/man1
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Die andere Option ist die Skripte und ihre man-Pages so umzubenennen, dass
die Namen die Perlversion enthalten. Bei dieser Optione kommt es erst gar nicht
zu einem Namenskonflikt, so dass die %N-bin SplitOffs sich nicht gegenseitig
ausschließen müssen:
</p>
<codeblock>Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4 5.16.2)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
  mv %i/bin/ptksh %i/bin/ptksh%type_raw[perl]
  mv %i/share/man/man1/ptksh.1 %i/share/man/man1/ptksh%type_raw[perl].1
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Der Nutzer kann jederzeit das ptksh für ein bestimmtes Perl benutzen. Besonders
komfortabel für die Nutzer ist es, mit <code>update-alternatives</code> den
Aufruf auch mit dem allgemeinen Namen ohne Perlversion zu ermöglichen.
</p>
<p>
Ab März 2005 wurde auch der Platz für die man-Pages und die Module, die vom
Finkpaket für Perl selbst (also die Pakete perlXYZ und perlXYZ-core mit
Versionen, die vom der von Apple abweichen) geändert. Deshalb sollten andere
Finkpakete die aktualisierte Versionen von core-Perl-Modulen anbieten, die
Pakete perlXYZ oder perlXYZ-core nicht in ihrem Feld <code>Replaces</code>
auflisten.
</p>

</section>

<section name="emacs"><title>Emacs-Richtlinien</title>
<p>
Das Finkprojekt hat entschieden, den Richtlinien des Debianprojekts zu Emacs zu
folgen mit wenigen kleinen Unterschieden.
(Das Dokument zu den Debian-Richtlinien gibt es hier:
<link url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">
http://www.debian.org/doc/packaging-manuals/debian-emacs-policy</link>.)
Es gibt zwei Unterschiede bei den Richtlinien von Fink. Erstens gelten die
Richtlinien derzeit nur für die Pakete <filename>emacs21</filename>,
<filename>emacs22</filename> und <filename>emacs23</filename> und nicht für das
Paket xemacs. (Dies kann sich eines Tages ändern.) Zweitens dürfen Finkpakete im
Gegensatz zu den Debian-Richtlinien Dateien direkt im Verzeichnis
/opt/sw/share/emacs/site-lisp installieren
</p>

</section>

<section name="sources"><title>Quelldateien-Richtlinien</title>
<p>
Quelldateien sollen normalerweise von da herunter geladen werden, wo
Upstream-Entwickler sie anbieten. Jegliche Modifikation für das Finkpaket sollte
mit Patch-Dateien und/oder Patch-Skripten erfolgen. Man sollte also nicht die
Quelldateien abändern und im Finkpaket ein Archiv mit den geänderten Dateien
als <code>Source</code> verwenden.
</p>
<p>
Wird ein vcs Checkout verwendet (z. B. <em>git</em> oder <em>svn</em>), weil
z. B. das Projekt keine formalen Releases veröffentlicht oder eine wichtige
Problemlösung zwischen den Releases eingepflegt wurde, kann eine akzeptable
Quelle auf folgende Art und Weise erzeugt werden:
</p>
<ol>
<li>Führen sie ein Checkout des Pakets durch, vorzugsweise zu einer dezidierten
  Revision des VCS.</li>
<li>Erstellen sie ein Archiv aus dem VCS-Checkout (z. B. ein <em>zip</em>,
  <em>tar</em>, <em>tar.gz</em> oder <em>tar.bz2</em>).
  <p>Geben sie dem Tarball eine eindeutige Version. Sie können die
    VCS-Revision verwenden, wenn es überhaupt keine Releases des Pakets gibt,
    z. B. <filename>foo-0svn1234.tar.gz</filename> oder
    <filename>bar-1.2.3+svn4567.tar.bz2</filename> für eine Version zwischen
    zwei Releases.</p></li>
<li>Nutzen sie die gleiche <code>Version</code> in ihrer
  <filename>.info</filename>-Datei.</li>
<li>Es ist äußerst hilfreich, die Kommandos für die Erzeugung des
  Quelldatei-Tarballs im Feld <code>DescPackaging</code> zu dokumnetieren.</li>
<li>Laden sie den Tarball auf eine öffentliche Download-Seite hoch, wo Nutzer
  sie mit <code>fink</code> herunter laden können. Haben sie keinen
  entsprechenden Zugang, fragen sie in der
  <link url="mailto:fink-devel@lists.sourceforge.net">Fink developers
  Mailing-Liste</link> oder im
  <link url="https://web.libera.chat/#fink">IRC channel #fink</link>.
  nach und ihnen wird sicher geholfen werden.</li>
</ol>

</section>

<section name="downloading"><title>Datei-Download-Richtlinien</title>
<p>
Pakete dürfen in den Phasen unpack, patch, compile, install oder den build
Phasen während des <xref chapter="reference"
section="build">build-Prozess</xref> keinerlei Dateien herunter laden. Alle
größeren Patches (also alles, was man nicht in einer üblichen Patchdatei
unterbringen kann) sollten als zusätzliche Quelldateien entsprechend den
<xref chapter="policy" section="sources">Quelldatei-Richtlinien</xref>
aufgesetzt werden.
</p>
<p>
Unter bestimmten, eng umrissenen Umständen dürfen Pakete im PostInstScript
Dateien herunter laden, nachdem sie installiert sind:
</p>
<ul>
<li>Aktualisierungen der Pakete sind verboten.</li>
<li>Die Daten/Dateien sind so, dass sie nicht leicht in ein Finkpaket zu packen
  sind. Die Virusdefinitionen für <filename>clamav</filename> können z. B. im
  PostInstScript herunter geladen werden, weil sie sich laufend ändern.</li>
</ul>
<p>
Sind sie sich nicht sicher, dann schicken sie eine Email an das
<link url="mailto:fink-core@lists.sourceforge.net">Fink Core Team</link>.
</p>

</section>

</chapter>

<chapter filename="fslayout">
<title>Dateisystem-Layout</title>
<shorttitle>Dateisystem-Layout</shorttitle>

<preface>
<p>
Die folgenden Richtlinien für das Layout der Dateiverzeichnisse sind Bestandteil
der Paket-Richtlinien von Fink.
</p>
</preface>

<section name="fhs"><title>Hierarchie-Standard für Dateiverzeichnisse</title>
<p>
Fink folgt dem Geist des
<link url="http://www.pathname.com/fhs/">Hierarchie-Standards für
Dateiverzeichnisse</link>, abgekürzt als FHS (Filesystem Hierarchy Standard).
Es kann diesen Standard nur nachempfinden, denn er setzt die Kontralle über
<filename>/</filename> und <filename>/usr</filename> voraus.
Fink ist aber ein Zusatz, der nur die Kontrolle über sein eigenes
Installationsverzeichnis hat. Die Beispiele verwenden den voreingestellten
Präfix <filename>/opt/sw</filename>.
</p>

</section>

<section name="dirs"><title>Die Verzeichnisse</title>
<p>
Dateien sollten in den Verzeichnissen wie folgt abgespeichert werden:
</p>

<itemtable>

<item><itemt><filename>/opt/sw/bin</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis ist für allgemeine ausführbare Programme.
Es hat keine weiteren Unterverzeichnisse.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/sbin</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis ist für Programme, die nur von Administratoren ausgeführt
werden.
Daemon-Programme, die im Hintergrund laufen, gehören hier her.
Es hat keine weiteren Unterverzeichnisse.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/include</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis ist für C und C++ Header-Dateien.
Unterverzeichnisse können je nach Bedarf angelegt werden.
Installiert ein Paket Header-Dateien, die mit Standard C Header-Dateien
verwechselt werden könnten, <em>müssen</em> diese Header-Dateien in ein
Unterverzeichnis.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/lib</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis ist für Daten-Dateien und Bibliotheken, die von der
Architektur abhängen.
Statische und dynamische Bibliotheken gehören direkt in
<filename>/opt/sw/lib</filename>, außer es gibt sehr gute Gründe.
Ebenso gehören Programme hierher, die nicht direkt vom Nutzer ausgeführt werden
(üblicherweise befinden sich solche Programme in libexec).
</p>
<p>
Ein Paket darf Unterverzeichnisse für private Daten oder ladbare Module anlegen.
Achten sie darauf, dass die Namen der Unterverzeichnisse sinnvoll sind und der
Kompatibilität dienen.
Es ist durchaus sinnvoll, den Namen des Verzeichnisses umd die Hauptversion des
Pakets zu erweitern oder zusätzliche Unterverzeichnisse einzufügen, z. B.
<filename>/opt/sw/lib/perl5</filename> oder <filename>/opt/sw/lib/apache/1.3</filename>.
Aufpassen muss man, wenn der Typ des Rechners im Namen verwendet wird.
Ein Verzeichnis mit dem Namen <code>powerpc-apple-darwin1.3.3</code> kann leicht
zu Kompatibilitätsproblemen führen, die sich durch
<code>powerpc-apple-darwin1.3</code> oder <code>powerpc-apple-darwin</code>
leicht vermeiden lassen.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/lib/ppc64</filename>
<filename>/opt/sw/lib/x86_64</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis ist für 64-bit-Bibliotheken auf 32-bit-Systemen, mit
<filename>/opt/sw/lib/ppc64</filename> für die PowerPC-Architektur und
<filename>/opt/sw/lib/x86_64</filename> für die i386-Architektur.
Bibliotheken, die als "fat" erzeugt wurden, sollten aber in
<filename>/opt/sw/lib</filename> abgespeichert werden und ein '32-64' in ihrem
Feld Shlibs eingetragen haben. Beachten sie, dass unter der x86_64-Architektur
64-bit-Bibliotheken in  <filename>/opt/sw/lib</filename> werden.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/share</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis ist für architektur-unabhängige Daten-Dateien. Es gelten
die selben Regeln wie für <filename>/opt/sw/lib</filename>.
Einige Unterverzeichnisse werden im folgenden beschrieben.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/share/man</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis enthält Dokumentationen als man-Pages.
Es ist weiter in die üblichen Abschnitte unterteilt.
Zu jedem Programm in  <filename>/opt/sw/bin</filename> und
<filename>/opt/sw/sbin</filename> sollte es hier eine entsprechende man-Page geben.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/share/info</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis enthält Dokumentationen im Info format (erstellt aus
Texinfo Quellen).
Die Pflege der Datei <code>dir</code> ist automatisiert und erfolgt mit
Debians Version von <code>install-info</code> (Teil des Pakets
<code>dpkg</code>).
Verwenden sie das Feld <code>InfoDocs</code>, um entsprechenden Code für die
Skripte <code>postinst</code> und <code>prerm</code> automatisch zu erzeugen.
Fink kümmert sich darum, dass kein Paket eine eigene Datei <code>dir</code>
erzeugt.
Es gibt keine Unterverzeichnisse.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/share/doc</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis enthält Dokumentationen, die weder als man-Page noch als
Info-Dokument vorliegen.
Die Dateien README, LICENSE und COPYING gehören z. B. hier her.
Jedes Paket muss hier sein eigenes Unterverzeichnis anlegen, das wie das Paket
benannt wird.
Die Namen der Unterverzeichnisse dürfen keine Versionsnummern enthalten, außer
wenn diese Nummern Teil des tatsächlichen Paketnamens sind.
Tipp: Verwenden sie einfach <code>%n</code>.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/share/locale</filename></itemt>
<itemd>
<p>
Dieses Verzeichnis enthält Kataloge mit Meldungen für die Internationalisierung.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/opt</filename></itemt>
<itemd>
<p>
In Verzeichnis <filename>opt</filename> werden "add-on" Programmpakete
abgespeichert, die aus irgendeinem Grund nicht die Standard-Verzeichnisse
<filename>/opt/sw/bin</filename>, <filename>/opt/sw/lib</filename>,
<filename>/opt/sw/include</filename>, usw. nicht verwenden können.
Ein Paket, das in <filename>/opt/sw/opt</filename> installiert wird, muss seine
statischen Dateien in einem separaten Unterverzeichnis
<filename>/opt/sw/opt/&lt;package&gt;</filename> abspeichern, wobei
<filename>&lt;package&gt;</filename> ein Name ist, der das Programmpaket
beschreibt.
(Verfügbar ab Fink 0.29.7 oder später.)
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/var</filename></itemt>
<itemd>
<p>
Im Verzeichnis <filename>var</filename> werden veränderliche Daten gespeichert.
Das umfasst Spool-Verzeichnisse, Lock-Dateien, Status-Datenbanken, Punktestände
von Spielen und Log-Dateien.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/etc</filename></itemt>
<itemd>
<p>
Diese Verzeichnis enthält Konfigurationsdateien.
Gehören zu einem Paket mehr als ein oder zwei Dateien, sollte ein
Unterverzeichnis angelegt werden.
Der Name des Unterverzeichnis muss den Namen des Pakets oder Programms
enthalten, damit es zugeordnet werden kann.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/src</filename></itemt>
<itemd>
<p>
In diesem Verzeichnis werden die Quell-Dateien gespeichert und erfolgt die
Codeerstellung. Vom den Paketen sollte hier nicht weiter installiert werden.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/Applications</filename></itemt>
<itemd>
<p>
In diesem Verzeichnis werden Programm mit einer graphischen Oberfläche im Stil
von OS X abgespeichert, die man normalerweise mit einem Doppelklick startet und
nicht von der Kommandozeile.
</p>
</itemd></item>

<item><itemt><filename>/opt/sw/Library/Frameworks</filename></itemt>
<itemd>
<p>
In diesem Verzeichnis werden Frameworks im OS X-Stil abgespeichert. Sie werden
manchmal von Programmen im OS X-Stil genutzt.
</p>
</itemd></item>

</itemtable>

</section>

<section name="avoid"><title>Was sollte man vermeiden?</title>
<p>
Außer den oben genannten Unterverzeichnissen sollte es keine anderen im
Verzeichnis <filename>/opt/sw</filename> geben.
Insbesondere die folgenden sind explizit nicht erlaubt:
<filename>/opt/sw/man</filename>, <filename>/opt/sw/info</filename>,
<filename>/opt/sw/doc</filename>, <filename>/opt/sw/libexec</filename> und
<filename>/opt/sw/lib/locale</filename>.
</p>

</section>

</chapter>

<chapter filename="compilers">
<title>Compiler</title>
<shorttitle>Compiler</shorttitle>

<preface>
<p>
Fink verwendet die gcc-Familie an Compilers wie sie Apple durch die
Apple Developer Connection zur Verfügung stellt. Es gibt mehrere Versionen von
gcc und normalerweise stehen auf einem Mac OS X System mehr als eine Version
zur Verfügung.
</p>
<p>
Dieses Kapitel erläutert, wie Fink mit den verschiedenen Versionen von gcc
umgeht. Weitere Details können in dieser
<link
url="http://www.mail-archive.com/fink-devel@lists.sourceforge.net/msg11877.html">
Email</link>
an die Fink mailing list nachgelesen werden.
</p>
</preface>

<section name="versions"><title>Compilerversionen</title>
<p>
So wie sich gcc entwickelt hat, gab es verschiedene "Distributionen" von Fink,
um die damit verbundenen Änderungen und Probleme abzufangen.
</p>
<p>
Jede Fink-Distribution hat eine Voreinstellung für die gcc und g++ Compiler, von
denen jeder Nutzer normalerweise erwartet, dass sie installiert sind. Jeder kann
erwarten, dass bei einem direkten Aufruf von "gcc" und "g++" diese Versionen
starten. Benötigt man andere Version (z. B. beim Übergang auf eine neue
Distribution) muss das Paket in der .info-Datei die benötigte Version des
Apple-Compiler explizit angeben. Im Details hängt das von dem Build-System des
Pakets ab, aber in dem meisten Fällen können dafür die Felder <code>SetCC</code>
und <code>SetCXX</code> verwendet werden.
Will man z. B. auf die Version 3.3 des Compiler g++ wechseln dann muss man
<code>SetCXX: g++-3.3</code> eintragen. Überprüfen sie die Ausgabe beim
Erstellen des Pakets, ob die richtige Version verwendet wird.
</p>
<p>
Die Distribution 10.1 geht von der Version 2.95 des Compiler aus, die
Distribution 10.2 von der Version 3.2, die Distributionen 10.2-gcc3.3 und 10.3
von der Version 3.3. Für die Distribution 10.4-transitional ist es kompliziert,
weil g++-3.3 zusammen mit gcc-4.0 verwendet wird. Die Distributionen 10.4 und
10.5 verwenden gcc-4.0 und g++-4.0. Die Distribution 10.6 verwendet gcc-4.2,
während 10.7 bis 10.9  clang and clang++ als Voreinstellung verwenden. Bei 10.9
kommt eine weitere Änderung durch den Übergang von libstdc++ nach libc++ dazu.
</p>
<p>
Mit der Distribution 10.4-transitional wurde eine neute Methode eingeführt, mit
der sicher gestellt wird, dass der richtige g++ Compiler verwendet wird.
Während des Compilierens wird das Verzeichnis
<code>/opt/sw/var/lib/fink/path-prefix-g++-XXX</code> (wobei xxx die Versionsnummer
ist) in der Pfadvariablen PATH eingetragen. In diesem Verzeichnis befinden sich
Shellskripte, die dafür sorgen, dass die richtige Version des g++ Compiler
aufgerufen wird.
</p>

</section>

<section name="abi"><title>Die g++ ABI</title>
<p>
Die g++ Abi hat sich in der Zeit von OS X dreimal geändert: Sie ist für die
Versionen 2.95, 3.1, 3.3 and 4.0 unterschiedlich. Sie sind untereinander nicht
kompatibel und jede Bibliothek mit C++ Code, die sie in ihrem Projekt verlinken,
muss mit der selben ABI compiliert sein, wie das, was sie gerade compilieren.
</p>
<p>
Fink dokumentiert die g++ ABI mit dem Feld GCC. Dieses Feld sollte in allen
Paketen definiert sein, die die g++ oder c++ Compiler aufrufen.
(Es sollte NICHT in Paketen definiert sein, die diese Compiler nicht aufrufen.)
Sobald es eine Aktualisierung in der ABI gibt, müssen alle abhängigen Pakete auf
ihr GCC Feld überprüft werden. Erst wenn die alle aktualisiert sind, kann auch
das Paket selbst aktualisiert werden. Die Versionen der Pakete müssen erhöht
werden, damit Nutzer wirklich die richtige, aktualisierten Abhängigkeiten
installieren, bevor sie versuchen ihr Paket zu erstellen.
</p>
<p>
Eine kleine Gruppe an Paketen, die nur von sich selbst abhängen, können auch bei
einer Änderung der ABI bei der alten Version bleiben, wenn sie z. B. noch nicht
aktualisiert werdden. Werden sie dann aktualisiert, müssen sie alle zusammen mit
der richtigen Version der ABI ersetzt werden. Deshalb ist es am besten, dass man
die meisten Pakete sofort dann aktualisiert, wenn sich die Distribution ändert.
</p>
<p>
Fink benutzt das Feld GCC um sicher zu stellen, dass die richtiger Version des
g++ Compiler installiert ist. Ist das Feld GCC in einem Paket definiert,
überprüft Fink ob der Wert dazu passt, was man für die Version von OS X
erwartet, aso 3.3 für die OS X Versionen 10.2 und 10.3 und 4.0 für OS X 10.4 bis
OS X 10.9.
</p>

</section>

</chapter>

<chapter filename="reference">
<title>Referenz</title>
<shorttitle>Referenz</shorttitle>

<section name="build"><title>Der Build-Prozess</title>
<p>
Für das Verständnis einiger Felder, muss man einige Details über den
Build-Prozess von Fink wissen: Der Build-Prozess besteht aus fünf Phasen:
Auspacken, patchen, compilieren, installieren und erstellen (build). Die
Pfade des nachfolgenden Beispiel sind für eine Installation in
<filename>/opt/sw</filename> und für das Paket gimp-1.2.1-1.
</p>
<p>
In der <em>Auspack-Phase</em> wird das Verzeichnis
<filename>/opt/sw/src/fink.build/gimp-1.2.1-1</filename> erzeugt und der
Quell-Tarball oder mehrere darin ausgepackt. Das erzeugt meistens ein
Verzeichnis gimp-1.2.1, das die Quellen enthält. Alle folgenden Schritte
erfolgen in diesem Verzeichnis, also in
<filename>/opt/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>. Details
dieser Phase können über die Felder SourceDirectory, NoSourceDirectory und
Source<em>N</em>ExtractDir kontrolliert werden.
</p>
<p>
In der <em>Patch-Phase</em> werden die Quelldateien gepacht, so dass das Paket
auf Darwin/Mac OS X erstellt werden kann. Die Aktionen werden über die Felder
UpdateConfigGuess, UpdateLibtool, Patch und PatchScript genau in dieser
Reihenfolge ausgeführt.
</p>
<p>
In der <em>Compile-Phase</em> werden die Quelldateien konfiguriert und
compiliert. Normalerweise bedeutet dies, dass das Skript <code>configure</code>
mit einigen Parametern und dann das Kommando <code>make</code> ausgeführt
werden. Details dazu stehen in der Beschreibung des Felds CompileScript.
Sind Tests für die Erstellung aktiviert (ein neues Feature in Fink 0.25, derzeit
wird es im Betreuer-Modus aktiviert), wird das Test-Skript direkt nach dem
Compile-Skript ausgeführt.
</p>
<p>
In der <em>Installationsphase</em> wird das Paket in einem temporären
Verzeichnis, <filename>/opt/sw/src/fink.build/root-gimp-1.2.1-1</filename> (= %d),
installiert. (Beachten sie den Teil "root-" im Namen.) Alle Dateien, die
normalerweise in <filename>/opt/sw</filename> installiert würden, werden stattdessen
in <filename>/opt/sw/src/fink.build/root-gimp-1.2.1-1/opt/sw</filename> (= %i = %d%p)
installiert. Weitere Details stehen in der Beschreibung des Felds InstallScript.
</p>
<p>
(<em>In Fink 0.9.9 eingeführt.</em>
Man kann mit einer einzigen Paketbeschreibung mehrere Pakete erzeugen, indem man
das Feld <code>SplitOff</code> benutzt. Gegen Ende der Installationsphase wird
für jedes Paket ein separates Installationsverzeichnis erzeugt und die Dateien
dann in das jeweilige Verzeichnis verschoben.)
</p>
<p>
In der <em>Erstellungsphase</em> wird eine binäre Datei (.deb) aus dem
temporären Installationsverzeichnis erzeugt. Diese Phase kann nicht direkt
beeinflusst werden, aber diverse Informationen aus der Paketbeschreibung werden
verwendet um eine Datei <filename>control</filename> für dpkg zu erstellen.
</p>

</section>

<section name="fields"><title>Felder</title>
<p>
Die Felder wurden in mehrere Kategorien eingeteilt. Es kann auch sein, dass
das eine oder andere Feld nicht beschrieben ist. <code>:-)</code>
</p>
<p><em>Start Daten:</em></p>

<itemtable>

<item><itemt>Package</itemt>
<itemd>
<p>
Der Paketname.
Er kann Kleinbuchstaben, Zahlen und die Sonderzeichen '.', '+' und '-'
enthalten, aber keine Unterstriche ('_') oder Grossbuchstaben.
Ein Pflichtfeld.
</p>
<p>
Eine Prozenterweiterung wird in diesem Feld nur für %N, %{Ni}, %type_raw[],
und %type_pkg[] vorgenommen.
</p>
<p>
Gemäß den Richtlinien für Finkpakete, muss ein Paket immer mit den gleichen
Optionen übersetzt werden. Bei verschiedenen Varianten eines Pakets (siehe die
Dokumentation zum Feld <code>Type</code>) muss man die jeweilige Variante in das
Feld <code>Package</code> einpflegen (siehe die Dokumentation für die
Prozenterweiterung %type_pkg[]). Auf diese Weise erhält jede Variante einen
eindeutigen Namen und die Namen zeigen, welche Varianten zur Verfügung stehen.
Beachten sie, dass die Prozenterweiterung %type_pkg[] und %type_raw[] relativ
neu sind und total inkompatibel mit älteren Versionen von Fink. Deshalb müssen
solche Paketbeschreibungen in ein Feld <code>InfoN</code> mit N ≥ 2 eingebettet
werden.
</p>
</itemd></item>

<item><itemt>Version</itemt>
<itemd>
<p>
Die upstream-Versionsnummer.
Es gelten die gleichen Einschränkungen wie für das Feld Package
Ein Pflichtfeld.
</p>
<p>
Beachten sie, dass einige Programm seltsame Schemen für ihre Versionsnummern
verwenden, die die Sortierung durcheinander bringen oder Zeichen enthalten, die
nicht erlaubt sind. In diesen Fällen muss sie den upstream-Wert so umwandeln,
dass er nur erlaubte Zeichen enthält und eine korrekte Sortierung ermöglicht.
Wenn sie sich über die Sortierung von Zeichenketten nicht sicher sind, können
sie das Kommando <code>dpkg</code> für einen Test verwenden. Im folgenden
Beispiel
</p>
<codeblock>  dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo "true"</codeblock>
<p>
wird &quot;true&quot; ausgegeben, weil die Zeichenkette &quot;1.2.1&quot; vor
&quot;1.3&quot; kommt. Mehr Details gibt es auf der man-Page von
<code>dpkg</code>.
</p>
</itemd></item>

<item><itemt>Revision</itemt>
<itemd>
<p>
Die Revision des Pakets.
Erhöhen sie diese Zahl, wenn sie eine neue Paketbeschreibung für dieselbe
upstream-Version erstellen.
Revisionsnummern beginnen mit 1.
Ein Pflichtfeld.
</p>
<p>
Finks Richtlinien verlangen, dass die Revisionsnummer <em>jedes</em> Mal erhöht
werden muss, wenn Änderungen in der Datei <filename>.info</filename> Änderungen
in der binären (kompilierten) Form des Pakets (die Datei
<filename>.deb</filename>) zur Folge haben. Beispiele sind Änderungen im
Feld <code>Depends</code> oder in anderen Paketlisten, Hinzufügen, Entfernen
oder Umbenennen von SplitOff-Paketen oder Dateien zwischen diesen hin und her
schieben. Erfordert die Migration eines Paket in einen neuen Baum (z. B. von
10.2 nach 10.3) solche Änderungen, sollten sie die Revision um 10 oder mehr
im neuen Baum erhöhen, damit noch Platz für Änderungen im alten Baum bleibt.
</p>
</itemd></item>

<item><itemt>Architecture</itemt>
<itemd>
<p>
Dies ist Komma-separierte Liste der Architekturen, für die das Paket (und jedes
SplitOff-Paket in der Beschreibung) vorgesehen ist.
Die gültigen Architekturen sind ab Fink-0.29.5 <code>powerpc</code>,
<code>i386</code> und <code>x86_64</code>.
Ist dieses Feld vorhanden und auch nach Auswertungen von Bedingungen nicht leer,
ignoriert Fink die Paketbeschreibung, wenn die lokal vorhandene Architektur
nicht aufgelistet ist. Ist das Feld weg gelassen oder der Wert leer, werden
alle Architekturen akzeptiert.
</p>
<p>
Ein häufiger Grund für dieses Feld ist, dass ein Paket einen Compiler vor
gcc-4.0 benötigt (oder auch Pakete, die von solchen Paketen abhängen) und für
die Architektur <code>powerpc</code> ist.
</p>
<p>
Diese Feld unterstützt auch die Standardsyntax für Bedingungen für jeden Wert in
der Werteliste. Ebenso können Prozenterweiterungen verwendet werden (Beim Feld
<code>Depends</code> werden weitere Details beschrieben). Damit können bestimmte
Varianten auf bestimmte Architekturen beschränkt werden. Im folgenden Beispiel:
</p>
<codeblock>  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.8 5.10.0)
  Architecture: (%type_pkg[perl] = 5100) x86_64</codeblock>
<p>
ist die Variante foo-pm5100 für <code>x86_64</code> und bei der Varianten
foo-pm588 bleibt das Feld leer, d. h. diese Variante ist für alle Architekturen.
</p>
<p>
Das Beispiel oben zeigt eine recht verbreitete Verwendung des Felds: Da einige
Module auf 10.6 nicht mit dem System-Perl 5.10.0 als 32-bit (i386) erstellt
werden können, schränkt dieses Feld die Perl-Pakete mit mehreren Typen auf
bestimmte Systeme ein.
</p>
</itemd></item>

<item><itemt>Distribution</itemt>
<itemd>
<p>
Dies ist Komma-separierte Liste der Distributionen für die das Paket (und jedes
SplitOff-Paket in der Beschreibung) vorgesehen ist.
Derzeit sind die gültigen Distributionen
<code>10.4</code>,
<code>10.5</code>,
<code>10.6</code>,
<code>10.7</code>,
<code>10.8</code>,
<code>10.9</code>,
<code>10.10</code>,
<code>10.11</code>,
<code>10.12</code>,
<code>10.13</code>,
<code>10.14</code>,
<code>10.14.5</code>,
and <code>10.15</code>
. Ist dieses Feld vorhanden und auch nach Auswertungen von Bedingungen nicht leer,
ignoriert Fink die Paketbeschreibung, wenn die lokal vorhandene Distribution
nicht aufgelistet ist. Ist das Feld weg gelassen oder der Wert leer, werden
alle Distributionen akzeptiert.
(Eingeführt in Fink 0.26.0.)
</p>
<p>
Seit den Fink-Distributionen für <code>10.9</code> durch <code>10.14.5</code> teilen sie sich ein gemeinsames Set an finkinfo-Dateien. Eine
übliche Verwendung des Felds ist, die Distributionen auszuklammern, für die
das Paket nicht erstellt werden kann.
</p>
<p>
Diese Feld unterstützt auch die Standardsyntax für Bedingungen für jeden Wert in
der Werteliste. Ebenso können Prozenterweiterungen verwendet werden (Beim Feld
<code>Depends</code> werden weitere Details beschrieben). Damit können bestimmte
Varianten auf bestimmte Distributionen beschränkt werden. Im folgenden Beispiel:
</p>
<codeblock>  Package: foo-pm%type_pkg[perl]
  Type: perl (5.12.3 5.12.4)
  Distribution: (%type_pkg[perl] = 5123) 10.7, (%type_pkg[perl] = 5123) 10.8</codeblock>
<p>
ist die Variante foo-pm5123 für die Distributionen <code>10.7, 10.8</code>
und bei der Varianten foo-pm5124 bleibt das Feld leer, d. h. diese Variante ist
für alle Distributionen.
</p>
<p>
Da die Python-Version 2.5 für die Distributionen 10.7+ nicht zur Verfügung steht
und die Perl-Versionen von Distrivution zu Distribution variieren, wird diese
Feld in diesen Paketen häufig vor. Als Referenz beschreiben wir hier die
Verfügbarkeit verschiedener Perl-Versionen für die Distributionen 10.3 bis 13.0
(<em>Fett</em>-gedruckte Systeme zeigen die Version von Sytem-Perl an):
</p>
<codeblock>
    perl 5.6.0:  10.3
    perl 5.8.0:  10.3
    perl 5.8.1:  <em>10.3</em>, 10.4
    perl 5.8.4:  10.3, 10.4
    perl 5.8.6:  10.3, <em>10.4</em>, 10.5
    perl 5.8.8:        10.4, <em>10.5</em>, 10.6
    perl 5.10.0:             10.5, <em>10.6</em>
    perl 5.12.3:                         <em>10.7</em>, 10.8, 10.9
    perl 5.12.4:                         10.7, <em>10.8</em>, 10.9
    perl 5.16.2:                         10.7, 10.8, <em>10.9</em>, 10.10, 10.11, 10.12, 10.13
    perl 5.18.2:                         10.7, 10.8, 10.9, <em>10.10</em>, <em>10.11</em>, <em>10.12</em>, <em>10.13</em>, <em>10.14</em>, 10.14.5, 10.15, 11.0, 11.3, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.18.4:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, <em>10.14.5</em>, <em>10.15</em>, 11.0, 11.3, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.28.2:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, <em>11.0</em>, 11.3, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.30.2:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, 11.0, <em>11.3</em>, 12.0, 13.0, 14.0, 14.4, 15.0
    perl 5.30.3:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, 11.0, 11.3, <em>12.0</em>, <em>13.0</em>, <em>14.0</em>, 14.4, 15.0
    perl 5.34.1:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, 10.14.5, 10.15, 11.0, 11.3, 12.0, 13.0, 14.0, <em>14.4</em>, <em>15.0</em>
</codeblock>
<p>
Eine Möglichkeit, alle unterstützten Varianten in einer einzigen finkinfo-Datei
einzuschließen, ist diese:
</p>
<codeblock>  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.8 5.10.0 5.12.3 5.12.4 5.16.2)
  Distribution: &lt;&lt;
   (%type_pkg[perl] = 588) 10.6,
   (%type_pkg[perl] = 5100) 10.6,
   (%type_pkg[perl] = 5123) 10.7, (%type_pkg[perl] = 5123) 10.8, (%type_pkg[perl] = 5123) 10.9,
   (%type_pkg[perl] = 5124) 10.7, (%type_pkg[perl] = 5124) 10.8, (%type_pkg[perl] = 5124) 10.9,
   (%type_pkg[perl] = 5162) 10.7, (%type_pkg[perl] = 5162) 10.8, (%type_pkg[perl] = 5162) 10.9
  &lt;&lt;</codeblock>
<p>
Beachten sie, dass wir alte Distributionen, wie 10.2 oder 10.4-transitional,
nicht einschließen, denn die Finkversionen für diese Distributionen unterstützen
dieses Feld nicht.
</p>
</itemd></item>

<item><itemt>Epoch</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.12.0.</em>
Diese optionale Feld kann dazu benutzt werden, die Epoche eines Pakets zu
beschreiben. (Ist es nicht angegeben, ist die Voreinstellung 0). Weitere Details
stehen im
<link
url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian
Policy Manual</link>.
Da Fink und die dahinter stehenden Debian-Tools als eindeutigen Bezeichner für
ein Paket die Abfolge Name-Version-Revision nehmen, darf man keine Pakete
definieren, die sich lediglich in der Epoche unterscheiden.
</p>
<p>
In einer Zeichenkette für die Version kommt die Epoche vor der Version,
abgetrennt durch ein Semikolon (1:3.14-2). Beachten sie, dass das Feld Epoche
weder in <code>%v</code> noch in <code>%f</code> enthalten ist. Fügt man das
Feld Epoche in einer Paketbeschreibung hinzu, muss man auch die Abhängigkeiten
aktualisieren. Fügt man z. B. in einem Paket <code>Epoch: 1</code> hinzu und das
Splitoff foo-dev deklariert <code>Depends: foo-shlibs (= %v-%r)</code>, muss man
das zu <code>Depends: foo-shlibs (= %e:%v-%r)</code> aktualisieren.
</p>
</itemd></item>

<item><itemt>Description</itemt>
<itemd>
<p>
Eine kurze Beschreibung des Pakets (Was ist es?). Diese Beschreibung ist
einzeilig und wird in Überscihtslisten verwendet. Deshalb muss es kurz und
informativ sein. Die Becshreibung soll kürzer als 45 Zeichen sein und muss
kürzer als 60 Zeichen sein. Der Paketname muss in diesem Feld nicht vorkommen -
diese Beschreibung wird immer im entsprechenden Kontext verwendet.
Ein Pflichtfeld.
</p>
</itemd></item>

<item><itemt>Type</itemt>
<itemd>
<p>
Dieses Feld kann auf <code>bundle</code> gesetzt werden.
Bundle-Pakete werden dazu benutzt, einen Satz von Paketen in einer Gruppe
zusammen zu fassen. Ein Bundle-Paket hat nur Abhängigkeiten, aber keinen Code
oder installierte Dateien. Die Felder Source, PatchScript, CompileScript,
InstallScript und verwandte Felder werden für Bundle-Pakete ignoriert.
</p>
<p>
Das Feld <code>nosource</code> ist ähnlich. Es bedeutet, dass es keinen
Quellcode-Tarball gibt, nichts herunter geladen wird und die Auspack-Phase nur
ein leeres Verzeichnis erzeugt.
Die Phasen Patch, Compile und Install werden aber normal ausgeführt.
Man kannn also den ganzen Code in der Patchphase erzeugen und im InstallSkript
einige Verzeichnisse erzeugen.
Ab Fink 0.18.0 kann man das selbe Verhalten auch mit den Feld
<code>Source: none</code> erzeugen. Dann kann man ds Feld Type für andere
Zwecke benutzen(<code>Type: perl</code>, usw.)
</p>
<p>
Ab Fink 0.9.5 gibt es den Typ <code>perl</code>, durch den alternative
Voreinstellungen in den Compile- und Install-Skripten verwendet werden.
Ab Fink 0.13.0 gibt es eine weitere Variante diesen Typs
<code>perl $version</code>, bei dem $version ein bestimmte Version von Perl ist
die aus 3 Zahlen besteht, die mit Punkten getrennt werden, z. B.
<code>perl 5.6.0</code>.
</p>
<p>
Seit einer CVS-Version von Fink nach Fink-0.19.2 wurde die Verwendung von
Sprache/Sprachenversion verallgemeinert, so dass Paketbetreuer Typen und
Subtypen definieren können und ein Paket mehr als einen Typ haben können.
Typ und Subtyp sind beliebige Zeichenketten ohne Leerzeichen (Klammern,
Kommata und Prozentzeichen sollten ebenfalls nicht benutzt werden);
die Prozenterweiterung wird NICHT angewendet und der Typ (aber nicht der Subtyp)
wird in Kleinbuchstaben konvertiert. Mehrere Typen (jeder mit einem optionalen,
leerzeichen-separierten Subtyp) werden komma-separiert aufgelistet.
</p>
<p>
Zusätzlich existiert das Konzept von &quot;variants&quot;, bei dem in einer
einzigen .info-Datei eine Familie von Paketen beschrieben werden, bei denen
verschiedene Optionen eingeschaltet sind. Der Schlüssel zu dem ganzen Prozess
ist eine Liste von Subtypen. Statt einer einzigen Zeichenkette nutzt man eine
Leerzeichen-separierte Liste von Zeichenketten in Klammern. Fink erzeugt für
jeden Subtyp in der Liste einen Klon und ersetzt die Liste mit dem jeweiligen
Subtyp, z. B.:
</p>
<codeblock>Type: perl (5.12.3 5.12.4)</codeblock>
<p>
ergibt zwei Paketbeschreibungen, eine die sich verhält als ob
<code>Type: perl 5.12.3</code> und eine andere als ob
<code>Type: perl 5.12.4</code> gesetzt ist. Die spezielle Subtypliste
&quot;(boolean)&quot; steht für eine Liste, die den Typ selbst und einen Punkt
enthält. Folgende zwei Formen sind identisch:
</p>
<codeblock>Type: -x11 (boolean)
Type: -x11 (-x11 .)</codeblock>
<p>
Die Erweiterung der Subtyp-Liste und das Klonieren der Pakete ist rekursiv.
Stehen mehrere Typen in der Subtyp-Liste erhält man alle Kombinationen:
</p>
<codeblock>Type: -ssl (boolean), perl (5.12.3 5.12.4)</codeblock>
<p>
Man kann eine bestimmte Subtyp-Variante in anderen Felder mit
%type_raw[] und %type_pkg[] verwenden. Im folgenden zwei Beispiele mit
.info-Fragmenten:
</p>
<codeblock>Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4)
Depends: perl%type_pkg[perl]-core
 &lt;&lt;</codeblock>
<codeblock>Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [ &quot;%type_raw[-x11]&quot; == &quot;-x11&quot; ]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Ab Fink 0.26.0 gibt es den speziellen <code>Type: -64bit</code>, der die
neue Prozenterweiterung <code>%lib</code> einführt und auch die Voreinstellung
für <code>LDFLAGS</code> ändert. Kombiniert mit der neuen Konstruktion
%type_num[] kann man so in einer einzigen .info-Datei sowohl 32-bit als auch
64-bit Versionen einer Bibliothek erzeugen.
Hier ein Beispiel:
</p>
<codeblock>Info2: &lt;&lt;
Package: foo%type_pkg[-64bit]
Type: -64bit (boolean)
Depends: (%type_raw[-64bit] = -64bit) 64bit-cpu
ConfigureParams: --libdir='${prefix}/%lib'
SplitOff: &lt;&lt;
 Package: %N-shlibs
 Files: %lib/libfoo.*.dylib
 Shlibs: &lt;&lt;
    %p/%lib/libfoo.1.dylib 1.0.0 %n (>= 1.0-1) %type_num[-64bit]
  &lt;&lt;
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Beachten sie, dass <code>Type: -64bit</code> für die x86_64-Architektur nicht
angemessen ist, denn dafür ist die Voreinstellung, dass 64-bit Bibliotheken
erstellt und in <filename>%i/lib</filename> abgespeichert werden.
</p>

</itemd></item>

<item><itemt>License</itemt>
<itemd>
<p>
Dieses Feld spezifiziert die Lizenz, unter der das Paket vertrieben werden kann.
Der Wert muss einer aus dem Kapitel
<xref chapter="policy" section="licenses">Packet-Lizensen</xref>
weiter oben in diesem Dokument sein.
Zusätzlich darf dieses Feld nun verwendet werden, wenn das Paket auch
tatsächlich die Richtlinien dafür einhält, d. h. eine Kopie der Lizenz im
Verzeichnis doc des Pakets installiert.
</p>
</itemd></item>

<item><itemt>Maintainer</itemt>
<itemd>
<p>
Name und Email-Adresse der Person, die für das Paket verantwortlich ist
Das Feld ist ein pflichtfeld und es darf nue ein Name und eine Adresse im
folgenden Format angegeben werden:
</p>
<codeblock>Vorname Familienname &lt;Nutzer@host.domain.com&gt;</codeblock>
</itemd></item>

<item><itemt>InfoN</itemt>
<itemd>
<p>
Diese Feld erlaubt Fink Syntaxänderungen in den Paketbeschreibungen zu
implementieren, die nicht rückwärtskompatibel sind. Eine gegebene Version von
Fink ist auf die maximale Zahl "N" gesetzt, die für sie machbar ist. Pakete
mit einem höheren N werden ignoriert. Deshalb sollte dieser Mechanismus nur
verwendet werden, wenn es notwendig ist. Ansonsten werden Nutzer mit älteren
Finkversionen unnötigerweise ausgeschlossen. Verwenden sie diesen Mechanismus,
indem sie die gesamte Paketbeschreibung in das Feld InfoN einschließen.
Sie können bei Datei-Format weiter oben nachschauen, wie die Syntax für
mehrzeilige Felder aussieht.
Es folgen die Features des jeweiligen InfoN-Niveau und die erste Version von
Fink, die es unterstützt:
</p>
<ul>
<li><code>Info2</code> (fink ≥ 0.20.0): Die Möglichkeit, Prozenterweiterung im
  Hauptfeld <code>Package</code> der .info-Datei und die Prozenterweiterung
  <code>%type_*</code> im Feld <code>Package</code> von <code>SplitOff</code>-
  (und <code>SplitOff<em>N</em></code>-)Paketen zu nutzen.</li>
<li><code>Info3</code> (fink ≥ 0.25.0): Schönes Einrücken in .info-Dateien,
  keine Unterstützung für Mehrfachzeilen nach RFC-822 und Kommentare in den
  Feldern pkglist.</li>
<li><code>Info4</code> (fink ≥ 0.26.2): fügt die Erweiterung %V hinzu und
  erlaubt <code>%lib</code> im Feld <code>ConfigureParams</code>.</li>
</ul>
</itemd></item>

</itemtable>

<p><em>Abhängigkeiten:</em></p>

<itemtable>

<item><itemt>Depends</itemt>
<itemd>
<p>
Dieses Feld enthält die Liste der Pakete, die installiert werden müssen, bevor
das Paket erstellt werden kann. Die Prozenterweiterung kann in diesem Feld
verwendet werden (genau wie auch in den anderen Feldern dieser Sektion:
BuildDepends, RuntimeDepends, Provides, Conflicts, Replaces, Recommends,
Suggests und Enhances). Normalerweise ist es eine Komma-separierte Liste mit
den Paketnamen, aber Fink unterstützt in der gleichen Syntax wie dpkg auch
Alternativen und Versionen.
Ein Beispiel mit allen Varianten:
</p>
<codeblock>Depends: &lt;&lt;
	daemonic (&gt;= 20010902-1),
	emacs | xemacs
&lt;&lt;</codeblock>
<p>
Das Layout ist das bevorzugte Format für das Feld <code>Depends</code> und
ähnliche Felder. Das Feld benutzt die Zeichen <code>&lt;&lt;</code> für
Mehrfachzeilen. Jedes Paket steht in alphabetischer Ordnung in einer separaten,
eingerückten Zeile. Hat das Feld nur einen einzigen Eintrag, kann auch das
vereinfachte Format <code>Field: value</code> verwendet werden.
</p>
<p>
Beachten sie, dass es keine Möglichkeit für optionale Abhängigkeiten gibt.
Funktioniert ein Paket sowohl mit als auch ohne ein anderes Paket, dann müssen
sie sicher stellen, dass das Paket auch nicht verwendet wird, auch wenn es
vorhanden ist. Andernfalls müssen sie das Paket in das Feld <code>Depends</code>
aufnehmen.
Wollen sie beide Optionen anbieten, müssen sie zwei separate Pakete erstellen,
z. B. wget und wget-ssl.
</p>
<p>
Ausführungsreihenfolge der Operationen: Ein logisches &quot;OR&quot; (Liste der
Alternativen) hat höhere Priorität (verknüpft enger) als ein logisches
&quot;AND&quot; zwischen den Paketen (oder einem Satz an Alternativen) in der
Komma-separierten Liste. Anders als die Verwendung von Klammern in
arithmetischen Ausdrücken gibt es im Feld <code>Depends</code> und verwandten
Feldern keine Möglichkeit für alternative Paketgruppen oder für die eine
Änderungen der Ausführungsreihenfolge der Operationen.
</p>
<p>
Beginnend mit einer post-0.18.2 CVS-Version of Fink kann man bedingte
Abhängigkeiten verwenden. Diese kann man dadurch ausdrücken, dass man
<code>(Zeichenkette1 op Zeichenkette2)</code> vor den Paketnamen platziert. Die
Prozenterweiterung wird wie gewohnt ausgeführt und dann werden die beiden
Zeichenketten, von denen keine leer sein kann, mit Hilfe eines der Operatoren
<code>op</code> (&lt;&lt;, &lt;=, =, !=, &gt;&gt;, &gt;=) verglichen. Das
folgende Paket wird nur berücksichigt, wenn der Vergleich wahr ist.
</p>
<p>
Sie können dieses Format nutzen, um die Pflege mehrerer ähnlicher Pakete zu
vereinfachen. Beide Pakete elinks und elinks-ssl könnten z. B. folgendes
auflisten:
</p>
<codeblock>Depends: &lt;&lt;
	expat-shlibs,
	(%n = elinks-ssl) openssl097-shlibs
&lt;&lt;</codeblock>
<p>Das hätte den gleichen Effekt, wie wenn elinks folgendes auflisten würde:</p>
<codeblock>Depends: expat-shlibs</codeblock>
<p>und elinks-ssl dieses:</p>
<codeblock>Depends: expat-shlibs, openssl097-shlibs</codeblock>
<p>
In einer alternativen Syntax, könnenten sie auch eine
<code>(Zeichenkette)</code> angeben, womit sie wahr ist, wenn die
<code>Zeichenkette</code> nicht leer ist, z. B.:
</p>
<codeblock>Package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11</codeblock>
<p>
Dies würde das Paket x11 als Abhängigkeit für die Variante nethack-x11 setzen,
aber nicht die Variante nethack.
</p>
<p>
Beachten sie folgendes: Verwenden sie die Felder Depends/BuildDepends für
dynamische Bibliothekspakete, für die es mehrere Hauptversionen gibt, dürfen
sie folgendes <em>nicht</em> deklarieren:
</p>
<codeblock>  Package: foo
  Depends: id3lib3.7-shlibs | id3lib4-shlibs
  BuildDepends: id3lib3.7-dev | id3lib4-dev</codeblock>
<p>
auch wenn ihr Paket mit jeder Bibliothek funktionieren sollte. Sie müssen eine
auswählen (vorzugsweise die mit der höchsten Version, die verwendet werden kann)
und verwenden sie in ihrem Paket diese Version durchgängig.
</p>
<p>
Wie im Kapitel über die Richtlinien über
<xref chapter="policy" section="sharedlibs">dynamische Bibliotheken</xref>
erklärt, kann immer nur ein Paket -dev installiert sein und jedes hat Links
mit dem gleichen Namen, die auf verschiedene Dateinamen im zugehörigen Paket
-shlibs zeigen können. Kompiliert man das Paket foo, wird der tatsächliche
Dateiname (im Paket -shlibs) fest in das Binärprogramm foo übernommen. Dies
bedeutet, dass das Paket genau dieses bestimmte Paket -shlibs benötigt, das zu
dem Paket -dev gehört, das zur Compile-Zeit installiert war. Deshalb kann
das Feld <code>Depends</code> nicht so aussehen, dass irgendeines ausreicht.
</p>
<p>
In der Vergangenheit hingen nicht-eseentielle Pakete implizit von essentiellen
ab; dies ist nicht mehr der Fall.
</p>
</itemd></item>

<item><itemt>BuildDepends</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.9.0.</em>
Eine Liste mit Abhängigkeiten, die nur für die Erstellungsphase gilt.
Man kann sie nutzen, um Tools aufzulisten (z. B. flex), die man für das
Erstellen des Pakets benötigt, aber nicht zur Laufzeit.
Es hat die gleiche Syntax wie das Feld <code>Depends</code>. Sind die
Test-Suites beim Erstellen eines Pakets aktiviert, werden die Abhängigkeiten
des Felds <code>TestDepends</code> dem Feld <code>BuildDepends</code> hinzu
gefügt.
</p>
</itemd></item>

<item><itemt>RuntimeDepends</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.32.0.</em>
Eine Liste mit Abhängigkeiten, die nur für die Laufzeit gilt, also wenn
das Paket installiert ist.
Dieses Feld kann genutzt werden, um Pakete aufzulisten, die man zur Laufzeit
benötigt, aber nicht beim Erstellen des Pakets.
Es hat die gleiche Syntax wie das Feld <code>Depends</code>.
</p>
</itemd></item>

<item><itemt>Provides</itemt>
<itemd>
<p>
Eine komma-separierte Liste von Paketnamen, die dieses Paket zur Verfügung
stellt.
Wenn ein Paket namens "pine" <code>Provides: mailer</code> deklariert, dann ist
jede Abhängigkeit von einem Paket "mailer" erfüllt, wenn "pine" installiert ist.
Meisten wird man diese Pakete auch in den Feldern <code>Conflicts</code>
und <code>Replaces</code> auflisten.
</p>
<p>
Beachten sie bitte, dass im Feld <code>Provides</code> keine Versionen verwendet
werden können. Die Pakete erben weder die Version des Elternpakets noch ist eine
Syntax für die Angabe einer Version definiert. Darüber hinaus gilt eine
Abhängigkeit mit einer bestimmten Version als nicht erfüllt. Damit ist es
relativ gefährlich, wenn mehrere Varianten dasselbe Paket in
<code>Provides</code> deklarieren, weil die Versionsabhängigkeit nicht
berücksichtigt werden kann. Deklarieren z. B. sowohl das Paket foo-gnome als
auch das Paket foo-nognome ein <code>Provides: foo</code>, ist die Abhängigkeit
<code>Depends: foo (> 1.1)</code> in einem anderen Paket nicht erfüllt.
</p>
</itemd></item>

<item><itemt>Conflicts</itemt>
<itemd>
<p>
Eine komma-separierte Liste von Paketnamen, die nicht gleichzeitig mit diesem
Paket installiert sein dürfen.
Virtuellen Pakete ist es erlaubt, Pakete aufzulisten, die auch im Feld
<code>Provides</code> stehen; sie werden entsprechend behandelt.
Dieses Feld unterstützt auch versionierte Abhängigkeiten wie das Feld
<code>Depends</code>, aber keine Alternativen (das wäre auch nicht sinnvoll).
Ist ein Paket in seinem eigenen Feld <code>Conflicts</code> aufgelistet,
wird es ohne eine Meldung aus der Liste entfernt (eingeführt in einer
post-0.18.2 CVS-Version von Fink.).
</p>
<p>
<em>Bitte beachten:</em> Fink selbst ignoriert dieses Feld, aber es wird an dpkg
weitergegeben und entsprechend ausgewertet. Damit gilt es nur für die Laufzeit
und nicht während der Erstellungszeit von Fink.
</p>
</itemd></item>

<item><itemt>BuildConflicts</itemt>
<itemd>
<p>
Eine Liste von Paketnamen, die nicht installiert sein dürfen, während dieses
Paket compiliert wird. Man kann es dazu benutzten, dass <code>./configure</code>
oder der Compiler unerwünschte Bibliotheks-Header erkennt oder um zu
verhindern, dass eine Version eines Tools verwendet wird, von dem bekannt ist,
dass es fehlerhaft ist (z. B. ein Fehler in einer bestimmten Version von sed).
Sind bei der Erstellung eines Pakets die Test-Suites aktiviert, werden zu dieser
Liste die Pakete vom Feld <code>TestConflicts</code> hinzugefügt.
</p>
</itemd></item>

<item><itemt>Replaces</itemt>
<itemd>
<p>
Dieses Feld wird zusammen mit dem Feld <code>Conflicts</code> benutzt, wenn ein
Paket nicht nur die Funktion eines anderen Pakets übernimmt, sondern auch einige
gemeinsamen Dateien hat.
Ohne dieses Feld erzeugt dpkg bei der Installation einen Fehler, weil die
Dateien immer noch Besitz eines anderen Pakets sind.
Es ist auch ein Hinweis, dass die zwei Pakete echte Alternativen sind und eines
gegen das andere ausgetauscht werden kann.
Ist ein Paket in seinem eigenen Feld<code>Replaces</code> aufgelistet,
wird es ohne eine Meldung aus der Liste entfernt (eingeführt in einer
post-0.18.2 CVS-Version von Fink.).
</p>
<p>
<em>Bitte beachten:</em> Fink selbst ignoriert dieses Feld, aber es wird an dpkg
weitergegeben und entsprechend ausgewertet. Damit gilt es nur für die Laufzeit
und nicht während der Erstellungszeit von Fink.
</p>
</itemd></item>

<item><itemt>Recommends, Suggests, Enhances</itemt>
<itemd>
<p>
Diese Felder deklarieren zusätzliche Beziehungen im selben Stil wie die anderen
Felder.
Diese drei Beziehungen haben auf die tatsächliche Installation mit
<code>dpkg</code> oder <code>apt-get</code> keinen Einfluss.
Sie werden aber von <code>dselect</code> und ähnlichen Frontends genutzt, um
dem Nutzer sinnvolle Vorschäge anzubieten.
</p>
</itemd></item>

<item><itemt>Pre-Depends</itemt>
<itemd>
<p>
Eine spezielle Variante des Felds <code>Depends</code> mit strengerer Semantik.
Dieses Feld darf nur benutzt werden, wenn der Fall auf der
Developer-Email-Liste diskutiert wurde und Konsens erreicht wurde, dass es
wirklich notwendig ist.
</p>
</itemd></item>

<item><itemt>Essential</itemt>
<itemd>
<p>
Ein boolscher Wert, der essentielle Pakete markiert. Essentielle Pakete werden
im Bootstrap-Prozess installiert. <code>dpkg</code> weigert sich essentielle
Pakete von dem System zu entfernen, so lange keine speziellen Flags gesetzt
sind, um dies zu übergehen.
In der Vergangenheit hingen nicht-essentielle Pakete implizit von den
essentiellen ab; dies ist aber nicht mehr der Fall.
</p>
</itemd></item>

<item><itemt>BuildDependsOnly</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.9.9.</em>
Ein boolscher Wert, der anzeigt, dass kein anderes Paket von diesem abhängen
darf, zulässig ist nur ein BuildDepend.
Im Unterschied zu den üblichen boolschen Feldern, gibt es für
<code>BuildDependsOnly</code> drei Zustände. Undefiniert (überhaupt nicht
angegeben) unterscheidet sich von einer Deklarierung als falsch. Weitere Details
sind im Kapitel
<xref chapter="policy" section="sharedlibs">Dynamische Bibliotheken</xref>
beschrieben.
</p>
<p>
Ab Fink 0.20.5 werden die Präsenz/Absenz des Felds und wenn der Wert gesetzt
ist, der Wert in die .deb Datei aufgenommen, wenn das Paket erstellt wird.
<em>Deshalb muss man die Revisionsnummer des Pakets erhöhen, wenn man den Wert
von BuildDependsOnly ändert oder das Feld hinzufügt oder löscht.</em>
</p>
</itemd></item>

</itemtable>

<p><em>Auspack-Phase:</em></p>

<itemtable>

<item><itemt>CustomMirror</itemt>
<itemd>
<p>
Eine Liste der Spiegelserver: Jeder Spiegelserver steht im folgenden Format in
einer separaten Zeile: <code>&lt;location&gt;: &lt;url&gt;</code>.
<em>location</em> kann ein Kontinent-Code (z. B. <code>nam</code>), ein
Länder-Code (z. B. <code>nam-us</code>) oder irgendetwas anderes sein; Die
Spiegelserver werden in der gegebenen Reihenfolge ausprobiert.
Ein Beispiel:
</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&lt;&lt;</codeblock>
<p>
Die Standard-Codes für Kontinent und Land stehen in der Datei
<filename>/opt/sw/lib/fink/mirror/_keys</filename>, Teil der Pakete fink oder
fink-mirrors.
</p>
</itemd></item>

<item><itemt>Source</itemt>
<itemd>
<p>
Eine URL zu dem Quell-Tarball. Es sollte eine HTTP- oder eine FTP-URL sein, aber
Fink kümmert sich nicht weiter darum, sondern reicht die URL an wget weiter.
Diese Feld unterstützt ein spezielles URL-Schema für Spiegelserver:
<code>mirror:&lt;Spiegelname&gt;:&lt;Relativpfad&gt;</code>. Daraufhin wird
der <em>Spiegelname</em> in Finks Konfiguration nachgeschaut, der Teil
<em>Relativpfad</em> angehängt und als tatsächliche URL verwendet. Die bekannten
<em>Spiegelnamen</em> sind in der Datei
<filename>/opt/sw/lib/fink/mirror/_list</filename> aufgelistet, die Teil des Pakets
fink oder fink-mirrors ist. Alternative dazu kann auch <code>custom</code> als
<em>Spiegelname</em> verwendet werden und dann wird Fink das Feld
<code>CustomMirror</code> dazu auswerten.
Bevor die URL verwendet wird, kommt die Prozenterweiterung zum Tragen. Bedenken
sie, dass %n alle Datenvarianten %type_ einschließt. Es kann deshalb günstiger
sein, hier %{ni} zu verwenden (eventuell mit einigen spezifischen %type_
Erweiterungen).
</p>
<p>
Ab Fink 0.18.0 hat <code>Source: none</code> die spezielle Bedeutung, dass es
keine Quelldateien zum Herunterladen gibt. Weitere Details dazu stehen in der
Beschreibung des Felds <code>Type</code>.
Der Wert <code>gnu</code> ist eine Abkürzung für
<code>mirror:gnu:%n/%n-%v.tar.gz</code> und <code>gnome</code> für
<code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code>. Die Voreinstellung
ist <code>%n-%v.tar.gz</code> (also manuelles Herunterladen).
Diese Form einer implizit-definierten <code>Source</code> is obsolet (explizit
angegebene einfach Namen für manuelles herunterladen ist immer noch in Ordnung).
</p>
<p>
Quellen, die nur für die Testsuite benötigt werden, sollten im Feld
<code>TestSource</code> und verwandten Felder im Block <code>InfoTest</code>
aufgelistet werden.
</p>
</itemd></item>

<item><itemt>Source<em>N</em></itemt>
<itemd>
<p>
Enthält ein Paket mehrere Tarballs, muss man sie mit diesen zusätzlichen Feldern
aufführen, beginnend mit N = 2. Der erste Tarball (der auch als der
Haupt-Tarball betrachtet werden kann) steht also im Feld <code>Source</code>,
der 2. im Feld <code>Source2</code> und so weiter. Die Regeln sind die gleichen
wie für Source, nur dass die Abkürzungen "gnu" und "gnome" nicht ausgewertet
werden, denn das wäre sowieso nutzlos. Beginnend mit einer CVS-Version von Fink
nach 0.19.2 können sie beliebige (und nicht notwendigerweise aufeinander
folgende) Werte mit N ≥ 2 verwenden, aber keine Dubletten.
</p>
</itemd></item>

<item><itemt>SourceDirectory</itemt>
<itemd>
<p>
Diese Feld wird benötigt, wenn der Tarball in ein einziges Verzeichnis
ausgepackt wird, dessen Namen sich aber vom Rumpf des Tarball-Namens
unterscheidet. Ein Tarball mit dem Namen "foo-1.0.tar.gz" wird normalerweise in
ein Verzeichnis "foo-1.0" ausgepackt. Ist das nicht der Fall, so kann man den
Namen mit diesem Feld angeben. Prozenterweiterung wird in diesem Feld
ausgeführt.
</p>
</itemd></item>

<item><itemt>NoSourceDirectory</itemt>
<itemd>
<p>
Setzen sie diesen boolschen Parameter auf wahr (true), wenn der Tarball nicht in
ein einziges Verzeichnis ausgepackt wird. Ein Tarball mit dem Namen
"foo-1.0.tar.gz" wird normalerweise in ein Verzeichnis "foo-1.0" ausgepackt.
Werden aber die Dateien des Tarballs nur in das aktuelle Verzeichnis ausgepackt,
nutzen sie dieses Feld und setzen sie den Wert auf wahr (true).
</p>
</itemd></item>

<item><itemt>Source<em>N</em>ExtractDir</itemt>
<itemd>
<p>
Normalerweise wird ein zusätzlicher Tarball in dasselbe Verzeichnis wie der
Haupt-Tarball ausgepackt. Muss er aber in ein spezifisches Unterverzeichnis
ausgepackt werden, können sie dies in diesem Fald angeben. Source2ExtractDir
bezieht sich erwartungsgemäß auf den Tarball in Source2. Beispiele dafür sind in
den Paketen ghostscript, vim und tetex.
</p>
</itemd></item>

<item><itemt>SourceRename</itemt>
<itemd>
<p>
Mit diesem Feld kann man eine Quell-Tarball umbenennen. Das ist vor allem dann
nützlich, wenn die Version der Quelle im Namen des Verzeichnis des Servers
steht, der Tarball aber für alle Versionen gleich heißt, z. B.
<filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename>. Die
damit verbundenen Probleme kann man wie folgt umgehen:
</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
<p>
In diesem Beispiel würde z. B. der Tarball unter dem Namen
<filename>/opt/sw/src/coolapp-1.2.3.tar.gz</filename> abgespeichert werden, genau so
wie man es erwarten würde.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>Rename</itemt>
<itemd>
<p>
Dieses Feld erfüllt die gleiche Funktion, nur dass es sich auf Tarballs bezieht,
die in den entsprechenden Feldern <code>Source<em>N</em></code> stehen.
Beispiele dafür finden sie in den Paketbeschreibungen context oder hyperref.
</p>
</itemd></item>

<item><itemt>Source-MD5</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.10.0.</em>
In diesem Feld müssen sie die MD5 Checksum der Quelldatei eintragen. Fink
benutzt diese Information um falsche Quelldateien zu entdecken, d. h. Tarballs,
die nicht mit denen übereinstimmen, die der Paket-Betreuer verwendet hat.
Häufige Ursachen für dieses Problem sind: unvollständig herunter geladene
Dateien, Austausch des Tarball Upstream ohne Ankündigung, Trojanerangriff oder
ähnliches und alles mögliche andere.
</p>
<p>Ein typisches Beispiel sieht so aus:</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
<p>
Für die Berechnung der Checksum kann man das Tool <code>md5sum</code> verwenden.
Die Checksum des Tarball <filename>/opt/sw/src/apache_1.3.23.tar.gz</filename> kann
man mit dem folgenden Kommando berechnen (einschließlich der Ausgabe):
</p>
<codeblock>fingolfin% md5sum /opt/sw/src/apache_1.3.23.tar.gz 
4499443fa1d604243467afe64522abac  /opt/sw/src/apache_1.3.23.tar.gz</codeblock>
<p>Wie man sieht ist der Wert links genau die Summe, die man braucht.</p>
</itemd></item>

<item><itemt>Source<em>N</em>-MD5</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.10.0.</em>
Dieses Feld hat denselben Zweck wie das Feld <code>Source-MD5</code>, mit dem
Unterschied, dass es für die MD5 Checksum der Tarballs der entsprechenden Felder
<code>Source<em>N</em></code> ist.
</p>
</itemd></item>

<item><itemt>Source-Checksum</itemt>
<itemd>
<p>
Alternative method to list the checksum for a source file. This field
takes a hash type, followed by the actual checksum. For example:
</p>
<codeblock>Source-Checksum: SHA256(5048f1c8fc509cc636c2f97f4b40c293338b6041a5652082d5ee2cf54b530c56)</codeblock>
<p>
Current valid checksums are <code>MD5</code>, <code>SHA1</code>, and
<code>SHA256</code>. The <code>shasum</code> tool can be used to
calculate SHA checksums:</p>
<codeblock>$ shasum -a 256 /opt/sw/src/libexif-0.6.22.tar.xz 
5048f1c8fc509cc636c2f97f4b40c293338b6041a5652082d5ee2cf54b530c56  /opt/sw/src/libexif-0.6.22.tar.xz
</codeblock>
<p>
The <code>Source-Checksum</code> field should only be used once per
.info file. If both the <code>Source-MD5</code> and
<code>Source-Checksum</code> fields are present,
<code>Source-Checksum</code> takes precedence.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>-Checksum</itemt>
<itemd>
<p>
This is just the same as the <code>Source-Checksum</code> field, except that it
is used to specify the checksum of the tarball specified by the
corresponding <code>Source<em>N</em></code> field.
</p>
</itemd></item>

<item><itemt>TarFilesRename</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.10.0.</em>
Dieses Feld bezieht sich nur auf Quelldateien im tar-Format.
</p>
<p>
Mit diesem Feld kann man Dateien in einem gegebenen Quell-Tarball während des
Auspackens umbenennen. Dies behebt die Probleme, die damit zusammenhängen, dass
das HFS+ Dateisystem Groß- und Kleinschreibung nicht unterscheidet und z. B.
die Dateien <filename>install</filename> und <filename>INSTALL</filename> auf
dem Standard Mac OS X eine Kollission verursachen. Mit diesem Feld kann man
dieses Problem beheben ohne dass man einen neuen Tarball erstellen muss (was
in der Vergangenheit die einzige Lösung war.).
</p>
<p>
In diesem Feld können sie einfach eine Liste an Dateien aufführen, die umbenannt
werden sollen. Man kann auch Wildcards benutzen. Standard ist einfach eine
Umbennung mit angehängtem <code>_tmp</code>. Dies kann man mit derselben
Syntax wie in den Feldern <code>Files</code> und <code>DocFiles</code>
überschreiben, nämlich mit dem alten Dateinamen, gefolgt von einem : und dann
dem neuen Dateinamen.
Ein Beispiel:
</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: directory/INSTALL:directory/INSTALL.txt</codeblock>
</itemd></item>

<item><itemt>Tar<em>N</em>FilesRename</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.10.0.</em>
Dieses Feld ist genau wie das Feld <code>TarFilesRename</code> mit dem
Unterschied, dass es auf den Tarball angewendet wird, der im entsprechenden
Feld <code>Source<em>N</em></code> steht.
</p>
</itemd></item>

</itemtable>

<!-- Patch Phase -->
<p><em>Patch-Phase:</em></p>

<itemtable>

<item><itemt>UpdateConfigGuess</itemt>
<itemd>
<p>
Ein boolscher Wert. Ist er auf wahr (true) gesetzt, werden die Dateien
config.guess und config.sub im Verzeichnis build durch Versionen ersetzt, die
Darwin kennen. Dies erfolgt in der Patch-Phase bevor das PatchSkript ausgeführt
wird. Benutzen sie dies <em>NUR</em>, wenn sie sich sicher sind, dass es
benötigt wird, d. h. wenn das configure-Skript mit der Fehlermeldung "unknown
host" abbricht.
</p>
</itemd></item>

<item><itemt>UpdateConfigGuessInDirs</itemt>
<itemd>
<p>
<em>Eingeführt in einer post-0.9.0 CVS-Version.</em>
Eine Liste von Unterverzeichnissen.
Es macht das gleiche wie das Feld UpdateConfigGuess, aber für Pakete mit
veralteten config.guess-Dateien in mehreren Verzeichnissen überall im Baum der
Quellen.
Früher musste man die Dateien von Hand im Patchskript an die richtigen Stellen
kopieren.
Mit diesem Feld muss man nur noch die Verzeichnisse auflisten.
Benutzen sie <code>.</code>, um auch die Dateien im Verzeichnis build zu
ersetzen.
</p>
</itemd></item>

<item><itemt>UpdateLibtool</itemt>
<itemd>
<p>
Ein boolscher Wert. Ist er auf wahr (true) gesetzt, werden die Dateien ltconfig
und ltmain.sh im Verzeichnis build durch Versionen ersetzt, die Darwin kennen.
Dies erfolgt in der Patch-Phase bevor das PatchSkript ausgeführt wird. Benutzen
sie dies <em>NUR</em>, wenn sie sich sicher sind, dass es benötigt wird. Einige
Pakete kann man beschädigen, wenn man die libtool-Skripte mit unpassenden
Versionen überschreibt. Für weitere Details lesen sie die Seiten über
<link url="/doc/porting/libtool.php">libtool</link>.
</p>
</itemd></item>

<item><itemt>UpdateLibtoolInDirs</itemt>
<itemd>
<p>
<em>Eingeführt in einer post-0.9.0 CVS-Version.</em>
Eine Liste von Unterverzeichnissen.
Es macht das gleiche wie das Feld UpdateLibtool, aber für Pakete mit veralteten
libtool-1.3.x-Skripten in mehreren Verzeichnissen überall im Baum der
Quellen.
Früher musste man die Dateien von Hand im Patchskript an die richtigen Stellen
kopieren.
Mit diesem Feld muss man nur noch die Verzeichnisse auflisten.
Benutzen sie <code>.</code>, um auch die Dateien im Verzeichnis build zu
ersetzen.
</p>
</itemd></item>

<item><itemt>UpdatePoMakefile</itemt>
<itemd>
<p>
Ein boolscher Wert.
Ist er auf wahr (true) gesetzt, wird die Datei
<filename>Makefile.in.in</filename> im Unterverzeichnis <filename>po</filename>
durch eine angepasste Version ersetzt.
Dies erfolgt in der Patch-Phase bevor das PatchSkript ausgeführt wird.
</p>
<p>
Die angepasste Version respektiert DESTDIR sorgt dafür, dass Kataloge mit
Meldungen im Verzeichnis <filename>/opt/sw/share/locale</filename> landen und nicht
in <filename>/opt/sw/lib/locale</filename>.
Bevor sie dieses Feld benutzen, überprüfen sie, dass das Paket nicht beschädigt
wird und überhaupt notwendig ist.
Sie können sich mit dem Tool <code>diff</code> die Unterschiede zwischen der V
ersion des Pakets und der in Fink (in <filename>/opt/sw/lib/fink/update</filename>)
anzeigen lassen.
</p>
</itemd></item>

<item><itemt>Patch</itemt>
<itemd>
<p>
Der Dateiname eines Patch, der mit dem Kommando
<code>patch -p1 &lt;<em>patch-file</em></code> angewendet wird. Dies sollte
einfach ein Dateiname sein. Der zugehörige Pfad (das gleiche Verzeichniss, in
dem die .info-Datei steht) wird automatisch davor gestellt. Prozenterweiterung
wird in diesem Feld ausgeführt. Ein typischer Wert ist einfach
<code>%f.patch</code> oder <code>%n.patch</code>. Der Patch wird in einem
separaten Schritt angewandt, bevor das Patch-Skript (wenn vorhanden) ausgeführt
wird.
</p>
<p>
Beachten sie, dass %n allen Datenvarianten %type_ einschließt. Es kann deshalb
günstiger sein, hier %{ni} zu verwenden (eventuell mit einigen spezifischen
%type_ Erweiterungen). Es ist einfacher, eine einzige Patchdatei zu pflegen und
dann variantenspezifische Änderungen im Patch-Skript zu machen als separate
Patchdateien für jede Variante zu pflegen.
</p>
<p>
Ab Fink-0.29.0 sollte dieses Feld nicht benutzt werden. Nutzen sie statt dessen
das Feld <code>PatchFile</code>. Die Unterstützung für das Feld
<code>Patch</code> wird in Zukunft entfernt werden.
</p>

</itemd></item>

<item><itemt>PatchFile</itemt>
<itemd>
<p>
Syntax für dieses Feld ist die gleiche wie für das Feld <code>Patch</code>.
Der komplette Pfad für diese Datei erhält man über die Prozenterweiterung
<code>%{PatchFile}</code>. Sie sollten <code>%a</code> nicht verwenden.
Im Unterschied zum Feld <code>Patch</code>, wird <code>PatchFile</code> im
Patch-Skript verwendet. Fink überprüft, ob die Datei existiert, lesbar ist und
seine Checksum mit dem Wert im Feld <code>PatchFile-MD5</code> übereinstimmt.
</p>
<p>
Man kann die Felder <code>Patch</code> und <code>PatchFile</code> in der
gleichen Paketbeschreibung verwenden. Jedes Paket, das das Feld
<code>PatchFile</code> verwendet, muss auch wenigstens
<code>BuildDepends: fink (&gt;= 0.24.12)</code> deklarieren. Muss man aus
anderen Gründen eine höhere Version angeben, ist dies auch in Ordnung.
</p>
</itemd></item>

<item><itemt>PatchFile<em>N</em></itemt>
<itemd>
<p>
Hat ein Paket mehrere Patch-Dateien, muss man sie in zusätzlichen Feldern
deklarieren, mit N = 2 anfangend. Die erste Patch-Datei steht als in
<code>PatchFile</code>, die zweite in <code>PatchFile2</code> uns so weiter.
Jedes Paket, das das Feld <code>PatchFile<em>N</em></code> verwendet, muss auch
wenigstens <code>BuildDepends: fink (&gt;= 0.30.0)</code> deklarieren.  Muss
man aus anderen Gründen eine höhere Version angeben, ist dies auch in Ordnung.
</p>
</itemd></item>

<item><itemt>PatchFile-MD5</itemt>
<itemd>
<p>
Hier steht die MD5-Checksum einer Datei des Felds <code>PatchFile</code>.
Dieses Feld ist obligatorisch, wenn man das Feld <code>PatchFile</code> benutzt.
(Eingeführt in Fink-0.24.12)
</p>
</itemd></item>

<item><itemt>PatchFile<em>N</em>-MD5</itemt>
<itemd>
<p>
Hier steht die MD5-Checksum einer Datei des Felds
<code>PatchFile<em>N</em></code>. Dieses Feld ist obligatorisch, wenn man das
Feld <code>PatchFile</code> benutzt.
(Eingeführt in Fink-0.30.0)
</p>
</itemd></item>

<item><itemt>PatchScript</itemt>
<itemd>
<p>
Eine Liste von Kommandos, die in der Patch-Phase ausgeführt werden. Hierhin
gehören Kommandos, mit denen man die Paketquellen patched oder irgendwie
modifiziert. Weitere Details dazu stehen weiter unten im Abschnitt
<xref chapter="reference" section="scripts">Anmerkungen zu Skripten</xref>.
Bevor die Kommandos ausgeführt werden, wird die
<xref chapter="format" section="percent">Prozenterweiterung</xref> ausgeführt.
Existiert das Feld <code>PatchFile</code>, ist das
Standard-<code>PatchScript</code>:
</p>
<codeblock>patch -p1 &lt; %{PatchFile}</codeblock>
<p>
Bei einem oder mehreren Feldern <code>PatchFile<em>N</em></code>, wird
entsprechend dem Bedarf folgendes an das Skript angehängt:
</p>
<codeblock>patch -p1 &lt; %{PatchFile<em>N</em>}</codeblock>
<p>
Gibt es kein Feld <code>PatchFile</code>, ist das Standardskript leer. Bei einem
expliziten Feld <code>PatchScript</code> muss man auch die
<code>PatchFile(s)</code> explizit anwenden.
</p>
</itemd></item>

</itemtable>

<p><em>Compile-Phase:</em></p>

<!-- insert DefaultScript here ? -->

<itemtable>

<item><itemt>Set<em>ENVVAR</em></itemt>
<itemd>
<p>
Hiermit kann man Umgebungsvariablen für die Compile- und Installations-Phase
setzen. Damit kann man Compiler-Flags z. B. an Configure-Skripte und Makefiles
übergeben. Derzeit werden folgende Variablen unterstützt:
CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, DYLD_LIBRARY_PATH, JAVA_HOME,
LD, LDFLAGS, LIBRARY_PATH, LIBS, MACOSX_DEPLOYMENT_TARGET, MAKE, 
MFLAGS, MAKEFLAGS.
Für den angegebenen Wert kann die Prozenterweiterung aus dem letzten Kapitel
genutzt werden: Ein häufiges Beispiel:
</p>
<codeblock>SetLDFLAGS: -Wl,-strip_dead_dylibs</codeblock>
<p>
Einige Umgebungsvariablen haben einen Standardwert. Gibt man für diese einen
Wert an, werden sie dem Standardwert voran gestellt.
Die vorbesetzten  Variablen und ihre Standardwerte sind:
</p>
<codeblock>CPPFLAGS: -I%p/include
LDFLAGS: -L%p/lib</codeblock>
<p>
Beginnend mit Fink 0.26.0, gibt es eine Ausnahme von diesen Standards:
Ist der <code>Type: -64bit</code> auf <code>-64bit</code> gesetzt, dann ist der
Standardwert von <code>LDFLAGS</code> auf <code>-L%p/%lib -L%p/lib</code>
gesetzt.
</p>
<p>
MACOSX_DEPLOYMENT_TARGET ist auf einen Standardwert gesetzt, der von der
Version von OS X abhängt, aber setzt man es für ein Paket auf einen anderen
Wert, so wird der Standardwert überschrieben.
</p>

</itemd></item>

<item><itemt>NoSet<em>ENVVAR</em></itemt>
<itemd>
<p>
Setzt man dies auf wahr (true), dann werden die Standardwerte für die Variablen
mit Voreinstellungen (wie CPPFLAGS, LDFLAGS, CXXFLAGS) nicht gesetzt. Soll zum
Beispiel LDFLAGS nicht gesetzt werden, erreicht man dies mit
<code>NoSetLDFLAGS: true</code> .
</p>
</itemd></item>
<item><itemt>UseMaxBuildJobs</itemt>
<itemd>
<p>
Wenn auf wahr (true) gesetzt, wird <code>-j<em>N</em></code> für das
Compile-Skript und das Test-Skript an die Umgebungsvariable MAKEFLAGS angehängt.
N ist der Wert des Felds MaxBuildJobs in der Datei
<filename>fink.conf</filename>. Dieser Wert wird an die Variable MAKEFLAGS auch
angehängt, wenn das Feld <code>NoSetMAKEFLAGS: true</code> gesetzt ist. Ab der
Fink-Version 0.31.2 ist die Voreinstellung <code>True</code>, wenn das Feld
nicht angegeben oder leer ist.
</p>
</itemd></item>

<item><itemt>BuildAsNobody</itemt>
<itemd>
<p>
Ab Version 0.33.0 wird Fink als <code>root</code> und nicht als Nutzer
<code>fink-bld</code> mit wenigen Privilegien ausgeführt, wenn das Feld
<code>BuildAsNobody</code> auf <code>false</code> gesetzt ist.
Ist das Feld nicht vorhanden, ist die Voreinstellunge für den Wert wahr
<code>true</code>, das Paket wird also als Nutzer <code>fink-bld</code>
erstellt.
</p>
<p>In früheren Versionen von Fink bleibt dieses Feld folgenloss.</p>
</itemd></item>

<item><itemt>ConfigureParams</itemt>
<itemd>
<p>
Zusätzliche Parameter, die an das Configure-Skript durchgereicht werden.
(Weitere Details dazu gibt es beim Compile-Skript)
Außer für Pakete des Typs <code>Type: Perl</code> wird der Parameter
<code>--prefix=%p</code> dem Wert vorangestellt.
Ab Fink > 0.13.7 funktioniert dieses Feld auch für Perlmodule mit dem Feld
<code>Type: Perl</code>; der Perl-Standard Makefile.PL wird dem Wert des Felds
<code>ConfigureParams</code> voran gestellt.
</p>
<p>
Sind bei der Paketserstellung die Test-Suites aktiviert wird der Wert des Felds
<code>TestConfigureParams</code> den normalen <code>ConfigureParams</code>
Werten angehängt.
</p>
<p>
Beginnend mit Fink-0.22.0 unterstützt dieses Feld auch Bedingungen. Die Syntax
ist die gleiche wie im Feld <code>Depends</code> und anderen Feldern mit
Paketlisten. Die Bedingungen gilt nur für das leerzeichenbegrenzte
&quot;Wort&quot; hinter der Bedingung. Ein Beispiel:
</p>
<codeblock>Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) --with-x11 --disable-shared</codeblock>
<p>
reicht die Parameter <code>--mandir</code> und <code>--disable-shared</code>
immer weiter, <code>--with-x11</code> aber nur für die -x11 Variante.
</p>
<p>
Dieses Feld unterstützt, Parameter in mehreren Zeilen mit einer
Mehrzeilen-Deklaration zu schreiben. Dieses Feld wird wie eine
Shell-Kommandozeile behandelt und benutzt <code>\</code>, um Zeilen zu trennen:
</p>
<codeblock>ConfigureParams: &lt;&lt;
	--mandir=%p/share/man \
	(%type_pkg[-x11]) --with-x11 \
	--disable-shared
&lt;&lt;</codeblock>
<p>
Beachten sie: Stellen sie bei mehreren Zeilen bedingte Parameter nicht in die
letzte Zeile. Ist die Bedingung falsch, dann wird der darauf folgende Parameter
nicht ausgewertet. Dieses führt dann zum Absturz der Shell.
</p>
</itemd></item>

<item><itemt>GCC</itemt>
<itemd>
<p>
Dieses Feld deklariert die GCC-ABI, die in diesem Paket von C++ Code genutzt
wird. (Es ist notwendig, weil sich die ABI zweimal änderte und jede Bibliothek,
die sie in ihrem C++ Code verlinken, muss mit der selben ABI kompiliert werden
wie ihr Code.)
</p>
<p>
Die erlaubten Werte sind:
<code>2.95.2</code> (oder <code>2.95</code>), <code>3.1</code>, <code>3.3</code>
und <code>4.0</code>.
So weit uns bekannt, wollen die Autoren von GCC die GCC-ABI irgendwann stabil
halten; wir können nur hoffen, dass sie sich nicht erneut ändert.
</p>
<p>
Das Feld GCC hat keine Voreinstellung an sich, denn es wird ignoriert, wenn es
nicht gesetzt ist. Es gibt aber für jeden Baum einen erwarteten Wert für GCC,
der dem g++ Compiler für diesem Baum entspricht.
Die erwarteten Werte für die verschiedenen Paketbäume sind:
<code>2.95</code> im Baum 10.1, <code>3.1</code> im Baum 10.2,
<code>3.3</code> in den Bäumen 10.2-gcc3.3, 10.3 und 10.4-transitional und
<code>4.0</code> in den Bäumen 10.4 und 10.7.
</p>
<p>
Beachten sie, dass der Compiler im Paket angegeben werden muss, wenn er von dem
erwarteten abweicht. Typischerweise wird der Compiler durch Setzen der Flags
CC oder CXX geändert. Es sollte auch eine Abhängigkeit von einem der
(virtuellen) gcc-Pakete angegeben werden.
</p>
<p>
Ab Version 0.13.8 von Fink wird die Version von gcc mit <code>gcc_select</code>
überprüft, wenn dieses Feld gesetzt ist. Liegt eine falsche Version vor, bricht
Fink mit einem Fehler ab.
</p>
<p>
Dieses Feld wurde in Fink eingerichtet, um Betreuern zu helfen, den Übergängen
zwischen den gcc Compilern zu folgen, die binäre Inkompatibilitäten zwischen
Bibliotheken einführte, die C++ Code enthalten, die aber nicht durch aus
Versionen erkannt werden kann.
</p>
</itemd></item>

<item><itemt>CompileScript</itemt>
<itemd>
<p>
Eine Liste von Kommandos, die in der Compile-Phase ausgeführt wird. Hierhin
gehören Kommandos, die ein Paket konfigurieren und compilieren. Weitere Details
dazu stehen weiter unten im Abschnitt
<xref chapter="reference" section="scripts">Anmerkungen zu Skripten</xref>.
Bevor die Kommandos ausgeführt werden, wird die
<xref chapter="format" section="percent">Prozenterweiterung</xref> ausgeführt.
Der Standard ist:
</p>
<codeblock>./configure %c
make</codeblock>
<p>
Dies ist für Pakete angemessen, die GNU autoconf benutzen. Für Pakete des Typs
perl (deklariert über das Feld Type) ohne Angabe der Perl-Version ist der
Standard ab Fink 0.13.4 folgender:
</p>
<codeblock>perl Makefile.PL PREFIX=%p \
  INSTALLPRIVLIB=%p/lib/perl5 \
  INSTALLARCHLIB=%p/lib/perl5/darwin \
  INSTALLSITELIB=%p/lib/perl5 \
  INSTALLSITEARCH=%p/lib/perl5/darwin \
  INSTALLMAN1DIR=%p/share/man/man1 \
  INSTALLMAN3DIR=%p/share/man/man3 \
  INSTALLSITEMAN1DIR=%p/share/man/man1 \
  INSTALLSITEMAN3DIR=%p/share/man/man3 \
  INSTALLBIN=%p/bin \
  INSTALLSITEBIN=%p/bin \
  INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>
Ist der Typ <code>perl $version</code> mit angegebener Perl-Version
(<code>$version</code> könnte beispielsweise 5.6.0 sein), dann wird der Standard
dieses:
</p>
<codeblock>perl$version Makefile.PL \
  PERL=perl$version PREFIX=%p \
  INSTALLPRIVLIB=%p/lib/perl5/$version \
  INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
  INSTALLSITELIB=%p/lib/perl5/$version \
  INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
  INSTALLMAN1DIR=%p/share/man/man1 \
  INSTALLMAN3DIR=%p/share/man/man3 \
  INSTALLSITEMAN1DIR=%p/share/man/man1 \
  INSTALLSITEMAN3DIR=%p/share/man/man3 \
  INSTALLBIN=%p/bin \
  INSTALLSITEBIN=%p/bin \
  INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>
wobei <code>$perlarchdir</code> für Versionen 5.8.0 und früher "darwin" ist und
"darwin-thread-multi-2level" für Versionen 5.8.1 und später.
</p>
</itemd></item>

<item><itemt>NoPerlTests</itemt>
<itemd> 
<p>
<em>Eingeführt in Fink > 0.13.7.</em>
Ein boolscher Wert speziell für Pakete mit Perl-Modulen. Wenn auf wahr gesetzt,
wird der Teil <code>make test</code> im <code>CompileScript</code> für dieses
bestimmte Perl-Modul-Paket ignoriert.
</p>
</itemd></item>

</itemtable>

<p><em>Test-Suites:</em></p>

<itemtable>

<item><itemt>InfoTest</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.25.</em>
Dieses Feld umfasst Informationen, die nur ausgeführt werden, wenn bei der
Erstellung eines Pakets die Test-Suites aktiviert sind. Es enthält andere
Felder. Ist es vorhanden, muss das Feld <code>TestScript</code> enthalten sein.
Alle anderen Felder sind optional. Die folgenden Felder sind innerhalb
<code>InfoTest</code> erlaubt:
</p>
<ul>
<li><code>TestScript</code>: Ein Skript, das die Test-Suite ausführt. Dieses
  Skript sollte mit einem Status 0 enden, wenn die Suite erfolgreich endet, mit
  einem Status 1 um Warnungen anzuzeigen oder jeder andere Wert, der Fehler
  anzeigt, die ernst genug für einen fatalen Abbruch sind. Wegen der
  Dreifach-Logik des Ausgangswert sollte er auf jeden Fall gesetzt werden.
  <code>make check</code> ist zum Beispiel ein schlechtes Skript, weil es mit
  dem Status 1 endet, wenn das Check-Ziel nicht existiert.
  <code>make check || exit 2</code> wäre schon ein besseres Skript.</li>
<li><code>TestConfigureParams</code>: Ein Wert, der an die
  <code>ConfigureParams</code> angehängt wird.</li>
<li><code>TestDepends</code> und <code>TestConflicts</code>: Listen der Pakete,
  die an Listen in <code>BuildDepends</code> oder <code>BuildConflicts</code>
  angehängt wird.</li>
<li><code>TestSource</code>: Extra Quellen, die für die Test-Suites benötigt
  werden. Alle verwandten Felder werden auch unterstützt. Man muss also auch
  <code>TestSource-MD5</code> oder <code>TestSource-Checksum</code> deklarieren. Die Felder <code>TestSourceN</code>
  und die entsprechenden Felder <code>TestSourceN-MD5</code>, <code>TestSourceN-Checksum</code>, 
  <code>TestTarFilesRename</code> usw. können ebenfalls vorhanden sein.</li>
<li><code>TestSuiteSize</code>: Beschreibt ungefähr wie lange das Ausführen der
  Test-Suites dauern wird. Erlaubte Werte sind <code>small</code>,
  <code>medium</code> und <code>large</code>. Gegenwärtig wird dieses Feld
  ignoriert.</li>
<li>Jedes andere Standardfeld. Ist ein Feld sowohl innerhalb als auch außerhalb
  von <code>InfoTest</code> deklariert, wird der Werte innerhalb von
  <code>InfoTest</code> den Wert von außerhalb ersetzen, wenn die Test-Suites
  aktiviert sind.</li>
</ul>
<p>Hier ein Beispiel:</p>
<codeblock>InfoTest: &lt;&lt;
    TestScript: make check || exit 2
    TestConfigureParams: --enable-tests
&lt;&lt;</codeblock>
</itemd></item>

</itemtable>

<p><em>Installationsphase:</em></p>

<itemtable>

<item><itemt>UpdatePOD</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.9.5.</em>
Ein boolscher Wert speziell Perl-Modul-Pakete.
Ist er auf wahr (true) gesetzt, wird Code zu den Skripten install, postrm und
postinst hinzu gefügt, der die .pod-Dateien aus den Perl-Paketen pflegt.
Dies schließt ein, das .pod-Datum in der zentralen Datei
<filename>/opt/sw/lib/perl5/darwin/perllocal.pod</filename> hinzu zu fügen oder
zu entfernen.
(Ist der Typ als <code>perl $version</code> mit einer bestimmten Perl-Version
wie 5.6.0 deklariert, werden diese Skripte angepasst, um die zentrale
.pod-Datei <filename>/opt/sw/lib/perl5/$version/perllocal.pod</filename> zu
bearbeiten.)
</p>
</itemd></item>

<item><itemt>InstallScript</itemt>
<itemd>
<p>
Die Liste der Kommandos, die in der Installationsphase ausgeführt werden. Hier
stehen die Kommandos, die alle notwendigen Dateien in das temporäre
dpkg-Verzeichnis für das Paket kopieren. Weitere Details dazu stehen weiter
unten im Abschnitt
<xref chapter="reference" section="scripts">Anmerkungen zu Skripten</xref>.
Bevor die Kommandos ausgeführt werden, wird die
<xref chapter="format" section="percent">Prozenterweiterung</xref> ausgeführt.
Normalerweise ist der Standard:
</p>
<codeblock>make install prefix=%i</codeblock>
<p>
Dies ist für Pakete angemessen, die GNU autoconf benutzen. Für Pakete des Typs
perl (deklariert über das Feld Type) ohne Angabe der Perl-Version ist der
Standard ab Fink 0.13.4 folgender:
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
  INSTALLARCHLIB=%i/lib/perl5/darwin \
  INSTALLSITELIB=%i/lib/perl5 \
  INSTALLSITEARCH=%i/lib/perl5/darwin \
  INSTALLMAN1DIR=%i/share/man/man1 \
  INSTALLMAN3DIR=%i/share/man/man3 \
  INSTALLSITEMAN1DIR=%i/share/man/man1 \
  INSTALLSITEMAN3DIR=%i/share/man/man3 \
  INSTALLBIN=%i/bin \
  INSTALLSITEBIN=%i/bin \
  INSTALLSCRIPT=%i/bin</codeblock>
<p>
Ist der Typ <code>perl $version</code> mit angegebener Perl-Version
(<code>$version</code> könnte beispielsweise 5.6.0 sein), dann wird der Standard
dieses:
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
  INSTALLARCHLIB=%i/lib/perl5/$version/$perlarchdir \
  INSTALLSITELIB=%i/lib/perl5/$version \
  INSTALLSITEARCH=%i/lib/perl5/$version/$perlarchdir \
  INSTALLMAN1DIR=%i/share/man/man1 \
  INSTALLMAN3DIR=%i/share/man/man3 \
  INSTALLSITEMAN1DIR=%i/share/man/man1 \
  INSTALLSITEMAN3DIR=%i/share/man/man3 \
  INSTALLBIN=%i/bin \
  INSTALLSITEBIN=%i/bin \
  INSTALLSCRIPT=%i/bin</codeblock>
<p>
wobei <code>$perlarchdir</code> für Versionen 5.8.0 und früher "darwin" ist und
"darwin-thread-multi-2level" für Versionen 5.8.1 und später.
</p>
<p>
Wenn das Paket es unterstützt, ist es besser, stattdessen
<code>make install DESTDIR=%d</code> auzuführen.
</p>
</itemd></item>

<item><itemt>AppBundles</itemt>
<itemd>
<p>
<em>Eingeführt in einer Version nach 0.23.1.</em>
Dieses Feld installiert das angegebene Applicationbundle bzw. mehrere im
Verzeichnis <filename>%p/Applications</filename>. Es wird auch ein Symlink im
Verzeichnis <filename>/Applications/Fink</filename> erzeugt.
Beispiel:
</p>
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
</itemd></item>

<item><itemt>JarFiles</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.10.0.</em>
Das Feld ist irgendwie ähnlich wie das Feld DocFiles. Damit werden die
angegebenen jar-Dateien ins Verzeichnis <filename>%p/share/java/%n</filename>
installiert.
Beispiel:
</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
<p>
Damit werden alle jars im Verzeichnis lib installiert; die Datei foo.jar als
fooBar.jar.
</p>
<p>
Es bewirkt auch, dass diese jar-Dateien (genau: alle Dateien in
<filename>%p/share/java/%n</filename> mit der Endung .jar) an die
Umgebungsvariable CLASSPATH angehängt werden. Damit können Tools wie configure
oder ant die installierten jar-Dateien feststellen.
</p>
</itemd></item>

<item><itemt>DocFiles</itemt>
<itemd>
<p>
Dieses Feld deklariert eine bequehme Art, Dateien wie README oder COPYING für
das Paket im doc-Verzeichnis <filename>%p/share/doc/%n</filename> zu
installieren. Der Wert ist eine leerzeichenseparierte Liste der Dateien. Man
kann Dateien aus Unterverzeichnissen des build-Verzeichnisses kopieren, aber sie
werden im doc-Verzeichnis und nicht einem Unterverzeichnis stehen. Shell
Wildcards sind erlaubt.
Es ist auch möglich, einzelne Dateien umzubenennen, indem man den neuen Namen
mit einem Doppelpunkt (:) anhängt, z. B.
<code>libgimp/COPYING:COPYING.libgimp</code>. Dieses Feld funktioniert, indem
entsprechende <code>install</code>-Kommandos im Installations-Skript angehängt
werden.
</p>
</itemd></item>

<item><itemt>Shlibs</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.11.0.</em>
Diess Feld deklariert dynamische Bibliotheken, die in dem Paket installiert
werden. Jede Bibliotheke steht in einer separaten Zeile die den
<code>install_name</code> der Bibliothek und Informationen über ihre binäre
Kompatibilität enthalten. Ist die Bibliothek öffentlich, steht in der Zeile auch
die <code>-compatibility_version</code>, Informationen zur Abhängigkeit mit
Version darüber, welches Fink-Paket die Bibliothek mit dieser
<code>compatibility_version</code> enthält und die Architektur der Bibliothek.
(Die Architektur der Bibliothek kann "32", "64" oder "32-64" sein oder ganz
fehlen. Ist sie nicht explizit angegeben, wird die Voreinstellung genommen, d.h.
"32" für PowerPC und i386 und "64" für x86_64.) Die Abhängigkeit sollte in der
Form <code>foo (>= version-revision)</code> angegeben sein, wobei sich
<code>foo (>= version-revision)</code> auf die <em>erste</em> Version des
Finkpakets bezieht, das diese Bibliothek (mit der compatibility version) zur
Verfügung stellte. Außerdem impliziert die Deklaration, dass der Betreuer
versichert, dass auch in späteren Versionen des Pakets eine Bibliothek mit
diesem Namen und dieser <code>-compatibility_version</code> angeboten wird.
Dem Namen von dynamischen Bibliotheken, die "privat" sein sollen, wird ein
Ausrufezeichen vorangestellt und keine Informationen zu Kompatibilität oder
Version werden angegeben. Weitere Details dazu stehen im Abschnitt
<xref chapter="policy" section="sharedlibs">dynamische Bibliotheken</xref>.
</p>
</itemd></item>

<item><itemt>RuntimeVars</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.10.0.</em>
Dieses Feld deklariert eine bequehme Art, Umgebungsvariablen für die Laufzeit
einen statischen Wert zuzuweisen (Benötigen sie mehr Flexibilität, schauen sie
im Abschnitt <xref section="profile.d">profile.d Skripte</xref> nach). Solange
das Paket installiert ist, werden diese Variablen im Skript
<filename>/opt/sw/bin/init.[c]sh</filename> gesetzt.
</p>
<p>
Der Wert ihrer Variablen kann Leerzeichen enthalten (Leerzeichen am Ende werden
abgeschnitten); Prozenterweiterung wird ausgeführt. In diesem Beispiel
</p>
<codeblock>RuntimeVars: &lt;&lt;
  SomeVar: %p/Value
  AnotherVar: foo bar
&lt;&lt;</codeblock>
<p>
werden zwei Umgebungsvariablen 'SomeVar' und 'AnotherVar' erzeugt und ihre Werte
auf '/opt/sw/Value' (oder wasauch immer ihr Präfix ist) und 'foo bar' gesetzt.
</p>
<p>
Dieses Feld funktioniert, in dem es die entsprechenden Kommandos im
Installations-Skript angehängt. Diese Kommandos fügen eine Zeile mit
setenv/export im Paket-Skript profile.d hinzu, so dass sie ihre eigenen
hinzufügen können, ohne dass sie überschrieben werden. Die Zeilen werden den
Skripten voran gestellt, so dass man die Variablen auch in den Skripten
verwenden kann.
</p>
</itemd></item>

<item><itemt>SplitOff</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.9.9.</em>
Erzeugen sie ein zweites Paket vom selben compile/install-Lauf. Schauen sie für
weitere Details im separaten Abschnitt
<link url="#splitoffs">Splitoff</link>
nach.
</p>
</itemd></item>

<item><itemt>SplitOff<em>N</em></itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.9.9.</em>
Dies ist genau so wie <code>SplitOff</code>, um dritte, vierte usw. Pakete vom
selben compile/install-Lauf zu erzeugen. Beginnend mit einer CVS-Version von
Fink nach 0.19.2 können sie beliebige (und nicht notwendigerweise aufeinander
folgende) Werte mit N ≥ 2 verwenden, aber keine Dubletten.
</p>
</itemd></item>

<item><itemt>Files</itemt>
<itemd>
<p>
<em>Eingeführt in Fink 0.9.9.</em>
Dieses Feld wird <em>nur</em> in den Feldern <code>SplitOff</code> oder
<code>SplitOff<em>N</em></code> verwendet. Es deklariert die Dateien und
Verzeichnisse, die vom Installationsverzeichnis des Pakets %I in das aktuelle
Installationsverzeichnis %i verschoben werden. Beachten sie, dass dies nach dem
Installations-Skript und dem Feld DocFiles des Elternpakets ausgeführt wird, aber
vor dem Installations-Skript und dem Feld DocFiles des aktuellen Pakets.
</p>
</itemd></item>

</itemtable>

<p><em>Erstellungsphase:</em></p>

<itemtable>

<item><itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
<itemd>
<p>
Diese Felder enthalten Shell-Skripte, die ausgeführt werden, wenn ein Paket
installiert, aktualisiert oder entfernt wird.
Fink fügt automatisch den Shell-Skript-Header
<code>#!/bin/sh</code> ein und ruft <code>set -e</code> auf, so dass ein Fehler
eines Kommandos zum sofortigen Abbruch des Skripts führt.
Fink fügt auch ein <code>exit 0</code> am Ende ein.
Will man einen Fehler anzeigen, sollte man das Skript mit einem anderen Wert als
Null beenden.
Der erste Parameter (<code>$1</code>) ist auf einen Wert gesetzt, der anzeigt,
welche Aktion ausgeführt wird.
einige der möglichen Werte sind <code>install</code>, <code>upgrade</code>,
<code>remove</code> und <code>purge</code>.
Beachten sie, dass es noch andere Werte gibt, die benutzt werden, um Fehler
zurück zu verfolgen und wenn Pakete gegenseitig ausgetauscht werden müssen.
</p>
<p>Die Skripte werden zu folgenden Zeitpunkten ausgerufen:</p>
<ul>
<li>PreInstScript: Wenn das Paket zum ersten mal installiert wird und bevor es
  auf diese Version aktualisiert wird.</li>
<li>PostInstScript: Nach dem Auspacken und Einrichten des Pakets.</li>
<li>PreRmScript: Bevor das Paket entfernt oder auf eine neue Version
  aktualisiert wird.</li>
<li>PostRmScript: Nachdem das Paket entfernt oder auf eine neue Version
  aktualisiert wird.</li>
</ul>
<p>
Klarstellung: Bei einer Aktualisierung werden sowohl die ...Inst-Skripte der
neuen Version als auch die ...Rm-Skripte der alten Version ausgeführt.
Details dazu kann man im Debian Policy Manual nachlesen, im
To make it more clear, an upgrade invokes both the ...Inst scripts of
the new version and the ...Rm scripts of the old version.
<link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">Kapitel 6</link>.
</p>
<p>
Prozenterweiterungen werden in diesen Skripten ausgeführt. Kommandos können ohne
den kompletten Pfad ausgeführt werden.
</p>
</itemd></item>

<item><itemt>ConfFiles</itemt>
<itemd>
<p>
Eine leerzeichengetrennte list an Dateien von Konfigurationsdateien, die vom
Nutzer geändert werden können.
Prozenterweiterungen werden ausgeführt.
Die Dateien müssen mit einem absoluten Pfad angegeben werden,
d. h. <filename>%p/etc/%n.conf</filename>.
Die genannten Dateien werden von dpkg besonders behandelt.
Wird ein Paket aktualisiert und die Datei wurde sowohl auf der Festplatte als
auch im Paket geändert, wird der Nutzer gefragt, welche Version genutzt werden
soll. Von den Dateien werden Sicherungskopien (backups) angelegt.
Wird ein Paket entfernt (removed), bleiben die Konfigurationsdateien auf der
Festplatte erhalten.
Nur ein "purge" entfernt auch die Konfigurationsdateien.
</p>
</itemd></item>

<item><itemt>InfoDocs</itemt>
<itemd>
<p>
Listet die Namen der Info-Dokumente, die das Paket in %p/share/info installiert.
Es wird entsprechender Code zu den Skripten postinst und prerm hinzugefügt, um
die Info-Verzeichnis-Datei <code>dir</code> zu aktualisieren.
</p>
<p>
<em>Anmerkung:</em> Nutzen sie nur die nicht-numerierten Dateien, wenn
Info-Dokumente ausgespalten werden. Hat z. B. ein Paket die Dateien
</p>
<codeblock>foo.info
foo.info-1
foo.info-2</codeblock>
<p>sollten sie nur diese aufführen:</p>
<codeblock>InfoDocs: foo.info</codeblock>
<p>
Dieses Feature ist immer noch im Fluss. Es können in Zukunft durchaus weitere
Felder für eine feinere Steuerung hinzu gefügt werden.
</p>
</itemd></item>

<item><itemt>DaemonicFile</itemt>
<itemd>
<p>
Liefert Service-beschreibungen für <code>daemonic</code>.
<code>daemonic</code> wird von Fink benutzt, um StartupItems für daemon-Prozesse
(z. B. Web-Server) einzurichten oder zu entfernen.
Die Beschreibung wird dem Paket als Datei mit dem Namen
<code>%p/etc/daemons/<em>Name</em>.xml</code> hinzu gefügt, wobei <em>Name</em>
im Feld DaemonicName angegeben wird und als Standard den Paketnamen hat.
Prozenterweiterungen werden für dieses Feld ausgeführt.
Beachten sie, dass sie <code>daemonic</code> zur Liste im Feld dependency
hinzu fügen müssen, wenn ihr Paket es benutzt.
</p>
</itemd></item>

<item><itemt>DaemonicName</itemt>
<itemd>
<p>
Ein Name für die Datei der <code>daemonic</code>-Service-Beschreibung.
Weitere Details stehen in der Beschreibung ders Felds DaemonicFile.
</p>
</itemd></item>

</itemtable>

<p><em>Zusätzliche Angaben:</em></p>

<itemtable>

<item><itemt>Homepage</itemt>
<itemd>
<p>Die URL der Upstream-Homepage des Pakets.</p>
</itemd></item>

<item><itemt>DescDetail</itemt>
<itemd>
<p>
Eine ausführlichere Beschreibung des Pakets als im Feld <code>Description</code>
(was ist es und für was kann man es benutzen?).
Mehrfachzeilen sind hier erlaubt. Dieses Feld wird ohne Zeilenumbruch
dargestellt. Deshalb sollten sie manuell Zeilenenden einführen, um die
Zeilenlänge, wenn möglich, unter 79 Zeichen zu halten.
</p>
</itemd></item>

<item><itemt>DescUsage</itemt>
<itemd>
<p>
Dieses Feld ist für Informationen, die man für die Benutzung des Pakets benötigt
(Wie benutze ich es?), z. B. "Führen sie wmaker.inst einmal aus, bevor sie
WindowMaker benutzen".
Mehrfachzeilen sind hier erlaubt. Dieses Feld wird ohne Zeilenumbruch
dargestellt. Deshalb sollten sie manuell Zeilenenden einführen, um die
Zeilenlänge, wenn möglich, unter 79 Zeichen zu halten.
</p>
</itemd></item>

<item><itemt>DescPackaging</itemt>
<itemd>
<p>
Anmerkungen zum Erstellen der Paketbeschreibung. Sachen wie "Patches im
Makefile, damit alles an die richtige Stelle gepackt wird." kommen in dieses
Feld. Mehrfachzeilen sind hier erlaubt.
</p>
</itemd></item>

<item><itemt>DescPort</itemt>
<itemd>
<p>
Anmerkungen spezifisch für die Portierung des Pakets nach Darwin. Sachen, wie
"config.guess und libtool Skripte aktualisiert, -no-cpp-precomp ist nötig"
gehören hier her. Mehrfachzeilen sind hier erlaubt.
</p>
</itemd></item>

</itemtable>

</section>

<section name="splitoffs"><title>SplitOffs</title>
<p>
Ab Fink 0.9.9 kann eine einzige .info-Datei benutzt werden, um mehrere Pakete zu
erstellen.
Die Installationsphase beginnt wie üblich mit der Ausführung der Kommandos
<code>InstallScript</code> und <code>DocFiles</code>.
Ist ein Feld <code>SplitOff</code> oder <code>SplitOff<em>N</em></code>
vorhanden, werden weitere Installationsverzeichnisse angelegt. In den Feldern
<code>SplitOff</code> oder <code>SplitOff<em>N</em></code> werden die neuen
Installationsverzeichnisse mit %i abgekürzt, das Installationsverzeichnis des
Elternpakets mit %I.
</p>
<p>
In jedem Feld <code>SplitOff</code> und <code>SplitOff<em>N</em></code> müssen
bestimmte Felder vorhanden sein. Tatsächlich wird eine komplette Beschreibung
gespiegelt, bei der nur wenige Felder fehlen. Im folgenden die Felder, die in
den Unterbeschreibungen vorkommen können, nach Kategorien sortiert:
</p>
<ul>
<li>Start-Daten: Nur das Feld <code>Package</code> muss angegeben werden. Alle
  anderen Felder werden vom Elternpaket übernommen. Die Werte der Felder
  <code>Type</code> und <code>License</code> können innerhalb von
  <code>SplitOff</code> or <code>SplitOff<em>N</em></code> überschrieben werden.
  Prozenterweiterungen können benutzt werden. Oft ist es bequehm, für den Namen
  des Elternpakets %N zu verwenden.</li>
<li>Abhängigkeiten: Alle felder sind erlaubt.</li>
<li>Auspackphase, Patch-Phase und Compile-Phase: Diese Felder sind irrelevant
  und werden ignoriert.</li>
<li>Installationsphase und Build-Phase: Alle Felder sind erlaubt (außer dass
  SplitOffs keine weiteren SplitOffs enthalten können).</li>
<li>Zusätzliche Angaben: Sie werden vom Elternpaket geerbt. Die Werte können
  aber durch Deklaration des Felds in <code>SplitOff</code> oder
  <code>SplitOff<em>N</em></code> überschrieben werden.</li>
</ul>
<p>
%n-%v-%r wird als eindeutiger Bezeichner für ein Paket interpretiert. Deshalb
kann man das selbe <code>Paket</code> (mit der gleichen <code>Version</code> und
<code>Revision</code>) nicht als <code>SplitOff</code> (oder
<code>SplitOff<em>N</em></code>) deklarieren. Benutzen sie Varianten, müssen sie
beachten, dass jede Variante als unabhängiges Paket betrachtet wird. Die
folgende Konstruktion ist deshalb verboten:
</p>
<codeblock>Package: mime-base64-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4)
SplitOff: &lt;&lt;
  Package: mime-base64-pm-bin
&lt;&lt;</codeblock>
<p>
Während der Installationsphase werden zuerst die Felder
<code>InstallScript</code> und <code>DocFiles</code> des Elternpakets
ausgeführt. Danach werden die Felder <code>SplitOff</code> und
<code>SplitOff<em>N</em></code> prozessiert. In jedem SplitOff wird seinerseits
das Installscript ausgeführt. Das Feld <code>Files</code> bewirkt dann, dass die
aufgelisteteten Dateien und Verzeichnisse vom Installationsverzeichnis %I des
Elternpakets in das Installationsverzeichnis %i des SplitOff-Pakets. Danach
werden die Felder <code>DocFiles</code> und andere Installationsphasen-Felder
der <code>SplitOff</code> oder <code>SplitOff<em>N</em></code> Pakete
ausgeführt.
</p>
<p>
Zu diesem Zeitpunkt wird <code>SplitOff</code> ausgeführt (falls vorhanden) und
dann jedes Feld <code>SplitOff<em>N</em></code>, in der Reihenfolge der Zahl N.
Dies kann sich aber in Zukunft ändern. Folgendes Beispiel
</p>
<codeblock>SplitOff: &lt;&lt;
  Description: Some header files
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: All other header files
  Files: include/*
&lt;&lt;</codeblock>
<p>
funktioniert nur weil <code>SplitOff</code> vor <code>SplitOff2</code>
ausgeführt wird. Es ist deshalb besser, die Dateien explizit auf zu listen
(oder detailiertere Wildcards benutzen).
</p>
<p>
Während der Erstellungsphase werden die pre/post install/remove Skripte für
jedes SplitOff während der Erstellungsphase des jeweiligen SplitOff konstruiert,
je nachdem wie die Skripte für das SplitOff deklariert wurden.
</p>
<p>
Von jedem erstellten Paket wird verlangt, dass seine Lizenzierung im Verzeichnis
%i/share/doc/%n (das %n nimmt für jedes Paket einen anderen Wert an)
dokumentiert wird. Beachten sie, dass <code>DocFiles</code> die Dateien kopiert
und nicht verschiebt, so dass man identische Kopien der Dokumentation in jedes
Paket mehrfach installieren kann.
</p>

</section>

<section name="scripts"><title>Skripte</title>
<p>
In den Feldern PatchScript, CompileScript und InstallScript kann man
Shell-Skripte deklarieren, die dann ausgeführt werden. Das build-Verzeichnis
(<filename>%b</filename>) ist das aktuelle Verzeichnis, in dem die Skripte
ausgeführt werden. Sie sollten immer relative Pfadnamen oder
Prozenterweiterungen für  Dateien und Verzeichnisse in der Fink-Hierarchie
angeben und keine absoluten Pfadnamen. Zwei Formen werden unterstützt.
</p>
<p>
Dieses Feld kann ein einfache List von Kommandos sein, ähnlich zu einem
Shell-Skripte. Die Kommandos werden jedoch mit system() Zeile für Zeile
ausgeführt. Setzt man Variablen oder wechselt das Verzeichnis, wirkt sich dies
nur für eben diese eine Zeile aus. Beginnend mit einer CVS-Version nach
Fink-0.18.2 kann man lange Zeilen wie in Shell-Skripten auf mehrere umbrechen:
Ein Backslash (<code>\</code>) am Ende der Zeile ist das Zeichen für die
Fortsetzung in der nächsten Zeile.
</p>
<p>
Alternativ dazu kann man ein komplettes Skript mit einem Interpreter eigener
Wahl hier einfügen. Wie in jedem Unix-Skript muss die erste Zeile mit
<code>#!</code> anfangen, gefolgt vom kompletten Pfadnamen für den Interpreter
und alle benötigten Flags (z. B. <code>#!/bin/csh</code>,
<code>#!/bin/bash -ev</code>, usw.). In diesen Fällen wird das komplette Feld
*Script in eine temporäre Datei kopiert und dann ausgeführt.
</p>

</section>

<section name="patches"><title>Patches</title>
<p>
Braucht das Paket einen Patch, um für Darwin kompiliert zu werden (oder um mit
Fink zu funktionieren), benennen sie die Patch-Datei so wie die
Paketbeschreibung nur mit der Extension ".patch" statt ".info" und speichern sie
im gleichen Verzeichnis wie der .info-Datei.
Geben sie den Namen der Patch-Datei mit einer Zeile wie die folgende an:
</p>
<codeblock>PatchFile: %n.patch</codeblock>
<p>
(Für Pakette mit Varianten, kann es günstiger sein, <code>%{ni}.patch</code> zu
verwenden.)
Sie müssen auch die MD5-Summe der Patch-Datei im Feld <code>PatchFile-MD5</code>
angeben und folgendes deklarieren:
<code>BuildDepends: fink (&gt;= 0.24.12)</code> (oder eine spätere Finkversion).
</p>
<p>
Wird das Feld <code>PatchFile<em>N</em></code> verwendet, ist es üblich, die
Datei <filename>%n-Zweck-des-Patch.patch</filename> zu benennen, damit man das
leichter verfolgen kann. Man muss auch das Feld
<code>PatchFile<em>N</em>-MD5</code> angeben und folgendes deklarieren:
<code>BuildDepends: fink (&gt;= 0.30.0)</code> (oder eine spätere Finkversion).
</p>
<p>
Gibt es das Feld <code>PatchFile</code>, wird folgendes
Standard-<code>PatchScript</code>Skript ausgeführt:
</p>
<codeblock>PatchScript: patch -p1 &lt; %{PatchFile}</codeblock>
<p>
Mit <code>PatchFile<em>N</em></code> wird folgendes an das obige
Standard-<code>PatchScript</code> angehängt:
</p>
<codeblock>patch -p1 &lt; %{PatchFile<em>N</em>}</codeblock>
<p>
Dieses Standard-<code>PatchScript</code> wird überschrieben, wenn man ein
eigenes <code>PatchScript</code> deklariert (z. B. um eine Änderung in der
Patchdatei vorzunehmen, bevor sie angewandt wird).
</p>
<p>
Benötigt man in der Patch-Datei den vom Nutzer gewählten Präfix, wird empfohlen,
statt <code>/opt/sw</code> eine Variable wie <code>@PREFIX@</code> zu deklarieren
und so zu verwenden:
</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt; %{PatchFile} | patch -p1</codeblock>
<p>
Patches sollten im unidiff-Format sein und werden normalerweise mit folgendem
Kommandoerzeugt:
</p>
<codeblock>diff -urN &lt;originalsourcedir&gt; &lt;patchedsourcedir&gt;</codeblock>
<p>
Verwendet man emacs zum Edditieren der Dateien, kann man die Option
<code>-x'*~'</code> an das diff-Kommando anhängen, um automatisch erzeugte
Backup-Dateien zu unterdrücken.
</p>
<p>
Beachten sie bitte, dass sehr große Patches nicht in das CVS-Repository hoch
geladen werden sollten. Sie sollten auf einen web/ftp-Server hoch geladen und
in einem Feld <code>SourceN:</code> deklariert werden. Haben sie keinen
Webserver, können Administratoren von Fink die Datei auf der eigenen Seite von
Fink zur Verfügung stellen. Auch wenn ihr Patch größer als 30 KB ist, sollten
sie überlegen, einen separaten Downlaod zu erstellen.
</p>

</section>

<section name="profile.d"><title>Profile.d scripts</title>
<p>
Benötigt ihr Paket einige Initialisierungen zur Laufzeit (z. B. Setzen von
Umgebungsvariablen), können sie profile.d-Skripte verwenden.
Diese Skript-Fragmente werden durch die Skripte
<filename>/opt/sw/bin/init.[c]sh</filename> "sourced". Normalerweise werden alle
Fink-Nutzer diese Skripte in ihren Shell-Startup-Skripte
(<filename>.cshrc</filename> und ähnliche Dateien) laden.
Ihr Paket muss jedes Skript in zwei Varianten zur Verfügung stellen: Eine für
sh-kompatible Shells (sh, zsh, bash, ksh, ...) und eine für csh-kompatible
Shells (csh, tcsh). Sie müssen als
<filename>/opt/sw/etc/profile.d/%n.[c]sh</filename> installiert werden (wobei %n wie
üblich für den Paketnamen steht).
Es müssen auch ihre executable und read Bits gesetzt werden (d. h. sie müssen
mit -m 755 installiert werden). Ansonsten werden sie nicht korrekt geladen
werden.
</p>
<p>
Muss man nur einige Umgebungsvariablen setzen (z. B. QTDIR auf '/opt/sw'), kann man
das Feld RuntimeVars benutzen; eine bequehme Art, genau dies zu erreichen.
</p>

</section>

</chapter>

</document>
