<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">

<document filename="index" lang="ja" >
	<title>Fink パッケージの作成方法</title>
	<shorttitle>パッケージ作成</shorttitle>
	<cvsid>$Id: packaging.ja.xml,v 1.58 2021/05/27 20:26:32 nieder Exp $</cvsid>
	<preface>
		<p>
			このマニュアルではパッケージ管理システム Fink 用のパッケージ記述 (Package Description) の作成方法を解説します．
			また Fink ディストリビューションのポリシーとガイドラインも解説します．
			パッケージ記述の書式もディストリビューションのポリシーも共に発展途上です．
			&quot;Last changed&quot; (最終更新) 情報とこのページの CVS タグを確認することで，更新されているかがわかります．
			ここで扱うのはパッケージ管理システム Fink の「0.9.0 以降の開発版」で使われる書式とポリシーの説明です．
		</p>
		<p>
			Fink 用にパッケージを作成した場合，メーリングリスト
			<link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link> を購読するとよいでしょう．
			Fink に貢献する方法を探していて，関連分野のスキルをお持ちなら，是非とも
			<link url="http://pdb.finkproject.org/pdb/nomaintainer.php">現在メンテナのいないパッケージ</link>
			のメンテナンスをお願いいたします．
		</p>
	</preface>
	<chapter filename="intro">
		<title>始めに</title>
		<shorttitle>始めに</shorttitle>
		<section name="def1">
			<title>パッケージとは何か?</title>
			<p>
				パッケージとは，基本的単位を構成するソフトウェアのまとまりを指します．
				典型的なパッケージには，例えば実行可能プログラム，それが必要とするデータファイル，
				国際化のためのメッセージカタログ，そしてドキュメントが含まれます．
				Fink のパッケージには2種類の形式があります．
				すなわちパッケージ記述情報と，そのままインストール可能なバイナリパッケージファイルです．
			</p>
			<p>
				パッケージ記述情報は人でも読めるテキストファイルで，
				パッケージをビルドするために必要な (つまりバイナリパッケージファイルを作るのに必要な) 全ての情報を含みます．
				それにはメタデータ (パッケージ名や目的を記した文章) やソースコードの URL の他，
				パッケージの configure ，コンパイルやバイナリパッケージの生成に必要な命令が書かれています．
			</p>
			<p>
				バイナリパッケージファイルとは，パッケージを実際に構成する各ファイルのアーカイブを指し，
				中には実行可能プログラム，データファイル，メッセージカタログ，ライブラリ，インクルードファイルなどが含まれます．
				また，そのパッケージに関するメタデータも含まれます．
				バイナリパッケージは既にそのまま使用できる形式ですので，インストールとは主に中身の展開です．
				Finkはパッケージ管理システム dpkg の上に構築されたシステムですので，
				バイナリパッケージには dpkg の形式が使われ，拡張子は .deb です．
			</p>
		</section>
		<section name="ident">
			<title>パッケージの区別</title>
			<p>
				パッケージは3つの文字列で区別されます．
				すなわちパッケージ名，version と revision です．
				これらのいずれにも英小文字 (a から z)，数字 (0 から 9)， ダッシュ (-; 註: revision 中には使えません)，プラス (+)，ドット (.) のみが使えます．
				この他の字は使えません．
				特に，大文字と下線 (_) が使えないことに注意して下さい．
			</p>
			<p>
				「パッケージ名」にはソフトウェアの名前 (openssh など) をそのまま使います．
				version は「upstream バージョン」とも呼ばれますが，これには元となるソフトウェアパッケージのバージョンを使います．
				version には (2.9p1 のように) 数字以外を使っても構いません．
				Fink も dpkg もそれらを認識してソートできます．
				revision はカウンタで，最初は 1 で始まり，パッケージ記述情報への変更回数に応じて 1 ずつ増加します．
				「upstream バージョン」が変化すると再び 1 に戻ります．
				revision にダッシュを使ってはいけません．
				Fink パッケージの正式名称はパッケージ名，version と revision をダッシュでつないだもので，
				&quot;openssh-2.9p1-2&quot; などという形式になります．
			</p>
		</section>
	</chapter>
	<chapter filename="format">
		<title>パッケージ記述</title>
		<shorttitle>パッケージ記述</shorttitle>
		<section name="trees">
			<title>ツリーレイアウト</title>
			<p>
				パッケージ記述はディレクトリ <filename>/sw/fink/dists</filename> 下のディレクトリ <code>finkinfo</code> から読み込まれます．
				「ツリー」の設定はファイル <filename>/sw/etc/fink.conf</filename> にあり，これでどのディレクトリを読むかを指定します．
				パッケージ記述ファイルの名前は，Fink パッケージの正式名称に拡張子 &quot;.info&quot; を付けたものです．
				Fink 0.13.0 以降では，パッケージのアップデートの手間を省くための，
				「パッケージ名」に拡張子 &quot;.info&quot; を付けただけの簡略形式が便利です．
fink 0.26.0 の時点で，ファイル名を特定するにはいくつかの方法があります:
推奨されるのは，他の必要なパッケージファイルと整合性のとれる最も短いものです．
ファイル名の形式は: variant のないパッケージ名，オプションとして architecture，オプションとして distribution，オプションとして　version または version-revision を
ハイフンでつなぎ，&quot;.info&quot; で終えます．
&quot;architecture&quot; と &quot;distribution&quot; は，対応するフィールドが定義され，値を一つだけ持つ場合に限ります．
			</p>
			<p>
				パッケージ記述ツリーはいくつかの階層のディレクトリにまとめられています．
				最上段から順の説明:
			</p>
			<ul>
				<li>
					ツリーは <code>dists</code> から始まる．
					<code>dists</code> ディレクトリは Debian ツールで必須．
					最近の fink では，ディストリビューションのわかるディレクトリへの symlink になっている．
				</li>
				<li>
					ディストリビューション．
					<code>stable</code>, <code>unstable</code>, <code>local</code> に分かれる．
					ディレクトリ <code>local</code> は各システムの管理者とユーザが管理する．
					ディレクトリ <code>stable</code> と <code>unstable</code> は Fink システムの一部．
				</li>
				<li>
					ツリー．
					ツリー <code>main</code> にはパッケージの大部分が含まれる．
					２０１０年７月１日以前は，暗号を使うソフトウェアは別ツリー <code>crypto</code> に収められていたが，
					現在は <code>main</code> 以下の１セクションになっている．
				</li>
				<li>
					<code>finkinfo</code> または <code>binary-darwin-powerpc</code>．
					<code>finkinfo</code> は Fink のパッケージ記述とパッチを含み，
					<code>binary-darwin-powerpc</code> は <code>.deb</code> 形式のバイナリパッケージを含む．
				</li>
				<li>
					セクション．
					ツリー <code>main</code> は，管理しやすくするために種類別に分類されている．
				</li>
			</ul>
		</section>
		<section name="format">
			<title>ファイル形式</title>
			<p>
				パッケージ記述ファイルはキーと値の組 (別名「フィールド」) の単純なリストです．
				次のように，各行はキーで始まり，コロン (:) 以降が値になります:
			</p>
<codeblock>Key: Value</codeblock>
			<p>
				複数行に渡らざるを得ないフィールドには 2 通りの記法があります．
			</p>
			<p>
				1 つ目はシェルスクリプトで言う &quot;here-document&quot; 風の形式で，こちらの方が望ましいです．
				この方式では，第1行は，キー，コロンの次に値として <code>&lt;&lt;</code> が続くものになります．
				その後の行が全て実質的な値となり，行頭に <code>&lt;&lt;</code> を置いた行が値の終端区切りです．
				例:
			</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
			<p>
				この形式ではインデントを付けて構いません．
				その方が読みやすくなるでしょう．
			</p>
			<p>
				here-document 形式はネストできます．
				これはフィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> でよく使われます．
				これらのフィールドは他の (複数行の) フィールドを含むことができ，
				here-document 形式を使えば含まれる方のフィールドにも複数行の値が使えます．
				内側でも同じ区切り <code>&lt;&lt;</code> が使われます．
			</p>
<codeblock>
SplitOff: &lt;&lt;
    Package: %N-shlibs
    InstallScript: &lt;&lt;
        ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
    &lt;&lt;
&lt;&lt;
</codeblock>
			<p>
				この形式では，空行と，シャープ (#) で始まる行は無視されます．
				キー (フィールド名) では大文字と小文字の区別がないので，
				<code>InstallScript</code> を <code>installscript</code> や <code>INSTALLSCRIPT</code> とも書けますが，
				最初の <code>InstallScript</code> という方式が読み易いのでこれを使いましょう．
				真偽値を取るフィールドでは &quot;true&quot;, &quot;yes&quot;, &quot;on&quot;, &quot;1&quot; (大文字，小文字の区別なし)
				のいずれも「真」となり，それ以外は全て「偽」になります．
			</p>
		</section>
		<section name="percent">
			<title>パーセント展開</title>
			<p>
				簡便のため， Fink はいくつかのフィールドで以下の文字列展開をサポートします．
				曖昧さをさけるため，波括弧を使ってどの文字までがパーセント展開を受けるのかを明示できます．
				例えば <code>%{n}</code> は <code>%n</code> と同義です．
			</p>
			<itemtable labeld="" labelt="">
				<item>
					<itemt>%n</itemt>
					<itemd>
						<p>
							<em>n</em>ame．「パッケージ名」．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%N</itemt>
					<itemd>
						<p>
							<em>N</em>ame．親パッケージの「パッケージ名」． (<code>SplitOff</code> 内部以外では %n と同じ)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%e</itemt>
					<itemd>
						<p>
							<em>e</em>poch．パッケージの「エポック」．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%v</itemt>
					<itemd>
						<p>
							<em>v</em>ersion．「バージョン」．
						</p>
					</itemd>
				</item>

<item><itemt>%V</itemt>
<itemd>
<p>
パッケージの完全な <em>V</em>ersion で， Epoch がある場合にはこれも自動的に追加されます．
<code>InfoN</code> レベルが 4 以上の場合のみパーセント展開されるので，注意してください．
</p>
</itemd></item>

				<item>
					<itemt>%r</itemt>
					<itemd>
						<p>
							<em>r</em>evision．パッケージの「リビジョン」．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%f</itemt>
					<itemd>
						<p>
							<em>f</em>ull package name．%n-%v-%r と等価．
							エポックは <code>%f</code> に含まれない．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%p, %P</itemt>
					<itemd>
						<p>
							<em>p</em>refix．Fink のインストール場所．例: <filename>/sw</filename>．
							全てのユーザーが <filename>/sw</filename> に Fink をインストールしているわけではない．
							<code>%p</code> で正しいパスを取得する．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%d</itemt>
					<itemd>
						<p>
							<em>d</em>estination．パッケージ化するツリーのビルド先．
							例:<filename>/sw/src/fink.build/root-gimp-1.2.1-1</filename>
							この一時ディレクトリはパッケージをコンパイルする際のインストール段階でルートディレクトリの役を果たす．
							<filename>root-%f</filename> が <filename>%p/src</filename> の中にあることを当てにしてはいけない．
							ユーザが設定ファイル <filename>/sw/etc/fink.conf</filename> でフィールド <code>Buildpath</code>
							を指定すればこの場所は変わってしまう．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%D</itemt>
					<itemd>
						<p>
							<em>D</em>estination．
							親パッケージのビルド先 (<code>SplitOff</code> 内部以外では %d と同じ)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%i</itemt>
					<itemd>
						<p>
							完全な <em>i</em>nstall-phase prefix．インストール段階での一時インストールディレクトリの完全名． %d%p と等価．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%I</itemt>
					<itemd>
						<p>
							<em>I</em>nstall prefix．
							親パッケージのインストール段階での一時インストールディレクトリの完全名．
							%D%Pと等価 (<code>SplitOff</code> 内部以外では %i と同じ)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%a</itemt>
					<itemd>
						<p>
							p<em>a</em>tches．
							パッチを検索するディレクトリパス．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%b</itemt>
					<itemd>
						<p>
							<em>b</em>uild．
							ビルドディレクトリ．例: <filename>/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>
							<filename>%f</filename> が <filename>%p/src</filename> の中にあることを当てにしてはいけない．
							ユーザが設定ファイル <filename>/sw/etc/fink.conf</filename> でフィールド <code>Buildpath</code>
							を指定すればこの場所は変わってしまう．
							最も内側のディレクトリ名は， <code>Source</code> ファイル名か， (もしあれば) <code>SourceDirectory</code> 
							フィールドの値となります．
							ただし， <code>NoSourceDirectory</code> が <code>true</code>
							であれば使用されません．
						</p>
						<p>
							注記: %b は使わざるを得ないときだけ使用して下さい．
							ビルドディレクトリはスクリプトが実行されるときのカレントディレクトリです．
							コマンドでは相対パス名を使わなければいけません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%c</itemt>
					<itemd>
						<p>
							configure に渡すパラメータ: <code>--prefix=%p</code> の他，フィールド <code>ConfigureParams</code> で指定したもの全て．
(<code>Type: perl</code> を持つパッケージについては，挙動が異なる;
この場合，%c 中の <code>--prefix=%p</code> の代わりに，perl パッケージをビルドする既定フラグが用いられる．)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%m</itemt>
					<itemd>
						<p>
							<em>m</em>achine architecture．
							マシンアーキテクチャーを示す記号で，<code>uname -p</code> の出力．
							現在のところ， PPC マシンでは 'powerpc' ， x86 マシンでは 'i386' という値になる
							(0.12.1 CVS版以降の Fink で導入)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%%</itemt>
					<itemd>
						<p>
							パーセント記号そのもの (これ以降にどの文字が続いても展開されない)．
							展開は厳密に左から右に行われるので， %%n はパッケージ名とは一切関係なく，単なる文字列 %n を表すことになる．
							(fink-0.18.0 で導入)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%type_raw[<em>タイプ</em>], %type_pkg[<em>タイプ</em>],
					%type_num[<em>タイプ</em>]</itemt>
					<itemd>
						<p>
							指定された <em>タイプ</em> のサブタイプを返す疑似ハッシュ．
							詳細は後述のフィールド <code>Type</code> の解説を参照．
							_raw 形式はサブタイプの文字列をそのまま返すが， _pkg 形式はドット (.) を 全て取り除いた文字列を返す．
							(Fink のパッケージ命名規約の「プログラミング言語-バージョン」方式に使う．他にもうまい使い方があるかも)．
							(0.19.2 CVS 版以降の Fink で利用可能)
_num 式 は fink-0.26.0 より導入．
<code>Type</code> から数字以外を全て除く．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%{ni}, %{Ni}</itemt>
					<itemd>
						<p>
							&quot;<em>n</em>ame <em>i</em>nvariant&quot;．
							%n や %N と似ているが， %type_pkg[] と %type_raw[] に当たる部分は全て空白に変わる．
							(0.19.2 CVS 版以降の Fink で利用可能)
							%n や %N を使った際の混乱を避けるためには %{ni} や %{Ni} を使うこと．
						</p>
					</itemd>
				</item>
				
				<item>
					<itemt>%{default_script}</itemt>
					<itemd>
						<p>
							<code>PatchScript</code>, <code>CompileScript</code> および <code>InstallScript</code> フィールドでのみ有効で，
							デフォルトの値．
							値は <code>Type</code> に依存するが，常に存在する（または空欄）．
							<code>SplitOff</code> (または <code>SplitOff<em>N</em></code>) 中の <code>InstallScript</code> で使われる場合，
							<code>SplitOff</code> パッケージの <code>InstallScript</code> デフォルトが空欄であっても，
							この展開は<em>親</em>のデフォルトになる．
							
						</p>
					</itemd>
				</item>
<item><itemt>%{PatchFile}</itemt>
<itemd>
<p>
<code>PatchFile</code> フィールドで示されたファイルのフルパス．
(fink-0.24.12 にて導入)
</p>
</itemd></item>

<item><itemt>%{PatchFile<em>N</em>}</itemt>
  <itemd>
    <p>
      <code>PatchFile<em>N</em></code> フィールドで示されたファイルのフルパス．
      (fink-0.30.0 にて導入)
    </p>
  </itemd></item>

<item><itemt>%lib</itemt>
<itemd>
<p>
<code>Type: -64bit</code>　が <code>-64bit</code>と定義されている場合，
powerpc マシン上では <em>lib/ppc64</em> と展開され，
intel マシン上では <em>lib/x86_64</em> と展開される (64-bit ライブラリの正しい保存場所)．
それ以外は， <em>lib</em> と展開される．
(fink-0.26.0 で導入)
</p>
<p>
<code>InfoN</code> レベルが 4 以上でないと，
<code>ConfigureParams</code> フィールド内での使用はできませんので，注意してください．
</p>
</itemd></item>

			</itemtable>
		</section>
	</chapter>
	<chapter filename="policy">
		<title>パッケージ化ポリシー</title>
		<shorttitle>ポリシー</shorttitle>
		<section name="licenses">
			<title>パッケージのライセンス</title>
			<p>
				Fink に含まれるパッケージのライセンスは多岐に渡ります．
				大部分は，ソース全体の再配布と，特に実行可能ファイルの配布に何らかの制限を課します．
				パッケージの中には，ライセンスのために Fink でバイナリ配布を行えないものもあります．
				そのため，パッケージのメンテナがライセンスを注意深くチェックすることが大変に重要です．
			</p>
			<p>
				バイナリ・パッケージとして配布される全てのパッケージは，ライセンスのコピーも含んでいなければいけません．
				ライセンスは doc ディレクトリすなわち <code>%p/share/doc/%n</code> にインストールされます．
				(InstallScript では，当然ながら %p でなく %i を使う必要があります．
				フィールド DocFiles ににより細部は自動的に処理されます．)
				元のソースに明示的なライセンスが存在しない場合，パッケージの状態を記した短いテキストを代わりとします．
				大半のライセンスは，ライセンスが配布物に必ず含まれるよう定めています．
				Finkのポリシーは「ライセンスを含めるよう明示的に要求されなくとも，常にライセンスを含める」ことです．
			</p>
			<p>
				バイナリディストリビューションのメンテナンスを自動化するため，
				配布されるどのパッケージにもフィールド <code>License</code> がなければいけません．
				このフィールドはライセンスの性質に関するもので，
				当該パッケージをバイナリディストリビューションに含めるかどうかを決定する際に参照されます．
				このフィールドは実際のライセンス条項が上記のようにバイナリパッケージに含まれているときのみ存在できます．
			</p>
			<p>
				フィールド License を有効に使用するため，値は以下の既定の選択肢からのみ選べます．
				下記の選択肢に当てはまらないパッケージの場合，開発用メーリングリストへ質問を投げかけて下さい．
			</p>
			<ul>
				<li>
					<code>GPL</code> - GNU General Public License．
					ソースがバイナリと同じ場所から入手できる必要がある．
				</li>
				<li>
					<code>LGPL</code> - GNU Lesser General Public License．
					ソースがバイナリと同じ場所から入手できる必要がある．
				</li>
				<li>
					<code>GPL/LGPL</code> -
					これは特殊な場合で，パッケージの一部 (実行可能プログラムなど) が GPL で，
					別の部分 (ライブラリなど) が LGPL になっているパッケージ．
				</li>
				<li>
					<code>BSD</code>  -
					BSD形式のライセンス．
					これには，いわゆる「オリジナル」 BSD ライセンス，「修正」 BSD ライセンスおよび MIT ライセンスが含まれる．
					The Apache lisence もこの一種とみなす．
					ソースコードを配布することは必須でない．
				</li>
				<li>
					<code>Artistic</code> -
					The Artistic lisence 及びその派生型．
				</li>
				<li>
					<code>Artistic/GPL</code> -
					The Artistic lisence と GPL のデュアルライセンス．
				</li>
				<li>
					<code>GNU Free Documentation License</code> および <code>Linux Documentation Project</code> -
					付属ドキュメントが明示的にこのライセンスのどちらかを採用している場合，
					値に <code>/GFDL</code> と <code>/LDP</code> のいずれか，または両方を後置する．
					結果として以下の組合せが可能: &quot;GFDL&quot;, &quot;GPL/GFDL&quot;, &quot;LGPL/GFDL&quot;, &quot;GPL/LGPL/GFDL&quot;,
					&quot;LDP&quot;, &quot;GPL/LGPL/LDP&quot;.
				</li>
				<li>
					<code>DFSG-Approved</code> - 
					<link url="http://www.debian.org/social_contract.ja.html">Debian 社会契約</link> のガイドラインに沿ったソフトウェア
				</li>
				<li>
					<code>OSI-Approved</code> -
					<link url="http://www.opensource.org/">Open Source Initiative</link> が承認した，その他の Open Source ライセンス．
					OSI はバイナリとソースの自由な配布を許可するよう要求しています．
					デュアルライセンスのパッケージにとりあえずこの選択肢を選ぶこともできます．
				</li>
				<li>
					<code>Restrictive</code> -
					制限付きのライセンス．
					作者からソース形式で free use のために入手できるが，free redistribution は許可されないパッケージに使う．
				</li>
				<li>
					<code>Restrictive/Distributable</code> -
					ソースとバイナリの配布を許可するが制限のあるライセンス．
					当該パッケージが作者からソース形式で入手でき，ソースとバイナリの配布も許可されているが，
					Open Source ライセンスと認められない制限がある場合に使う．
				</li>
				<li>
					<code>Commercial</code> -
					制限付きの商用ライセンス．
					ソースやバイナリの自由な再配布を許可しない商用パッケージ (フリーウェアやシェアウェアなど) に使う．
				</li>
				<li>
					<code>Public Domain</code> -
					パブリックドメインの，すなわち作者がコードに対するコピーライトを放棄したパッケージ．
					この場合，パッケージにはライセンスが存在せず，だれが何をしても良い．
				</li>
			</ul>
		</section>
		<section name="openssl"><title>GPL と OpenSSL</title>
			<p>
				(2005年４月より施行)
			</p>
			<p>
				OpenSSL ライセンスが GPL と LPGL ライセンスが明らかに整合性を欠いていることから，
				openssl にリンクをしている fink パッケージのうち， GPL または LGPL ライセンスを使用しているものは
				&quot;Restrictive&quot; となります．
				Fink プロジェクトはこれらのパッケージをバイナリ配布しないことになりますが，利用者は自己判断でコンパイルすることができます．				
			</p>
			<p>
				パッケージメンテナは，元のパッケージライセンスを <code>DescPackaging</code> に記述してください．
			</p>
		</section>
		<section name="prefix">
			<title>基盤システムへの干渉問題</title>
			<p>
				Finkは基盤システムから分離したディレクトリにインストールされるアドオン・ディストリビューションです．
				パッケージは Fink のディレクトリ外にファイルをインストールしてはしてはいけません．
			</p>
			<p>
				他に方法がないときには例外が設けられます (XFree86 など)．
				この場合，パッケージはインストール前に既存のファイルを調べ，上書きの恐れがある場合はインストールを中止する必要があります．
				そのようなパッケージは， Fink ディレクトリ外にインストールしたファイルはそのパッケージが取り除かれるときに全て削除されること，
				あるいはそのようなファイルは残しても問題がないことを保証しなければいけません
				(すなわち，実行可能ファイルを呼び出す前にそれが存在するかどうか調べるなどする必要があります)．
			</p>
		</section>
		<section name="sharedlibs">
			<title>共有ライブラリ</title>
			<p>
				Fink は共有ライブラリに関して新しいポリシーを定め， 2002 年 2 月から施行しています．
				以下では Fink 0.5.0 と共に公布された，共有ライブラリについてのポリシー第 4 版です。
				これは、2006年12月の時点で、 64 bit ライブラリを扱うために、
				2008年1月時点で、プライベートな共有ライブラリを扱うために修正されています。
				(さらに、2008年6月に共有ライブラリを実行する暫定期間への参照を削除しました。)
				最初に要点をかいつまんで述べ，後から詳細に移ります．
			</p>
			<p>
				共有ライブラリをビルドするパッケージは，
				Fink ポリシーに従って共有ライブラリを扱う必要があります．
				すなわち以下の約束に従わなければいけません．
			</p>
			<ul>
				<li>
					コマンド <code>otool -L</code> (64bit ライブラリの場合は otool64 -L) を使い，各ライブラリの install_name ，互換性，バージョンが適切か確認する．
				</li>
				<li>
					共有ライブラリを別パッケージとし (例外は libfoo.dylib から install_name へのリンク) ，
					さらに，そうしてできた別パッケージにフィールド <code>Shlibs</code> を設ける．
				</li>
				<li>
					ヘッダと， libfoo.dylib からの最終的リンクを <code>BuildDependsOnly: True</code> となっているパッケージに入れ，
					他のパッケージが一切そのパッケージに依存しないようにする．
				</li>
			</ul>
<p>
パッケージはプライベートな共有ライブラリをインストールすることがあることに注意してください。
これは、他のパッケージからリンクされることを意図しています。
この場合、ライブラリは別パッケージになる必要があります。
共有ライブラリを含むパッケージは、<code>Shlibs</code> がなければなりません。
また、他のプログラムが誤ってリンクしないように、
メンテナは <filename>%i/lib</filename> (またはその 64 bit 版) 内にある主要ライブラリが 
libfoo.dylib からの最終的なリンクを保存しないよう努めてください。
</p>
			<p>
				このポリシーに反し，パッケージを分割しない場合には，フィールド <code>DescPackaging</code> に理由を記述しなければいけません．
			</p>
			<p>
				パッケージによっては，主パッケージと -shlib パッケージを作成するだけで済みます．
				しかしさらに別のパッケージが必要な場合もあります．
				新設されたフィールド <code>SplitOff</code> を使うとこの作業の手間が省けます．
			</p>
			<p>
				3つのパッケージに分ける必要があるとき，それらの命名法は，
				パッケージの実質的な中身がライブラリなのか (選択肢 1) 実行可能プログラムなのか (選択肢 2) によって変わります．
				選択肢 1 では次の構成を使います．
			</p>
			<itemtable labeld="Contents" labelt="Package">
				<item>
					<itemt>
						<code>foo-shlibs</code>
					</itemt>
					<itemd>
						<p>共有ライブラリ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo</code>
					</itemt>
					<itemd>
						<p>ヘッダ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo-bin</code>
					</itemt>
					<itemd>
						<p>実行可能プログラムなど</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				選択肢 2 では次の構成を使います．
			</p>
			<itemtable labeld="Contents" labelt="Package">
				<item>
					<itemt>
						<code>foo-shlibs</code>
					</itemt>
					<itemd>
						<p>共有ライブラリ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo-dev</code>
					</itemt>
					<itemd>
						<p>ヘッダ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo</code>
					</itemt>
					<itemd>
						<p>実行可能プログラムなど</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>詳細なポリシー</em>
			</p>
			<p>
				以下ではさらに詳しく解説します．
				ポリシーが実際に適用された例としては Fink パッケージ libpng, libjpeg や libtiff を参照して下さい．
			</p>
			<p>
				Darwin にポートされたソフトウェアは可能な限り共有ライブラリをビルドしなければいけません．
				(パッケージメンテナが，必要に応じて共有ライブラリの他に静的ライブラリもビルドすることは自由です．
				または，静的ライブラリのみを含むパッケージを登録することも問題ありません．)
				他のパッケージで使われると想定される共有ライブラリをビルドする場合，<em>ふたつの</em>相互関連する Fink パッケージを作成しなければいけません．
				それらの名称は例えば foo と foo-shlibs となります．
				共有ライブラリは foo-shlibs に，ヘッダは foo に入ります．
				これら 2 つのパッケージを単一の .info ファイルから作れます．
				それには後述のフィールド <code>SplitOff</code> を使います．
				(現実には3つ以上のパッケージに分割する必要がある場合も多いですが，
				この場合は <code>SplitOff2</code>, <code>SplitOff3</code> などを使えばだいじょうぶです．)
			</p>
			<p>
				共有ライブラリがビルドされるソフトウェアパッケージは、
				<em>メジャーバージョン番号</em> N がなければなりません。
				これは、共有ライブラリのファイル名にも含まれています (例 <filename>libbar.N.dylib</filename>)。
				「メジャーバージョン」は，ライブラリの API にパッケージ間で非互換な変更が加えられたときのみ変わることになっています．
				Fink では，名称は以下の要領で作成されます．
				すなわち， upstream パッケージ名が bar なら，そのFinkパッケージの名前は barN と barN-shlibs になります．
				(この規則が厳密に適用されるのは新規に作られるパッケージと「メジャーバージョン」が変わったパッケージのみです．)
				例えば既存の Fink パッケージ libpng の「メジャーバージョン」は 2 でしたが，最近， 3 に変わりました．
				そこで当面は libpng に関わる Fink パッケージは4種類あることになります:
				libpng, libpng-shlibs, libpng3, libpng3-shlibs です．
				libpng と libpng3 はどちらか片方しか同時にインストールできませんが，
				libpng-shlibs と libpng3-shlibs は同時にインストールできます．
				(これら 4 つのパッケージのビルドに必要な .info ファイルは 2 つだけであることに注意してください．)
			</p>
			<p>
				共有ライブラリ自身とそれに関わるファイルは，パッケージ barN-shlibs に入ります．
				また「インクルード」ファイルとその他のファイルはパッケージ barN に入ります．
				これら 2 つに重複して含まれるファイルがあってはならず，また barN-shlibs に含まれるどのファイルのパス名にも，
				何らかの形で「メジャーバージョン」 N が含まれなくてはいけません．
				多くの場合，パッケージは，典型的には <filename>%i/lib/bar</filename> や
				<filename>%i/share/bar/</filename> にインストールされるようなファイルを実行時に必要とします．
				そのときはインストール先パスを <filename>%i/lib/bar/N</filename> や
				<filename>%i/share/bar/N/</filename> に修正しなければいけません．
			</p>
			<p>
				「メジャーバージョン」が N であるようなパッケージ bar に依存するパッケージは，全て次の依存情報を使うことになります．
			</p>
<codeblock>
Depends: barN-shlibs
BuildDepends: barN
</codeblock>
<p>
他のパッケージが、barN 自体に依存することは許されていません。
(2002年2月以前からあるパッケージについては、まだそのような依存性になっているかもしれません。)
これは、他の開発者には真偽値で連絡されます。
</p>
<codeblock>
BuildDependsOnly: True
</codeblock>
			<p>
				共有ライブラリと実行可能プログラムの両方を含むパッケージの場合，実行可能プログラムが (ビルド時だけでなく) 実行時に必要であれば，
				それらの実行可能プログラムは barN-bin という名の第 3 のパッケージに分離されます．
				他のパッケージが barN-shlibs の他に barN-bin に依存しても構いません．
			</p>
			<p>
				「メジャーバージョン」が N の共有ライブラリをビルドするとき，その共有ライブラリの &quot;install_name&quot; が
				<filename>%p/lib/libbar.N.dylib</filename> になることが重要です．
				(install_name は，ライブラリに対し <code>otool -L</code>，64bit ライブラリの場合は <code>otool64 -L</code> を実行すれば分かります．)
				実際のライブラリファイルのインストール先は，
			</p>
<codeblock>
%i/lib/libbar.N.x.y.dylib
</codeblock>
			<p>
				でなければならず，パッケージ側では次のようにシンボリックリンクを貼らなければいけません．
			</p>
<codeblock>
%i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
%i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib
</codeblock>
			<p>
				install_name パスからと、リンクパスからの実際のライブラリ。
			(ライブラリが実際に install_name パスにインストールされる場合は、最初のものは不要です。こちらのほうが普通です。)
			</p>
			<p>
				静的ライブラリもビルドする場合，次の場所にインストールされることになります．
			</p>
<codeblock>
%i/lib/libbar.a
</codeblock>
			<p>
				パッケージが libtool を利用する場合，上記のことはほぼ自動的に処理されますが，
				どの段階でも処理が適切に行われたか確認する必要があります．
				また，共有ライブラリの current_version と compatibility_version が適切に定義されているかどうかも確認して下さい．
				(これらも <code>otool -L</code> または 64bit ライブラリの場合 <code>otool64 -L</code> で表示されます．)
			</p>
			<p>
				次に，ファイルを以下のように 2 つのパッケージに分類します．
			</p>
			<ul>
				<li>パッケージ barN-shlibs:
<codeblock>
%i/lib/libbar.N.x.y.dylib
%i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
%i/lib/bar/N/*
%i/share/bar/N/*
%i/share/doc/barN-shlibs/*
</codeblock>
				</li>
				<li>パッケージ barN:
<codeblock>
%i/include/*
%i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib
%i/lib/libbar.a
%i/share/doc/barN/*
必要に応じて，他のファイルも含める
</codeblock>
				</li>
			</ul>
			<p>
				どちらのパッケージにもライセンスに関する何らかの文書が必要ですが，それらを格納するディレクトリは異なることに注意して下さい．
			</p>
			<p>
				このことはフィールド <code>SplitOff</code> を使えば実際には非常に簡単です．
				以下に上の例を実現するためにどのように記述するか (の一部) を示します．
			</p>
<codeblock>
Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/libbar.N.x.y.dylib lib/libbar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;
</codeblock>
			<p>
				フィールド <code>SplitOff</code> の処理により，指定されたファイルとディレクトリが，
				メインパッケージのインストールディレクトリ %I から splitoff パッケージのインストールディレクトリ %i に移動します．
				(これは命名法とも似ています．
				すなわち，%N がメインパッケージの「パッケージ名」で，%n が splitoff パッケージの「パッケージ名」でしたね．)
				次に <code>DocFiles</code> によりドキュメントファイルが <filename>%i/share/doc/barN-shlibs</filename> にコピーされます．
			</p>
			<p>
				barN-shlibs の正確な「バージョン」
				を親パッケージ barN の依存情報に含めたことに注意して下さい
				 (これは &quot;%N-shlibs (= %v-%r)&quot; と略記できます)．
				これにより「バージョン」が確かに適合するようになり，
				さらにパッケージ barN がパッケージ barN-shlibs の依存情報を自動的に「継承する」ことを保証します．
			</p>
			<p><em>フィールド BuildDependsOnly:</em></p>
			<p>
				ライブラリがアップグレードされる場合，移行期に二つのバージョンのヘッダファイルが必要になる時もあるでしょう．
				一つのバージョンはコンパイル時に使われ，もう一つは他のコンパイルに使われるような場合です．
				このため，ヘッダファイルを含むパッケージの作成には注意が必要となります．
				foo-dev と bar-dev が重複するヘッダを含む場合， foo-dev で，
			</p>
<codeblock>
   Conflicts: bar-dev
   Replaces: bar-dev
</codeblock>
			<p>
				と宣言し，同様に bar-dev では foo-dev を Conflicts/Replaces として宣言します．
			</p>
			<p>
				さらに，両方のパッケージで
			</p>
<codeblock>
   BuildDependsOnly: True 
</codeblock>
			<p>
				を宣言します．
				これにより，foo-dev または bar-dev に依存してパッケージを記述することを防ぐことができます．
				このような依存性が Conflicts/Replaces 手段を実行することを防ぐためです．
			</p>
			<p>
				ヘッダファイル付きのパッケージで， BuildDependsOnly を True にするのが適切ではないものもあります．
				この場合，そのパッケージでは
			</p>
<codeblock>
   BuildDependsOnly: False
</codeblock>
			<p>と宣言し，その理由を DescPackaging に記述します．</p>
			<p>
				BuildDependsOnly フィールドは，パッケージがヘッダファイルを含み /sw/include にインストールされる場合，
				パッケージの .info ファイルに記述されていなければなりません．
			</p>
			<p>
				fink 0.20.5 の時点で， &quot;fink validate&quot; とすることで，
				ヘッダファイルと，最低一つの dylib を含み， BuildDependsOnly 値で真偽を宣言していない .deb ファイルに警告を出します．
				(将来のバージョンでは，この機能をヘッダファイルと静的ライブラリに対応するように拡張する可能性もある．)
			</p>
<p>
  共有ライブラリのポリシーのゴールは，共有ライブラリを提供したパッケージと，それを使う別のパッケージとの互換性を保証することです．
  パッケージによっては，共有ライブラリが他のパッケージに使われることを想定せずに設計されていることもあります．
  一般的な例としては，プログラムスイートの裏方のライブラリや，
  機能を追加するためのプラグインのあるようなプログラムです．
  これらのライブラリは，そのパッケージにとって「プライベート」なので，
  -shlibs や <code>BuildDependsOnly</code> といった　SplitOff は必要ありません．
</p>
			<p><em>フィールド Shlibs:</em></p>
			<p>
共有ライブラリを適切なパッケージに分類する他にも， Fink ポリシー第4版では，
共有ライブラリ全てをフィールド <code>Shlibs</code> を使って宣言することが求められています．

このフィールドでは，各共有ライブラリに対して 1 行ずつ，
ライブラリの <code>-install_name</code>， 
ライブラリがパブリックである場合、その  <code>Shlibs</code> には <code>-compatibility_version</code> のリスト，
そのライブラリを提供する Fink パッケージを指定するバージョン付き依存性情報
(ただし -compatibility_version が同じでなければならない)，

そしてライブラリのアーキテクチャ (値は &quot;32&quot;, &quot;64&quot;, または
&quot;32-64&quot;, あるいは空欄; 空欄時の既定値は &quot;32&quot; ．) 

を記します．
依存性情報は <code>foo (&gt;= バージョン-版)</code> という形式で示します．
ここで <code>バージョン-版</code> にはこの (-compatibility_version が同じ) ライブラリを利用可能にしてくれる
Fink パッケージの<em>最初</em>の「バージョン」を使います．
例えば次の宣言は，
			</p>
<codeblock>
Shlibs: &lt;&lt;
%p/lib/libbar.1.dylib 2.1.0 bar1 (>= 1.1-2) 32
&lt;&lt;
</codeblock>
			<p>
				<code>-install_name</code> が %p/lib/libbar.1.dylib で <code>-compatibility_version</code> が 2.1.0 の (32bit) ライブラリが，
				Fink パッケージ <em>bar1</em> の「バージョン」1.1-2 以降でインストールされることを示します．
				それに加え，この宣言は「この名前がついていて compatibility_version が少なくとも 2.1.0 のライブラリは，
				Fink パッケージ bar1 の今後のバージョンには必ず含まれている」というメンテナからの保証にも相当します．
			</p>
			<p>
				ライブラリの名称には %p を使用するよう注意して下さい．
				これによって， Fink ユーザはインストールディレクトリに関係なく，正しい <code>-install_name</code> を検索できます．
			</p>
			<p>
				パッケージが更新されたとき，
				普通は次の「バージョン」または「版」のパッケージ記述にフィールド <code>Shlibs</code> をコピーするだけで構いません．
				例外は <code>-compatibility_version</code> が増加したときです．
				その場合，依存性情報の中の「バージョン-版」は新しい「バージョン」または「版」に従って更新されなければいけません．
				(新しい「バージョン」または「版」とは，
				新しい compatibility_version のライブラリを提供する最初の「バージョン」または「版」のことです．)
			</p>
<p>
プライベートなライブラリの <code>Shlibs</code> は，文法が異なります:
</p>
<codeblock>
  Shlibs: &lt;&lt;
    !%p/lib/%N/libbar.1.dylib
  &lt;&lt;
</codeblock>
<p>最初のビックリマークが，これはプライベートなライブラリであることを示しています．
この場合，他の情報は関係がないので，省略されています．</p>
<p>この例では，プライベートなライブラリが <filename>%i/lib</filename> 内の <filename>%N</filename> というサブディレクトリに保存されています．
これはパッケージ名で，他のパッケージが誤ってこのライブラリにリンクしないようにするものです．
</p>
			<p>
				<em>メジャーバージョン番号が変わるとき:</em>
			</p>
			<p>
				「メジャーバージョン」が N から M に変化したときは， 2 つの新しいパッケージ barM と barM-shlibs を作ることになります．
				パッケージ barM-shlibs と barN-shlibs に重複するファイルがあってはいけません．
				これは，多くのユーザにとって両方を同時にインストールする必要があるからです．
				パッケージ barM には以下の依存性情報を指定しなければいけません．
			</p>
<codeblock>
Conflicts: barN
Replaces: barN
</codeblock>
			<p>
				同様に barN の方も次の依存性情報を含むように改訂しなければいけません．
			</p>
<codeblock>
Conflicts: barM
Replaces: barM
</codeblock>
			<p>
				これにより，問題の共有ライブラリの片方のバージョンに依存する他の様々なパッケージがビルドされるときに
				barN と barM が入れ替わり入ってくるのを目にするでしょうが，
				barN-shlibs と barM-shlibs はいつまでもインストールしたままでいられます．
			</p>
			<p>
				<em>実行可能プログラムとライブラリの両方を含むパッケージ:</em>
			</p>
			<p>
				upstream パッケージが実行可能プログラムとパブリックライブラリの両方を含む場合，
				Fink パッケージを作成する際にいくつかの注意が必要です．
				唯一の実行可能プログラムが (恐らくビルド時のみに使われ，普段は使われない) foo-config のようなものという場合もあります．
				その場合，実行可能プログラムはヘッダファイルと共にパッケージ <code>foo</code> に入れて構いません．
			</p>
			<p>
				そうでない場合，実行可能プログラムは実行時に他の Fink パッケージから必要とされることになりますが，
				それらは <code>foo-bin</code> などの名前の個別の Fink パッケージに split off しなければいけません．
				パッケージ <code>foo-bin</code> はパッケージ <code>foo-shlibs</code> に依存しなければいけません．
				他パッケージのメンテナは，次のようにすることで
			</p>
<codeblock>
Depends: foo-bin
BuildDepends: foo
</codeblock>
			<p>
				明示せずに <code>foo-shlibs</code> を処理します．
			</p>
			<p>
				しかしこの場合，アップグレードは問題を起こします．
				ユーザは <code>foo-bin</code> をインストールするよう指示されないからです．
				この問題の回避のため，パッケージ <code>foo</code> に依存している全てのパッケージのメンテナがパッケージを上記のように改訂するまで，
				<code>foo</code> で次のようにして構いません．
			</p>
<codeblock>
Depends: foo-shlibs (= 正確な.バージョン), foo-bin
</codeblock>
			<p>
				こうすると， <code>foo</code> に依存する他のパッケージのメンテナが改訂を済ませるまで，
				ユーザのシステムでは大抵 <code>foo-bin</code> のインストールが要求されます．
			</p>
<p>
  fink-0.28.0 (released in January 2008) より，<code>Shlibs</code> の「プライベート」なライブラリの記述方法が変わりました．
  (上述のパブリックライブラリとプライベートライブラリの議論を参照)
  共有ライブラリのポリシーでは，常にすべての共有ライブラリを一覧化するよう定められています．
  ここで変わったのは，<code>Shlibs</code> フィールドの書き方だけです．
  プライベートなライブラリは，他のパッケージによって使われることを想定していないので，
  compatibility や他のバージョン情報は不要です．
  その代わりに先頭にビックリマークをつけます．
  例えば，あるプライベートな共有ライブラリの <code>install_name</code> が <filename>libquux.3.dylib</filename> である場合，
  以下のようになります．
</p>
<codeblock>
  Shlibs: &lt;&lt;
    !%p/lib/libquux.3.dylib
  &lt;&lt;
</codeblock>
		</section>
		<section name="perlmods">
			<title>Perl モジュール</title>
			<p>
				2003 年 5 月以来， Fink には Perl モジュールに対する新しいポリシーがあります．
				これは 2004 年 4 月に見直されました．
			</p>
			<p>
				伝統的に，perl モジュールの Fink パッケージには <code>-pm</code> が後置され，
				ディレクティブ <code>Type: perl</code> を使ってビルドされていました．
				このディレクティブは Perl モジュールのファイルを
				<filename>/sw/lib/perl5</filename> 及び/または <filename>/sw/lib/perl5/darwin</filename> に格納していました．
				現在のポリシーでは，それらのディレクトリには，コンパイルに使われる Perl のバージョンに依存しない 
				(また，このバージョン非依存性を欠いた Perl モジュールに依存しない)
				Perl モジュールのみを格納します．
			</p>
			<p>
				バージョンに依存する Perl モジュールはいわゆる XS モジュールであり，
				しばしば純粋な Perl コードの他に C コードからコンパイルされたファイルを含みます．
				このことを区別する方法はいくつもありますが，例えば拡張子 <code>.bundle</code> を持つファイルがあるかどうか調べる方法があります．
			</p>
			<p>
				Perl のバージョンに依存する Perl モジュールは該当バージョンの付いた Perl の実行可能プログラム (perl5.6.0 など)
				を使ってビルドされなければいけません．
				また，モジュールの含むファイルは，標準の Perl のディレクトリ内の，バージョンの付いたサブディレクトリ
				(<filename>/sw/lib/perl5/5.12.3</filename> や <filename>/sw/lib/perl5/5.12.3/darwin</filename> など) に格納しなければいけません．
				命名規約により，バージョン 5.12.3 に依存する Perl モジュールに <code>-pm5123</code> を後置します．
				格納場所と命名方法に関する同様の規約が他のバージョンの Perl に対しても有効で，
				perl 5.10.0 (10.6 ツリーのみ), 
				perl 5.12.4 (10.7 ツリーのみ),
				perl 5.16.2 (10.7 ツリーのみ)
				でもそのように対応されます．
			</p>
			<p>
				ディレクティブ <code>Type: perl 5.6.0</code> は自動的にバージョンの付いた Perl の実行可能ファイルを使い，
				できたファイルを適切なサブディレクトリに格納します．
				(このディレクティブは Fink 0.13.0 で導入されました．)
			</p>
			<p>
				<code>-pm</code> の付くパッケージも作成できます．
				これは本質的には「バンドル」パッケージで， <code>-pm560</code> 
				などの付く同等なパッケージなどをロードします．
				2004 年 4 月より，この方式は順次廃止されていきます
				(bootstrap に必要な <code>storable-pm</code> は例外です)．
			</p>
			<p>
				fink 0.20.2 の時点で， system-perl バーチャルパッケージは，
				システムに 5.8.0 以降の Perl がある場合，自動的に Perl モジュールを提供 (Provides) します．
				提供中の perl モジュール一覧を生成しているコードは、
				<code>fink</code> パッケージの中の
				<code>VirtPackage.pm</code> というファイルにあります。
			</p>
			<p>
				システム perl が異なると、提供するモジュールも変わります。
				パッケージメンテナは、提供されている perl モジュールを利用する場合には、
				正しい一覧を想定しているか確認することを勧めます。
			</p>
			<p>
				Fink 0.13.0 から利用可能になったコマンド <code>fink validate</code> を .deb ファイルに適用すると，
				その Fink パッケージが XS モジュールで，バージョンの付かないディレクトリにインストールされるかチェックし，そうなら警告を発します．
			</p>
<p>
ユーザーは，同時に複数のバージョンの perl をインストールしておくことができます．
このため， perl バージョン番号の指定されたモジュールは，複数のバージョンが共存できるようにインストールされなければなりません．
manpage やバイナリ，その他のスクリプトなど，これらのパッケージでのファイル名の重複を避けるよう，
注意を払わねばなりません．
-pm<em>XYZ</em> で終わるパッケージのどのファイルも，<em>XYZ</em> 値のことなる他のパッケージと同じパスを使用してはいけません．
<code>Replaces</code> を用いることで，同名のファイルがあっても異なる perl バージョンの perl モジュールは，以前は許可されていましたが，今後は許可されません．
manpage に関する解決として，2005年3月より，それぞれの perl-X.Y.Z に <filename>%p/lib/perl5/X.Y.Z/man</filename> という MANPATH を定義しました．
このため，-man や -doc といった SplitOff を作って対処する必要はなくなりました．
例えば， uri-pm5124 と uri-5162 のコンフリクトの場合，どちらにもある <filename>URI.3pm</filename> という manpage は，
それぞれ <filename>%p/lib/perl5/5.12.4/man/man3/URI.3pm</filename> と 
<filename>%p/lib/perl5/5.16.2/man/man3/URI.3pm</filename> にインストールされます．
ただし，<code>Type: perl X.Y.Z</code> によるスクリプトは変更されていないので， <code>InstallScript</code> にてどこに mapnage をインストールするのかを記述する必要があります．
もし複雑なスクリプトを記述していないのであれば，既存のものを用い，ファイルを移動させるだけで済みます．
</p>
<codeblock>
%{default_script}
mv %i/share/man %i/lib/perl5/5.12.4
</codeblock>
<p>
これにより，全ての manpage が移動します．
もし manpage のうち一つのセクションを以上させたい場合 (例えばセクション3とモジュールの manpage を移し，セクション1のスクリプト manpage は移さない)，同様に:
</p>
<codeblock>
%{default_script}
mkdir -p %i/lib/perl5/5.12.4/man
mv %i/share/man/man3 %i/lib/perl5/5.12.4/man
</codeblock>
<p>
デモ用やユーティリティ的なスクリプトなどが <filename>%p/bin</filename> にある場合は，いくつかの解決方法があります．
一つ目の例は，これらのファイル (およびその manpage や 関連ファイル) を %N-bin という Splitoff とします．
<code>Conflicts</code> と <code>Replaces</code> のフィールドを用いることで，perl バージョンの異なる，同じファイルを含んでいる複数のパッケージが，相互に排他的になります．
利用者は，異なる perl バージョンのモジュールを複数インストールしておき，スクリプトに関しては一つの perl バージョンのものだけを選択することになります．
例えば，Tk.pm は <filename>ptksh</filename> と共に来ますが，tk-pm* パッケージは以下のように作られます:
</p>
<codeblock>
Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4 5.16.2)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
&lt;&lt;
SplitOff: &lt;&lt;
  Package: %N-bin
  Depends: %N
  Conflicts: %{Ni}5.12.3, %{Ni}5.12.4, %{Ni}5.16.2
   Replaces: %{Ni}5.12.3, %{Ni}5.12.4, %{Ni}5.16.2
  Files: bin share/man/man1
&lt;&lt;
&lt;&lt;
</codeblock>
<p>
この他の方法としては，スクリプトの名称と，関連する manpage を，perl バージョン番号を示すように変更することがあります．
これでコンフリクトを回避できるので，相互排他的な %N-bin の Splitoff を作る必要はありません:
</p>
<codeblock>
Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4 5.16.2)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
  mv %i/bin/ptksh %i/bin/ptksh%type_raw[perl]
  mv %i/share/man/man1/ptksh.1 %i/share/man/man1/ptksh%type_raw[perl].1
&lt;&lt;
&lt;&lt;
</codeblock>
<p>
利用者は，どのバージョンの perl 用の ptksh も持っておくことができます．
<code>update-alternatives</code> を使用すると，利用者は一般的な (perl バージョンのない) 名前でもアクセスすることができ，便利です．
</p>
<p>
2005年3月の時点で，fink パッケージの perl 自体 (Apple が提供する perl バージョン以外の perlXYZ や perlXYZ-core) としては，manpage とモジュールの位置が変わりました．
このため，上位バージョンのコア perl モジュールを提供するパッケージは，perlXYZ や perlXYZ-core パッケージを <code>Replaces</code> フィールドに記述しないでください．
</p>
		</section>
		<section name="emacs">
			<title>Emacs ポリシー</title>
			<p>
				Fink プロジェクトでは Emacs について Debian プロジェクトのポリシーに従うことに決定しましたが，小さな違いもあります．
				(Debian プロジェクトのポリシーについては
				<link url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">
					http://www.debian.org/doc/packaging-manuals/debian-emacs-policy
				</link>
				を参照)
				Fink ポリシーとの違いは 2 点です．
				まず，このポリシーは Fink では現在のところパッケージ <filename>emacs21</filename>, <filename>emacs22</filename>, <filename>emacs23</filename> にのみ適用され，パッケージ xemacs には適用されません．
				(この点は将来変わるかも知れません．)
				次に Debian のポリシーと異なり， Fink パッケージはどれもファイルを直接
				<filename>/sw/share/emacs/site-lisp</filename> にインストールして構いません．
			</p>
		</section>



<section name="sources"><title>Source ポリシー</title>
    <p>
    ソースは、通常であれば upstream の開発者がつかっている場所からダウンロードされるべきであり、
    Fink 用の変更は、PatchFile または PatchScript の使用でする必要があります。
    Fink のパッケージでは、 ソースを変更して、変更済みソースアーカイブを <code>Source</code> に設定してはいけません。
    </p>
    <p>
    もし、プロジェクトは公式リリースを行っていない、
    あるいはリリース間に特定の修正のための追加など、
    CVS チェックアウト (<em>git</em> や <em>svn</em> など) が使われる場合、
    以下の要領で作成したソースを使用することができます:
    </p>
    <ol>
        <li>パッケージをチェックアウトする。できる限り VCS の限定リビジョンを使用。</li>
        <li>VCSチェックアウトからアーカイブ作成 (<em>zip</em>, <em>tar</em>, <em>tar.gz</em>, <em>tar.bz2</em> など)。
            <p>アーカイブは、固有のバージョンをつける。たとえば、アーカイブ名に VCS リビジョンをいれて、
            リリースしないパッケージであれば <filename>foo-0svn1234.tar.gz</filename> とし、
            upstream リリース間の Fink パッケージであれば <filename>bar-1.2.3+svn4567.tar.bz2</filename>
            とする。</p></li>
        <li>同じ <code>Version</code> を、 <filename>.info</filename> ファイルでも使う。</li>
        <li><code>DescPackaging</code> フィールドに、ソースアーカイブを生成するために実行したコマンドを書いておくと便利です。</li>
        <li>ユーザが <code>fink</code> を使ってダウンロードできる公開ダウンロードサイトにアーカイブをアップロードする。
        もし、そのようなサイトがない場合は、
        <link url="mailto:fink-devel@lists.sourceforge.net">Fink 開発者メーリングリスト</link> または
        <link url="https://web.libera.chat/">#fink IRC チャンネル</link>,
        に連絡してください。だれかが助けてくれるでしょう。</li>
    </ol>
</section>

<section name="downloading"><title>ファイルダウンロードのポリシー</title>
    <p>パッケージは、
    <xref chapter="reference" section="build">ビルドプロセス</xref>
    の unpack, patch, compile, install, build どの段階でもファイルをダウンロードしません。
    巨大なパッチ (例えば、PatchFile で扱うには大きすぎるもの)　は、
    <xref chapter="policy" section="sources">ソースポリシー</xref> に従ってソースとして設置してください。
    </p>
    <p>
    パッケージは、以下の条件下で、PostInstScript　でシステムにインストール後にデータをダウンロードしても構いません。
    </p>
    <ul>
        <li>パッケージ自身の更新は不可。</li>
        <li>
        データの性質上、Fink で容易にパッケージ化できないもの。
        例えば、 <filename>clamav</filename> のウイルス定義は、頻繁に更新されるので、この段階でダウンロードできます。
        </li>
    </ul>
    <p>もし不安があるなら、<link url="mailto:fink-core@lists.sourceforge.net">Fink Core
    Team</link>に相談してください。</p> 
</section>



	</chapter>
	<chapter filename="fslayout">
		<title>ファイルシステムのレイアウト</title>
		<shorttitle>ファイルシステム</shorttitle>
		<preface>
			<p>
				以下はファイルシステムのレイアウトのガイドラインで， Fink のパッケージ作成ポリシーの一部です．
			</p>
		</preface>
		<section name="fhs">
			<title>ファイルシステム構造標準 (Filesystem Hierarchy Standard)</title>
			<p>
				Fink は
				<link url="http://www.pathname.com/fhs/">
					ファイルシステム構造標準 (Filesystem Hierarchy Standard, 略して FHS )
				</link>
				の精神に従います．
				しかし従えるのは飽くまでも精神のみです．
				それは FHS が <filename>/</filename> 以下と <filename>/usr</filename> 以下の階層を管理できるシステムベンダ向けに作られたからです．
				Fink はインストールディレクトリ (別名「プリフィクス」) 以下のみを管理するアドオン・ディストリビューションです．
				以降の例ではデフォルトの「プリフィクス」 <filename>/sw</filename> を使います．
			</p>
		</section>
		<section name="dirs">
			<title>ディレクトリ</title>
			<p>
				ファイルは以下のサブディレクトリに保存します:
			</p>
			<itemtable>
				<item>
					<itemt>
						<filename>/sw/bin</filename>
					</itemt>
					<itemd>
						<p>
							一般的な実行可能プログラム用．
							サブディレクトリはなし．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/sbin</filename>
					</itemt>
					<itemd>
						<p>
							管理者のみが使うことを意図した実行可能プログラム用．
							バックグラウンドで動くデーモンもここに入る．
							サブディレクトリはなし．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/include</filename>
					</itemt>
					<itemd>
						<p>
							C と C++ のヘッダファイル用．
							必要に応じてサブディレクトリを作成してよい．
							標準の C ヘッダファイルと混同しそうなヘッダファイルをインストールする場合は<em>必ず</em>サブディレクトリに入れること．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/lib</filename>
					</itemt>
					<itemd>
						<p>
							アーキテクチャ依存のデータファイルやライブラリ用．
							静的および共有ライブラリは，避ける理由が特にない限り <filename>/sw/lib</filename> 直下に置きます．
							ユーザが直接起動することのない実行可能プログラム
							(普通なら <filename>libexec</filename> 下に置かれるはずのもの) もここに置きます．
						</p>
						<p>
							パッケージは，固有のデータやロード可能モジュールを保存するサブディレクトリを自由に作成できます．
							必ず互換性を考慮したディレクトリ名を使って下さい．
							賢明な方法は，そのサブディレクトリの名前にパッケージの「メジャーバージョン」を含めたり，
							「メジャーバージョン」をディレクトリ名にしたさらに深い階層を作ることです
							(<filename>/sw/lib/perl5</filename> や <filename>/sw/lib/apache/1.3</filename> など)．
							ディレクトリにホストの種類を使うときには注意が必要です．
							<code>powerpc-apple-darwin1.3.3</code> は，互換性の観点から問題があります．
							<code>powerpc-apple-darwin1.3</code> または単に <code>powerpc-apple-darwin</code> とします．
						</p>
					</itemd>
				</item>
<item><itemt><filename>/sw/lib/ppc64</filename>
<filename>/sw/lib/x86_64</filename></itemt>
<itemd>
<p>
このディレクトリは 64-bit ライブラリ用で，
powerpc アーチテクチャーでは <filename>/sw/lib/ppc64</filename> が，
i386 アーチテクチャーでは <filename>/sw/lib/x86_64</filename> が用いられます．
'fat' としてビルドされたライブラリは， <filename>/sw/lib</filename> に保存されます．
</p>
</itemd></item>
				<item>
					<itemt>
						<filename>/sw/share</filename>
					</itemt>
					<itemd>
						<p>
							アーキテクチャに依存しないデータファイル用で， <filename>/sw/lib</filename> と同じルールが当てはまります．
							よく使われるサブディレクトリについては後述します．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/man</filename>
					</itemt>
					<itemd>
						<p>
							man ページ用．
							この中は man のセクションに従って分類されます．
							<filename>/sw/bin</filename> と <filename>/sw/sbin</filename> の中の全てのプログラムには，
							対応した man ページがここになければいけません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/info</filename>
					</itemt>
					<itemd>
						<p>
							Texinfo ソースから生成される Info 形式のドキュメント用．
							索引ファイル <code>dir</code> のメンテナンスは
							Debian 版 <code>install-info</code> (パッケージ <code>dpkg</code> の一部) が自動的に行う．
							パッケージ記述のフィールド <code>InfoDocs</code> を使って，
							パッケージスクリプト <code>PostInst</code> 及び <code>PreRm</code> で使うための適切なコードを自動生成する．
							Fink は，それぞれのパッケージが勝手に <code>dir</code> ファイルを作成しないことを保証する．
							サブディレクトリはなし．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/doc</filename>
					</itemt>
					<itemd>
						<p>
							man でも Info でもないドキュメント用．
							README, LICENSE, COPYING はここに保存する．
							全てのパッケージは，ここに各「パッケージ名」に対応したサブディレクトリを作らなければいけない．
							名前には (「パッケージ名」そのものの一部でない限り) 「バージョン」を含めてはいけない．
							単に <code>%n</code> を使うとよいでしょう．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/locale</filename>
					</itemt>
					<itemd>
						<p>
							国際化で使うメッセージカタログ用．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/var</filename>
					</itemt>
					<itemd>
						<p>
							ディレクトリ <filename>var</filename> には変化するデータを保存する．
							(スプールディレクトリ，ロックファイル，状態のデータベース，ゲームのハイスコアやログファイルなど)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/etc</filename>
					</itemt>
					<itemd>
						<p>
							設定ファイル用．
							複数のファイルを使用するパッケージは，ここにサブディレクトリを作らなければいけない．
							区別のため，そのサブディレクトリにはパッケージまたはその中のプログラムの名前を付けなければいけない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/src</filename>
					</itemt>
					<itemd>
						<p>
							ソースコードを保存，ビルドするディレクトリ．
							パッケージはここに何もインストールしてはいけない．
						</p>
					</itemd>
				</item>
<item><itemt><filename>/sw/Applications</filename></itemt>
<itemd>
<p>このディレクトリには，コマンドラインから実行するのではなく，ダブルクリックで実行する OS X 型のアプリケーションを保存する．</p>
</itemd></item>
<item><itemt><filename>/sw/Library/Frameworks</filename></itemt>
<itemd>
<p>このディレクトリには，OS X 型のアプリケーションが使用する，OS X 型のフレームワークを保存する．</p>
</itemd></item>
			</itemtable>
		</section>
		<section name="avoid">
			<title>避けるべきこと</title>
			<p>
				<filename>/sw</filename> 下には，上述のもの以外ディレクトリを作ってはいけません．
				特に以下のディレクトリを作らないこと:
				<filename>/sw/man</filename>, <filename>/sw/info</filename>, <filename>/sw/doc</filename>,
				<filename>/sw/libexec</filename>, <filename>/sw/lib/locale</filename>
			</p>
		</section>
	</chapter>
<chapter filename="compilers">
<title>コンパイラ</title>
<shorttitle>コンパイラ</shorttitle>

<preface>
<p>
Fink は，Apple Developer Connection によってアップルコンピュータから提供される gcc コンパイラを使用しています．
バージョンはいくつかあり， Mac OS X システムでも通常は複数のバージョンが存在します．
</p>
<p>
<link 
url="http://www.mail-archive.com/fink-devel@lists.sourceforge.net/msg11877.html"
>より詳しい解説</link>がメーリングリスト中にあります．
</p>
</preface>

<section name="versions"><title>コンパイラバージョン</title>
<p>
GCC の発展に伴い，fink は &quot;ディストリビューション&quot; をつくって変化に対応してきました．
</p>
<p>
各 Fink ディストリビューションには，ソースからコンパイルするユーザー全員がもっていると想定されている
既定の gcc と g++ コンパイラがあります．
パッケージ中で直接 &quot;gcc&quot; や &quot;g++&quot; を使用すると，この既定値が使われます． 
これと違う値を使用する必要がある場合，(例えば，ディストリビューションの移行中に) パッケージ .info ファイルは
Apple 提供の特定バージョンのバイナリを指定しなければなりません．
どのように指定するかは，ソフトウェアのビルドシステムによりますが，多くの場合
<code>SetCC</code> と <code>SetCXX</code> のフィールドを使用します．
例えば，g++コンパイラのバージョンを 3.3 にするには，<code>SetCXX: g++-3.3</code> とします．
正しいコンパイラが使われているか，ビルド時の出力を確認してください．
</p>
<p>
10.1 ディストリビューションは，コンパイラに 2.95 の使用を前提とします．
10.2 ディストリビューションは，コンパイラに 3.1 の使用を前提とします．
10.2-gcc と 10.3 ディストリビューションは，コンパイラに 3.3 の使用を前提とします．
10.4-transitional ディストリビューションは複雑で，これは g++-3.3 と gcc-4.0 を使用しています．
10.4 と 10.5 ディストリビューションでは，gcc-4.0 と g++-4.0 を使用しています．
10.6 ディストリビューションでは，gcc-4.2 を使用しています．
10.7 から 10.9 ディストリビューションでは，clang と clang++ をデフォルトコンパイラとして使用しています．
10.9 では、さらに、libstdc++ から libc++ へ統合という変化があります。
</p>
<p>
正しい g++ コンパイラが使用されるよう新手法が 10.4-transitional ディストリビューションから採用されました．
コンパイル時に，<code>/sw/var/lib/fink/path-prefix-g++-XXX</code> (XXX はバージョン番号) 
ディレクトリが PATH に追加されます．
このディレクトリには正しいコンパイラと正しいバージョンの g++ が使われるようなシェルスクリプトが入っています．
</p>

</section>
<section name="abi"><title>g++ ABI</title>
<p>
OS X の歴史の中で，g++ ABI は３度変わってきました: ABI は バージョン 2.95, 3.1, 3.3, 4.0 で異なります．
ABI の相違は互換性がなく，C++ コードを用いたライブラリにリンクする場合は，同じ ABI でコンパイルしなければなりません．
</p>
<p>
Fink では，g++ ABI は GCC フィールドで扱っています．
g++ あるいは c++ コンパイラを呼び出すパッケージは，GCC フィールドを定義しなければなりません
(逆に，呼び出さないパッケージには定義してはいけません)．
ABI が更新された場合，パッケージ依存性に GCC フィールドも確認しなければいけません．
依存するパッケージ全てがアップグレードされて，始めてそのパッケージもアップグレードすることができます．
ユーザーがパッケージをビルドするより前に正しく更新された依存性を持つためには，依存パッケージのバージョンを変える必要があります．
</p>
<p>
ある範囲内でのみ依存されているパッケージは，アップグレードの準備ができない場合，
ディストリビューション変更時に旧バージョンの ABI を使用することもできます．
アップグレードされる場合は，範囲内の全てのパッケージを同時に正しいバージョンにアップグレードする必要があります．
このため，ほとんどのパッケージにとって，アップグレードはディストリビューションの変更時にするのがよいでしょう．
</p>
<p>
Fink は GCC フィールドを使って，ユーザーが正しいコンパイラを使うよう確認します．
GCC フィールドがパッケージによって定義されている場合，
その値が OS X バージョンにあっているか確認します。
(10.2 と 10.3 での正しい値は　3.3 で，
10.4 から 10.9 までの正しい値は　4.0 です．)
</p>

</section>

</chapter>

	<chapter filename="reference">
		<title>リファレンスマニュアル</title>
		<shorttitle>リファレンス</shorttitle>
		<section name="build">
			<title>ビルドプロセス</title>
			<p>
				各フィールドの意味を理解するには， Fink のビルドプロセスに関する知識がある程度必要です．
				このプロセスは 5 段階になっていて，それぞれ解凍段階，パッチ段階，コンパイル段階，インストール段階，ビルド段階 と呼ばれます．
				下記の例では <filename>/sw</filename> にパッケージ gimp-1.2.1-1 をインストールするものとします．
			</p>
			<p>
				<em>解凍段階</em>では，ディレクトリ <filename>/sw/src/fink.build/gimp-1.2.1-1</filename> が作成されてソースの tarball がそこに解凍されます．
				大抵，解凍によりソースを含むディレクトリ <filename>gimp-1.2.1</filename> が作られます．
				これ以降のステップはすべてこの中 (すなわち <filename>/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>) で行われます．
				詳細はフィールド SourceDirectory, NoSourceDirectory や Source<em>N</em>ExtractDir (Nは数字) で変更できます．
			</p>
			<p>
				<em>パッチ段階</em>では Darwin でビルドするためのパッチがソースに当てられます．
				フィールド UpdateConfigGuess, UpdateLibtool, Patch や PatchScript で指定されたアクションを，この順で実行します．
			</p>
			<p>
				<em>コンパイル段階</em>ではソースの configure とコンパイルが行われます．
				普通はスクリプト <code>configure</code> を適切な引数で起動し，コマンド <code>make</code> を実行することになります．
				詳細はフィールド CompileScript を参照して下さい．
				ビルドに対しテストスイートが有効な場合 (fink 0.25 の新しい機能で，現在メンテナモードでビルド中に適用される)，
				CompileScript の直後に TestScript が実行される．
			</p>
			<p>
				<em>インストール段階</em>では，パッケージは仮ディレクトリ
				<filename>/sw/src/fink.build/root-gimp-1.2.1-1</filename> (%d と同じ) にインストールされます
				(&quot;root-&quot; が付いていることに注意)．
				ディレクトリ <filename>/sw</filename> にインストールされる予定のファイルは全て，
				<filename>/sw/src/fink.build/root-gimp-1.2.1-1/sw</filename> (%i すなわち %d%p に同じ) にインストールされます．
				詳細はフィールド InstallScript を参照して下さい．
			</p>
			<p>
				(<em>Fink 0.9.9 で導入:</em>
				フィールド <code>SplitOff</code> を用いると，単一のパッケージ記述から複数のパッケージを生成できます．
				インストール段階の最後のあたりでパッケージそれぞれに対して個別のインストールディレクトリが作られ，
				ファイルが適当なディレクトリに振り分けられます．)
			</p>
			<p>
				<em>ビルド段階</em>では，仮ディレクトリからバイナリパッケージ (.deb ファイル) が作られます．
				この段階を直接制御することはできません．
				代わりに，パッケージ記述からの様々な情報を使って dpkg 用の <filename>control</filename> ファイルが作成できます．
			</p>
		</section>
		<section name="fields">
			<title>フィールド</title>
			<p>
				フィールドを分類して解説します．
				以下の一覧は完全ではありません．
				<code>:-)</code>
			</p>
			<p>
				<em>初期データ関連</em>
			</p>
			<itemtable>
				<item>
					<itemt>Package</itemt>
					<itemd>
						<p>
							「パッケージ名」．
							値には英小文字，数字及び ドット (.), プラス (+), ハイフン (-) を使うことができます．
							下線 (_) と英大文字は使えません．
							必須フィールド．
						</p>
						<p>
							このフィールドで行われるパーセント展開は %N, %{Ni}, %type_raw[] と %type_pkg[] のみです．
						</p>
						<p>
							Fink のパッケージ作成ポリシーでは，
							どのパッケージも常に同じオプションを有効にしてコンパイルされるようにします．
							あるパッケージに複数の variant を設ける場合は (フィールド <code>Type</code> の説明を参照)，
							variant を区別する情報をフィールド <code>Package</code> に含めなければいけません
							(パーセント展開 %type_pkg[] の説明を参照)．
							これにより，各 variant に固有の (どのオプションが有効かが分かる) 「パッケージ名」が与えられます．
							フィールド <code>Package</code> 内でパーセント展開 %type_pkg[] および %type_raw[] を使うことは最近導入されたばかりで，
							古い Fink とは非互換であるため，注意が必要です．
							そのため，そのようなパッケージ記述はフィールド <code>InfoN</code> (ただし N&gt;=2) 内に埋め込むようにします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Version</itemt>
					<itemd>
						<p>
							upstream のバージョン．
							値にはフィールド Package と同じ制限がある．
							必須フィールド．
						</p>
						<p>
							プログラムによっては被標準的なバージョン番号の付け方をしていて，ソートや当フィールドで認められていない字を使っている場合があります．
							このような状況では，上流のバージョンを適切にソートされるものに変えます．
							バージョン文字列のソートのされ方がわからない場合，<code>dpkg</code> コマンドをシェルで入力します．例えば，
						</p>
<codeblock> 
 dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo &quot;true&quot;
</codeblock>
						<p>
							これは &quot;1.2.1&quot; の方が &quot;1.3&quot; より小さいため &quot;true&quot; を出力します．
							詳細は <code>dpkg</code> man ページを参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Revision</itemt>
					<itemd>
						<p>
							Fink パッケージとしてのリビジョン．
							upstream のバージョンが同じパッケージのパッケージ記述を書き換えたら，ここを 1 ずつ増やします．
							最初は 1 で始めます．
							必須フィールド．
						</p>
						<p>
							Fink のポリシーでは，パッケージのバイナリ (コンパイル済み) 形式 (<filename>.deb</filename> ファイル)が変わる<em>いかなる</em>場合でも，<code>Revision</code> をあげなければ<em>なりません</em>．
							例えば，<code>Depends</code> や他のパッケージ一覧フィールド， Splitoff パッケージの追加・削除・名称変更， Splitoff パッケージ間でのファイルの移動など．
							パッケージのツリーを統合 (例えば 10.2 から 10.3) する場合，新しい方のツリーでは <code>Revision</code> を 10 (など，大きな数字) あげて古い方のツリーでのパッケージの更新に対応できるようにします．
 						</p>
					</itemd>
				</item>
<item><itemt>Architecture</itemt>
<itemd>
<p>
パッケージ (および Splitoff) が対応している CPU アーキテクチャー一覧を，コンマ区切りで記述します．
現在のところ，<code>powerpc</code> と <code>i386</code> が値として使用できます．
このフィールドがあり，値が条件処理後にブランクでなく，ローカルマシンのアーキテクチャーが一覧にない場合，パッケージ記述は無視されます．
このフィールドがない場合，あるいは値がブランクの場合は，全てのアーキテクチャーに対応していると見なされます．
(0.24.11 CVS バージョン以降 の fink に導入)
</p>
<p>
gcc-4.0 以前のコンパイラを使うパッケージ
(およびこれに依存するパッケージ)
の場合に <code>powerpc</code> と宣言するのが，
現在のところの主な使用方法です．
</p>
<p>
このフィールドでは，値一覧にある値とパーセント展開を，通常の条件文法で使うことができます
(詳細については，<code>Depends</code> フィールドを参照)．
これによって，特定の variant を特定のアーキテクチャーに制限することができます．
例えば:
</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.8 5.10.0)
  Architecture: (%type_pkg[perl] = 5100) x86_64
</codeblock>
<p>
によって，foo-pm5100 という variant は <code>x86_64</code> となり， foo-pm588 には値無しになります．
ただし，アーキテクチャーの値が無いことは，そのアーキテクチャー用のパッケージではない，ということではありません．
</p>
<p>
上の例は、このフィールドのよくある使い方です。
10.6 の system-perl 5.10.0 は 32-bit (i386) でビルドできないものがあるので、
複数タイプの perl パッケージを特定のシステムに限定することができます。
</p>
</itemd></item>



<item><itemt>Distribution</itemt>
<itemd>
<p>
パッケージ (およびその Splitoff パッケージ) が対応しているコンマ区切りのディストリビューション一覧。
現在、有効な値は
<code>10.4</code>,
<code>10.5</code>,
<code>10.6</code>,
<code>10.7</code>,
<code>10.8</code>,
<code>10.9</code>,
<code>10.10</code>,
<code>10.11</code>,
<code>10.12</code>,
<code>10.13</code>,
<code>10.14</code>,
<code>10.14.5</code>,
and <code>10.15</code>
です。
このフィールドがあり、条件式判定で空欄でなければ、
マシンのディストリビューションが書かれていなければ、
fink はパッケージ記述を無視します。
このフィールドが無いか、あってもブランクの場合、すべてのディストリビューションが想定されます。
(fink 0.26.0　で導入。)
</p>
<p>
<code>10.9</code>, <code>10.10</code>, <code>10.11</code>, <code>10.12</code>, <code>10.13</code>, <code>10.14</code>, <code>10.14.5</code> ディストリビューションは、
finkinfo ファイルが同じであるため、
これらのディストリビューションの一つに有効だが他ではそうでない場合が、このフィールドを使います。
</p>
<p>
このフィールドは、値リスト中の値とパーセント展開を条件式に使うことができます
(<code>Depends</code> に詳しい情報があります)。
これを使って、variant を特定のアーキテクチャに制限することができます。例えば:
</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.12.3 5.12.4)
  Distribution: (%type_pkg[perl] = 5123) 10.7, (%type_pkg[perl] = 5123) 10.8
</codeblock>
<p>
は、<code>Distribution</code> フィールドで foo-pm5123 は <code>10.7, 10.8</code>　用で、
foo-pm5124 は空欄であることになります。
</p>
<p>
10.7 以降では python 2.5 がなく、 perl のバージョンがディストリビューションによって異なるため、
これらのパッケージはこのフィールドをよく使います。
参照のため、10.3 から 10.14.5 までの利用可能な perl バージョンを記します
(<em>太字の</em> system はそのバージョンの system-perl です)。
</p>
<codeblock>
    perl 5.6.0:  10.3
    perl 5.8.0:  10.3
    perl 5.8.1:  <em>10.3</em>, 10.4
    perl 5.8.4:  10.3, 10.4
    perl 5.8.6:  10.3, <em>10.4</em>, 10.5
    perl 5.8.8:        10.4, <em>10.5</em>, 10.6
    perl 5.10.0:             10.5, <em>10.6</em>
    perl 5.12.3:                         <em>10.7</em>, 10.8, 10.9
    perl 5.12.4:                         10.7, <em>10.8</em>, 10.9
    perl 5.16.2:                         10.7, 10.8, <em>10.9</em>, 10.10, 10.11, 10.12, 10.13
    perl 5.18.2:                         10.7, 10.8, 10.9, <em>10.10</em>, <em>10.11</em>, <em>10.12</em>, <em>10.13</em>, <em>10.14</em>, 10.14.5, 10.15
    perl 5.18.4:                                     10.9, 10.10, 10.11, 10.12, 10.13, 10.14, <em>10.14.5</em>, <em>10.15</em>
</codeblock>
<p>
すべての variant をひとつの finkinfo ファイルに含める方法は、以下の通りです。
</p>
<codeblock>
  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.8 5.10.0 5.12.3 5.12.4 5.16.2)
  Distribution: &lt;&lt;
    (%type_pkg[perl] = 588) 10.6,
    (%type_pkg[perl] = 5100) 10.6,
    (%type_pkg[perl] = 5123) 10.7, (%type_pkg[perl] = 5123) 10.8, (%type_pkg[perl] = 5123) 10.9,
    (%type_pkg[perl] = 5124) 10.7, (%type_pkg[perl] = 5124) 10.8, (%type_pkg[perl] = 5124) 10.9,
    (%type_pkg[perl] = 5162) 10.7, (%type_pkg[perl] = 5162) 10.8, (%type_pkg[perl] = 5162) 10.9
  &lt;&lt;
</codeblock>
<p>
10.2 or 10.4-transitional などの古いディストリビューションは、対応している fink バージョンがこのフィールドを認識しないので、
省略しています。
</p>
</itemd></item>



				<item>
					<itemt>Epoch</itemt>
					<itemd>
						<p>
							<em>Fink 0.12.0 で導入:</em>
							パッケージの「エポック」を指定します (指定されていない場合は 0 と見なされる)．
							詳細は
							<link url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian Policy Manual</link>
							を参照．
							Fink と，元となっている Debian ツールは，name-version-revision をパッケージのユニークな識別子としています．
							epoch のみが異なるような複数のパッケージを作ってはいけません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Description</itemt>
					<itemd>
						<p>
							パッケージの短い説明．(それが何であるか)
							一覧表示に使われる1行紹介文なので，簡潔かつ分かり易く．
							(半角) 45文字以下が望ましい．
							60文字を超えないこと．
							このフィールドは，「パッケージ名」と必ず一緒に表示されるので，「パッケージ名」を繰りかえす必要はありません．
							必須フィールド．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Type</itemt>
					<itemd>
						<p>
							値が <code>bundle</code> の場合:
							バンドルパッケージは関連するパッケージをひとまとめにするために使われます．
							各パッケージには，依存関係はありえますが，ソースコードにも，インストールされるファイルにも関連はありません．
							フィールド Source, PatchScript, CompileScript, InstallScript とそれらの関連フィールドは，
							バンドルパッケージでは無視されます．
						</p>
						<p>
							値が <code>nosource</code> の場合:
							これは <code>bundle</code> と非常に似ています．
							これはソースの tarball が存在しないことを示します．
							よって何も取り寄せられず，解凍段階では空ディレクトリが作られます．
							しかしパッチ，コンパイル，インストールの各段階は通常通り実行されます．
							このようにして全てのソースコードをパッチと共に配布したり，
							または InstallScript を使ってディレクトリを作るだけのことができます．
							Fink 0.18.0 以降では <code>Source: none</code> と設定しても同じ挙動が実現できます．
							これにより，フィールド <code>Type</code> を他の目的に使えます (<code>Type: perl</code> など)．
						</p>
						<p>
							値が <code>perl</code> の場合 (Fink 0.9.5 以降):
							コンパイル及びインストール段階のスクリプトのデフォルト値が変わります．
							Fink 0.13.0 からは，この値の variant として <code>perl $version</code> が使えます．
							ここで &quot;$version&quot; は perl の特定のバージョンで，3つの数をピリオドで区切ったもの
							(<code>perl 5.6.0</code> など)．
						</p>
						<p>
							CVS 版の Fink 0.19.2 以降では，
							「プログラミング言語」または「プログラミング言語-バージョン」という記法は一般化され，
							メンテナの定義した任意のタイプとそれに関連するサブタイプが指定できるようになり，
							あるパッケージに複数のタイプを指定できるようになりました．
							タイプとサブタイプにはそれぞれブランク以外からなる任意の文字列が使えます．
							(しかし括弧，大括弧，カンマ，パーセント記号を使ってはいけません．)
							ここではパーセント展開は行われません．
							また，タイプの値は小文字に変換されます(が，サブタイプは変換されません)．
							複数のタイプを指定するにはカンマ区切りのリストを使います
							(各タイプに空白区切りのサブタイプリストが伴うことができます)．
							
						</p>
						<p>
							これに加えて「 variant 」という概念があります．
							単一のパッケージ記述が，有効なコンパイルオプションだけが違う複数のパッケージを生成するとき，
							これらのパッケージは「 variant 」になります．
							このプロセスの鍵はサブタイプリストの利用です．
							単一の文字列ではなく，文字列の空白区切りリストを括弧で括ったものを使います．
							Fink はリスト内のサブタイプ毎にパッケージ記述をコピーし，各コピー内ではリストを単一のサブタイプに置き換えます．
							例:
						</p>
						<codeblock>Type: perl (5.12.3 5.12.4)</codeblock>
						<p>
							これは 2 つのパッケージ記述を生成します．
							片方は <code>Type: perl 5.12.3</code> と，もう片方は <code>Type: perl 5.12.4</code> と同等になります．
							特殊なサブタイプリスト &quot;(boolean)&quot; が意味するのは，(サブでない) タイプ自身とドット '.' から成るリストです．
							つまり以下の 2 つは同一です．
						</p>
<codeblock>
Type: -x11 (boolean)
Type: -x11 (-x11 .)
</codeblock>
						<p>
							サブタイプリストの展開とそれに伴うパッケージ variant の作成は，再帰的に行われます．
							またサブタイプリストを持つタイプが複数ある場合は，あり得る組み合わせが全て生成されます．
						</p>
<codeblock>Type: -ssl (boolean), perl (5.12.3 5.12.4)</codeblock>
						<p>
							Type 以外のフィールドから特定の variant のサブタイプを得るには，疑似ハッシュ %type_raw[] および %type_pkg[] を使います．
							以下にパッケージ記述の例の一部を示します．
						</p>
<codeblock>
Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4)
Depends: perl%type_pkg[perl]-core
&lt;&lt;
</codeblock>
<codeblock>
Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [ &quot;%type_raw[-x11]&quot; == &quot;-x11&quot; ]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;
</codeblock>
<p>
fink 0.26.0 より， <code>Type: -64bit</code> によって新しいパーセント展開 <code>%lib</code> を制御することができます．
また，<code>LDFLAGS</code> の既定値も変更になりました．
こちらも新しい式 %type_num[] と用いることで，ライブラリの 32-bit バージョンと 64-bit バージョンを一つの .info ファイルから作ることが可能になりました．
以下はサンプルコードです:
</p>
<codeblock>
Info2: &lt;&lt;
Package: foo%type_pkg[-64bit]
Type: -64bit (boolean)
Depends: (%type_raw[-64bit] = -64bit) 64bit-cpu
ConfigureParams: --libdir='${prefix}/%lib'
SplitOff: &lt;&lt;
 Package: %N-shlibs
 Files: %lib/libfoo.*.dylib
 Shlibs: &lt;&lt;
    %p/%lib/libfoo.1.dylib 1.0.0 %n (>= 1.0-1) %type_num[-64bit]
  &lt;&lt;
&lt;&lt;
&lt;&lt;
</codeblock>
					</itemd>
				</item>

				<item>
					<itemt>License</itemt>
					<itemd>
						<p>
							パッケージ配布の際にパッケージの従うライセンスの性質を表す．
							値は <xref chapter="policy" section="licenses">パッケージのライセンス</xref> で示した選択肢から選ばなければいけない．
							それに加え，パッケージが実際にパッケージ作成・ポリシーに従うとき，
							すなわちライセンスのコピーがパッケージの doc ディレクトリにインストールされるときでなければ
							このフィールドを指定してはいけない．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>Maintainer</itemt>
					<itemd>
						<p>
							パッケージに責任を負っている人物の名前とメールアドレス．
							必須フィールド．
							値は以下の形式で，名前とメールアドレスはそれぞれ一つだけとする．
						</p>
<codeblock>名前 名字 &lt;アカウント@ドメイン.example.com&gt;</codeblock>
						<p>
							訳注: 名前はローマ字表記です．
							順序は，特に指定はありませんが， YAMADA Taro などとするのが一般的です．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>InfoN</itemt>
					<itemd>
						<p>
							このフィールドにより Fink はパッケージ記述の構文の非互換な変更に対処できます．
							任意のバージョンの Fink には扱える &quot;N&quot; (整数) の最大値が設定されています．
							それより大きいNを持つフィールド InfoN はいずれも無視されます．
							よって、この機構の利用は必要最低限に止めなければいけません．
							そうでないと，古いバージョンの Fink のユーザが必然性なしに仲間外れにされます．
							この機構を使うには，パッケージ記述全体をフィールド InfoN の値に埋め込んでください．
							複数行に渡る値の記述方法については，前述の「ファイル形式」を参照してください．
							以下は，各 InfoN レベルにおいて追加された機能と，最初にサポートされた fink のバージョンです．
						</p>
<ul>
<li>
<code>Info2</code> (fink>=0.20.0): 
.info ファイル中のメインの <code>Package</code> フィールドでのパーセント展開の使用．
<code>SplitOff</code> (および <code>SplitOff<em>N</em></code>) での <code>%type_*</code> パーセント展開の使用．
</li>
<li>
<code>Info3</code> (fink>=0.25.0): 
.info ファイル中でインデントを正しく扱うことができる．
RFC-822 複数行のサポートは終了．
pkglist フィールドにコメントが可能．
</li>
<li>
<code>Info4</code> (fink>=0.26.2): %V 展開を追加，
<code>ConfigureParams</code> フィールド内で <code>%lib</code> の使用が可能．
</li>
</ul>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>依存性関連</em>
			</p>
			<itemtable>
				<item>
					<itemt>Depends</itemt>
					<itemd>
						<p>
							そのパッケージがビルドできるようになる前にインストールされていなければいけないパッケージの一覧。
							このフィールドではパーセント展開が行われる
							(「依存性関連」の他のフィールドでも同様:
							BuildDepends, RuntimeDepends, Provides, RuntimeDepends, Conflicts, Replaces, Recommends, Suggests および Enhances)。
							普通、値は「パッケージ名」の単なるカンマ区切り一覧だが、
							現在の Fink は、dpkgと同じ形式の「代替パッケージ」と「バージョン節」に対応している。
							それらを全て盛りこんだ例:
						</p>
<codeblock>Depends: &lt;&lt;
    daemonic (&gt;= 20010902-1), 
    emacs | xemacs
&lt;&lt;</codeblock>
						<p>
							上のレイアウトは <code>Depends</code> や類似のフィールドでの好ましい書き方です。
							 <code>&lt;&lt;</code> を使うことで複数行に対応し、
							 各パッケージをアルファベット順に書きます。
							 値が一つだけの場合は、一行の <code>Field: value</code> でも構いません。
						</p>
						<p>
							本当の意味で「省略可能」な依存性を表現する方法がないことに注意．
							あるパッケージが別のパッケージがあってもなくても動作するとき，
							もう片方のパッケージが (存在するときであっても) 確かに使われていないか確かめるか，
							またはフィールド Depends に加えるかのどちらかを行うこと．
							ユーザにどちらの使い方をも提供したいときは，2 つの別々のパッケージ (例えば wget と wget-ssl) を作る．
						</p>
						<p>
							0.18.2 CVS版以降の Fink では，条件付き依存性を記述できる．
							それを指定するには「パッケージ名」の前に <code>(string1 op string2)</code> を付ける．
							パーセント記法が普通に展開され，その後オペレータ <code>op</code> によって2つの文字列が比較される．
							<code>op</code> には以下のものが使える: &lt;&lt;, &lt;=, =, !=, &gt;&gt;, &gt;=．
							その直後に「パッケージ名」の記されたパッケージには，比較が真を返したときのみ依存性があると判断される．
						</p>
						<p>
							この機能は，複数の似通ったパッケージを管理する際に手間を省くためにも使える．
							例えば elinks と elinks-ssl は次のように列挙できるが，
						</p>
<codeblock>Depends: &lt;&lt;
    (%n = elinks-ssl) openssl097-shlibs, 
    expat-shlibs
&lt;&lt;</codeblock>
						<p>
							これは elinks の方で
						</p>
<codeblock>Depends: expat-shlibs</codeblock>
						<p>
							とし， elinks-ssl の方で
						</p>
<codeblock>Depends: expat-shlibs, openssl097-shlibs</codeblock>
						<p>
							とすることと同じである．
						</p>
						<p>
							この他の文法として， <code>(string)</code> 指定をすることもできる．
							<code>string</code> が null でない場合， &quot;true&quot; を返す．
						</p>
<codeblock>
Package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11
</codeblock>
						<p>
							これにより，nethack-x11 は x11 パッケージに依存するが， nethack は依存しない．
						</p>
						<p>
							Depends/BuildDepends を，複数のメジャーバージョンを持つ共有ライブラリパッケージに使用する場合，下記のようにしては<em>いけない</em>:
 </p>
<codeblock>
  Package: foo
  Depends: id3lib3.7-shlibs | id3lib4-shlibs
  BuildDepends: id3lib3.7-dev | id3lib4-dev
</codeblock>
						<p>
							どちらのライブラリとも動作するパッケージであっても，どちらか一つ (適切に動作する高い方のバージョンが望ましい) のパッケージを選び，パッケージ内で統一する． 
						</p>
						<p>
							<xref chapter="policy" section="sharedlibs">共有ライブラリポリシー</xref>で説明したように， -dev パッケージがインストールされるのは一つだけである．
							各パッケージは -shlibs パッケージに関連づけられた異なるファイル名へ同じ名前のシンボリックリンクを作成することがある．
							しかし，パッケージ foo をコンパイルする際には実際の (-shlibs パッケージ内の) ファイル名の方が foo バイナリにハードコードされる．
							パッケージは，コンパイル時にインストールされた -dev に合った -shlibs パッケージを必要とする．
							このため， <code>Depends</code> でどちらも満たすようにはできないのである．
						</p>
						<p>
							以前は，必須でないパッケージは暗黙のうちに必須パッケージに依存していたが，
							現在はそうなっていない．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>BuildDepends</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.0 で導入:</em>
							ビルド時のみに適用される依存性のリスト．
							ビルド時には必要だが，実行時には使われないツール (flexなど) を示すのに使う．
							書式は Depends と同じ．
							ビルドされる際にテストスイートが有効であれば，
							<code>TestDepends</code>
							がこのリストに追加される．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>RuntimeDepends</itemt>
					<itemd>
						<p>
							<em>Fink 0.32.0 で導入:</em>
							ランタイム時のみに適用されインストールされる依存パッケージ一覧。
							パッケージを実行中になければならないが、
							ビルド時には使われないパッケージを一覧化します。
							Depends と同じ書式です。
						</p>
					</itemd>
				</item>

				<item>
					<itemt>Provides</itemt>
					<itemd>
						<p>
							そのパッケージが「提供」すると考えられる「パッケージ名」のカンマ区切りの一覧。
							パッケージ pine で <code>Provides: mailer</code> となっている場合，
							pine がインストールされると mailer についての全ての依存性は解決したものとされる．
							普通，そのようなパッケージは pine のフィールド Conflicts や Replaces にも入れるとよい．
						</p>

						<p>
							Provides 項目には，バージョン番号に関連した情報はない．
							親パッケージから取得することも，Provides フィールド自体にはバージョン番号を特定するような仕組みなどもない．
							バージョンを指定する依存性があっても，Provides を持つパッケージによって満たすことはできない．
							結果として，同一の代理パッケージを提供する variant が多数あるのは危険である．
							これによってバージョンを指定した依存性ができなくなるためである．
							例えば， foo-gnome と foo-nogome が &quot;Provides: foo&quot; を提供する場合，&quot;Depends: foo (> 1.1)&quot; は動作しない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Conflicts</itemt>
					<itemd>
						<p>
							そのパッケージと同時にインストールしてはいけない「パッケージ名」のカンマ区切りの一覧．
							バーチャルパッケージでは，そのパッケージが提供する「パッケージ名」をここに指定することができ，適切に扱われます．
							このフィールドはフィールド Depends のようにバージョン付きの依存性情報にも対応していますが，
							代替パッケージには対応していない (意味をなさない)。
							あるパッケージがそれ自身のパッケージ記述の Conflicts に入っていると、(暗黙のうちに) そこから取り除かれる。
							(Fink のバージョン 0.18.2 CVS 以降で導入)
						</p>
						<p>
							<em>注記:</em> Fink 自身はこのフィールドを無視します．
							これは dpkg に渡され，そこで適切に扱われます．
							要するに，このフィールドが影響するのはビルド時でなく実行時です．
						</p>
					</itemd>
				</item>
<item><itemt>BuildConflicts</itemt>
<itemd>
<p>
当該パッケージがコンパイル中にインストールされてはいけないパッケージの一覧．
これは， <code>./configure</code> やコンパイラが，望ましくないライブラリヘッダを見たり，
壊れることが分かっているツール (例えば，特定のバージョンの sed にあるバグ) のバージョンを使用することを避けるために使います．
ビルド時にテストスイートが有効な場合， <code>TestConflicts</code> フィールド内のパッケージはこの一覧に追加されます。
</p>
</itemd></item>
				<item>
					<itemt>Replaces</itemt>
					<itemd>
						<p>
							Conflicts と共に使われる．
							そのパッケ−ジが，衝突するパッケ−ジの機能の代わりになるだけでなく，共通するファイルを持つときに使われる．
							このフィールドがないと、dpkg はパッケージのインストール時にエラーを出すことがある。
							これは、いくつかのファイルが別の方のパッケージに属しているためである。
							こうした 2 つのパッケージが純粋な意味で互いに代替物であり，どちらか好きな方を選べるようなときはこれを使うとよい。
							あるパッケージがそれ自身のパッケージ記述の Conflicts に入っていると， (暗黙のうちに) そこから取り除かれる．
							(Fink のバージョン 0.18.2 CVS 以降で導入)
						</p>
						<p>
							<em>注記:</em> Fink自身はこのフィールドを無視します。
							これは dpkg に渡され、そこで適切に扱われます。
							つまり、このフィールドが影響するのはビルド時でなく実行時です。
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Recommends, Suggests, Enhances</itemt>
					<itemd>
						<p>
							これらのフィールドはパッケージ同士の付加的な関係情報を指定する．
							書式は他の依存情報フィールドと同じ．
							これら 3 つの情報は dpkg や apt-get によるインストール過程そのものには影響しないが，
							dselect や他のフロントエンドが，微妙な選択を行うユーザの判断を助けるのに使われる．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Pre-Depends</itemt>
					<itemd>
						<p>
							フィールド Depends の特別なもので，意味の上で厳密さが必要になる．
							このフィールドを使うのは，開発者用メーリングリストで議論を行い，確かに使う必要があるとの同意が得られた場合に限る．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Essential</itemt>
					<itemd>
						<p>
							必須パッケージを表す真偽値フィールド．
							必須パッケージでないパッケージは必須パッケージに暗黙のうちに依存して構わない．
							<code>dpkg</code> は，このフィールドの指示に優先する特別なフラグを使わない限り，必須パッケージをシステムから取り除くことを拒む．
							以前は，必須でないパッケージは暗黙のうちに必須パッケージに依存していたが，現在はそうではない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>BuildDependsOnly</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							真偽値フィールド．
							他パッケージはこのパッケージを BuildDepend に入れてもよいが， Depend に入れてはいけないことを示します．
							通常の真偽値とは異なり，<code>BuildDependsOnly</code> は３つの状態があります．
							未定義 (何も指定しない) の場合と明示的に False を指定するのとは異なります．
							詳細は<xref chapter="policy" section="sharedlibs">共有ライブラリポリシー</xref>を参照してください．
						</p>
						<p>
							fink 0.20.5 より，このフィールドが設定されているか，設定されている場合その値が，
							パッケージがビルドされる際には .deb ファイルに記録されます．
							このため， BuildDependsOnly の値を変更したり，追加・削除時には Rivision 番号をあげる必要があります．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>解凍段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>CustomMirror</itemt>
					<itemd>
						<p>
							ミラーサイトのリスト．
							各ミラーサイトは <code>&lt;場所&gt;: &lt;url&gt;</code> という書式に従って 1 行ずつ記述する．
							<em>場所</em> には大陸コード (例えば nam) や国コード (例えば nam-us) など (何でもよい) を使う．
							ミラーサイトはここに記述した順に試される．
							例:
						</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&lt;&lt;</codeblock>
						<p>
							大陸及び国のコードは  <filename>/sw/lib/fink/mirror/_keys</filename> にある．
							これは， fink および fink-mirrors パッケージの一部である．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source</itemt>
					<itemd>
						<p>
							ソースの tarball の URL ．
							HTTP または FTP でなければいけないが，Fink はそれを単に wget に渡すだけなので，実際には問題にならない．
							このフィールドは，ミラーサイトを示す特別な記法に対応している．
							すなわち <code>mirror:&lt;ミラー名称&gt;:&lt;相対パス&gt;</code> だ．
							こうすると Fink に <em>ミラー名称</em> として設定された URL を探し，
							その後ろに <em>相対パス</em> を付け加え，それを実際の URL として使う．
							Fink の認識する <em>ミラー名称</em> の一覧は <filename>/sw/lib/fink/mirror/_list</filename>
							(パッケージ fink または fink-mirrors の一部) に記される．
							または <em>ミラー名称</em> に <code>custom</code> と書くことで，
							Fink にフィールド <code>CustomMirror</code> を使わせることもできる．
							URL が wget に渡される前に，パーセント記法の展開が行われる．
							%n は %type_ 系で示される variant データ全てを含む文字列に展開されることに注意．
							ここでは %{ni} を (場合によっては特定の %type_ の展開値と共に) 使うとよい．
						</p>
						<p>
							Fink 0.18.0 以降では <code>Source: none</code> は特殊な意味を持ち，取り寄せるべきソースは存在しないことを表す．
							詳細についてはフィールド Type の説明を参照．
							<code>gnu</code> という値は <code>mirror:gnu:%n/%n-%v.tar.gz</code> の，
							<code>gnome</code> という値は <code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code> の省略形．
							デフォルト値は <code>%n-%v.tar.gz</code>  (すなわちマニュアル・ダウンロード) になっている．
							暗示的に <code>Source</code> を指定するのは廃止予定である (明示的に簡単なファイル名指定/手動ダウンロードするのは可)．
</p><p>
テストスイートを実行するためだけに必要なソースは，<code>TestSource</code>
および <code>InfoTest</code> 内の関連フィールドを使ってください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em></itemt>
					<itemd>
						<p>
							パッケージが複数の tarball から形成されている場合，それらはこの (省略可能) フィールドで指定する．
							N は 2 から始まる数．
							つまり最初の tarball  (ある意味「メイン」になるもの) をフィールド <code>Source</code> に，
							2 番目の tarball をフィールド <code>Source2</code> に，という風になる．
							値の書式は <code>Source</code> と共通だが，
							<code>gnu</code> や <code>gnome</code> という省略形は展開されない (結局，意味をなさない)．
							バージョン 0.19.2 以降の CVS 版 Fink では， 2 以上の任意の (つまり，必ずしも連続しない) 整数を N に使える．
							しかし，重複はやはり許されない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SourceDirectory</itemt>
					<itemd>
						<p>
							tarball が単一のディレクトリに展開されはするが，
							そのディレクトリ名が tarball のファイル名から拡張子を除いたものと異なる場合には，これを設定しなければいけない．
							つまり，普通なら &quot;foo-1.0.tar.gz&quot; という tarball は &quot;foo-1.0&quot; というディレクトリを生成する．
							しかし生成されるディレクトリ名がそれと異なる場合，そのディレクトリ名をこのフィールドで指定する．
							パーセント展開が行われる．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>NoSourceDirectory</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							tarball が単一のディレクトリに展開されないときにこのフィールドを設定する。
							つまり、普通なら &quot;foo-1.0.tar.gz&quot; という tarball は &quot;foo-1.0&quot; というディレクトリを生成する。
							しかし tarball を展開したときにファイルがカレントディレクトリで展開される場合は、
							このフィールドを &quot;true&quot; に設定する．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em>ExtractDir</itemt>
					<itemd>
						<p>
							普通、補助的な tarball は「メイン」の tarball と同じディレクトリで展開される。
							それを特定のサブディレクトリ内で展開して欲しいときは，このフィールドでサブディレクトリ名を指定する．
							ご想像の通り， <code>Source2ExtractDir</code> は <code>Source2</code> で指定した tarball に対応する．
							用例についてはパッケージ ghostscript, vim や tetex を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SourceRename</itemt>
					<itemd>
						<p>
							このフィールドを使うと，ビルド時にソースの tarball をリネームできる。
							これが便利なのは，例えば，ソースのバージョンがサーバのディレクトリ名には示されているが，
							tarball そのものはどのバージョンでも同じ名前のときだ。
							(例えば <filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename> というとき)
							このことで起きる問題を回避するためには次のようにすればよい．
						</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
						<p>
							この例では，ご想像の通り， tarball は <filename>/sw/src/coolapp-1.2.3.tar.gz</filename> として格納されることになる．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em>Rename</itemt>
					<itemd>
						<p>
							これはフィールド <code>SourceRename</code> と同じだが，
							<code>Source<em>N</em></code> で指定された N 番目の tarball のリネームに使う．
							用例についてはパッケージ context や hyperref を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source-MD5</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドではソースファイルの MD5 チェックサムを指定します．
							Fink はこの情報によりおかしなソースファイル，
							すなわち Fink パッケージの作成者が指定したものではない tarball を見分けられます．
							この問題の原因には，以下のようなものがあります:
							tarball のダウンロードに失敗した，upstreamのメンテナが知らないうちに tarball を更新した，トロイの木馬などの攻撃，など．
						</p>
						<p>
							このフィールドの典型的な用例は次の通り．
						</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
						<p>
							チェックサムの算出にはツール <code>md5sum</code> を使います．
							tarball  <filename>/sw/src/apache_1.3.23.tar.gz</filename> のチェックサムが知りたいときには，
							次のコマンドを実行します (出力も一緒に示した)．
						</p>
<codeblock>fingolfin% md5sum /sw/src/apache_1.3.23.tar.gz
4499443fa1d604243467afe64522abac  /sw/src/apache_1.3.23.tar.gz</codeblock>
						<p>
							左に表示された値がここで必要なものです．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em>-MD5</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							フィールド <code>Source-MD5</code> と同様ですが，
							フィールド <code>Source<em>N</em></code> に対応する N 番目の tarball の MD5 チェックサムを指定します．
						</p>
					</itemd>
				</item>
<item><itemt>Source-Checksum</itemt>
<itemd>
<p>
Alternative method to list the checksum for a source file. This field
takes a hash type, followed by the actual checksum. For example:
</p>
<codeblock>Source-Checksum: SHA256(5048f1c8fc509cc636c2f97f4b40c293338b6041a5652082d5ee2cf54b530c56)</codeblock>
<p>
Current valid checksums are <code>MD5</code>, <code>SHA1</code>, and
<code>SHA256</code>. The <code>shasum</code> tool can be used to
calculate SHA checksums:</p>
<codeblock>$ shasum -a 256 /opt/sw/src/libexif-0.6.22.tar.xz 
5048f1c8fc509cc636c2f97f4b40c293338b6041a5652082d5ee2cf54b530c56  /opt/sw/src/libexif-0.6.22.tar.xz
</codeblock>
<p>
The <code>Source-Checksum</code> field should only be used once per
.info file. If both the <code>Source-MD5</code> and
<code>Source-Checksum</code> fields are present,
<code>Source-Checksum</code> takes precedence.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>-Checksum</itemt>
<itemd>
<p>
This is just the same as the <code>Source-Checksum</code> field, except that it
is used to specify the checksum of the tarball specified by the
corresponding <code>Source<em>N</em></code> field.
</p>
</itemd></item>
				<item>
					<itemt>TarFilesRename</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドは tar 形式を使うソースファイルにのみ適用されます．
						</p>
						<p>
							このフィールドを使うと，任意のソース tarball の中のファイルを， tarball の展開中にリネームできます．
							ファイルシステム HFS+ がケースインセンシティブである (大文字と小文字を区別しない) ことを回避するために非常に便利でしょう．
							普通の Mac OS X システムでは，ファイル <filename>install</filename> と <filename>INSTALL</filename> は衝突してしまいます．
							このフィールドを使うと， tarball をわざわざ再パッケージしなくとも (以前はこのような場合に行われていた)，
							こういった問題を回避することができます．
						</p>
						<p>
							このフィールドでは，単に，リネームされるファイルのリストを指定します．
							ワイルドカードも使うことができます．
							デフォルトでは，指定されたファイルは，いずれも元の名前に <code>_tmp</code> を後置したファイル名にリネームされます．
							デフォルト値に優先する指定をするには，
							フィールド <code>Files</code> や <code>DocFiles</code> と同様の書式を使います．
							すなわち 元のファイル名，コロン (:)，新ファイル名，という順です．
							例:
						</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: direcory/INSTALL:directory/INSTALL.txt</codeblock>
					</itemd>
				</item>

				<item>
					<itemt>Tar<em>N</em>FilesRename</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							フィールド <code>TarFilesRename</code> と同様ですが，
							フィールド <code>Source<em>N</em></code> に対応する N 番目の tarball に対して機能します．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>パッチ段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>UpdateConfigGuess</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							&quot;true&quot; にすると，ビルド用ディレクトリ内のファイル config.guess と config.sub が
							Darwin に対応したバージョンに置き換えられます．
							その動作は，パッチ段階の，PatchScript が実行される前に行われます．
							これが必要だと分かっているとき，
							すなわち configure スクリプトが &quot;unknown host&quot; というメッセージで失敗するとき<em>のみ</em>使うこと．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdateConfigGuessInDirs</itemt>
					<itemd>
						<p>
							<em>0.9.0 CVS バージョン以降で導入:</em>
							サブディレクトリのリストを指定します．
							これは UpdateConfigGuess と同じことを行いますが，
							ソースツリー中の複数のディレクトリに古い config.guess が入っているパッケージで便利でしょう．
							以前はコピーや移動を行うよう PatchScript に手動で指定する必要がありましたが，
							この新フィールドを使えばディレクトリを単に列挙するだけでよくなりました．
							ビルド用ディレクトリ自身のファイルの更新には <code>.</code> とします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdateLibtool</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							&quot;true&quot; にすると，ビルド用ディレクトリ内のファイル ltconfig と ltmain.sh が
							Darwin に対応したバージョンに置き換えられます．
							その動作は，パッチ段階の， PatchScript が実行される前に行われます．
							これが必要だと分かっているとき<em>のみ</em>使うこと．
							libtool 関連のスクリプトをバージョンの合わないものに取り換えると壊れるパッケージもあります。
							詳細については<link url="/doc/porting/libtool.php">libtool のページ</link>を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdateLibtoolInDirs</itemt>
					<itemd>
						<p>
							<em>0.9.0 CVS バージョン以降で導入:</em>
							サブディレクトリのリストを指定します．
							これは UpdateLibtool と同じことを行いますが，
							ソースツリー中の複数のディレクトリに古い libtool 1.3.x 系列のスクリプトが入っているパッケージで便利でしょう．
							以前はコピーや移動を行うよう PatchScript に手動で指定する必要がありましたが，
							この新フィールドを使えばディレクトリを単に列挙するだけでよくなりました．
							ビルド用ディレクトリ自身のファイルの更新には <code>.</code> とします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdatePoMakefile</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							&quot;true&quot; にすると，サブディレクトリ <filename>po</filename> 内のファイル
							<filename>Makefile.in.in</filename> が，パッチの当たったものと取り換えられます．
							その動作は，パッチ段階の， PatchScript が実行される前に行われます．
						</p>
						<p>
							パッチの当たった <filename>Makefile.in.in</filename> は DESTDIR の指定を優先し，メッセージカタログを，
							<filename>/sw/lib/locale</filename> ではなく，確実に <filename>/sw/share/locale</filename> に格納します．
							このフィールドを利用する前に，入れ換えによってパッケージを破壊していないこと，また入れ換えが本当に必要かどうかを確認すること．
							<code>diff</code> を実行すれば，パッケージ付属のものと Fink 向けのもの
							(<filename>/sw/lib/fink/update</filename> 内にある) との違いが分かります．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Patch</itemt>
					<itemd>
						<p>
							<code>patch -p1 &lt;<em>パッチファイル</em></code> として適用されるパッチのファイル名．
							ここにはファイル名のみを指定します．
							適切なパス (<code>.info</code>のあるディレクトリ) は自動的に前置されます．
							このフィールドではパーセント展開が行われるので，典型的な値は単に <code>%f.patch</code> または <code>%n.patch</code> となります．
							PatchScript が指定されている場合，パッチはその後に別のステップとして実行されます．
						</p>
						<p>
							%n は %type_ 系で示される variant データ全てを含む文字列に展開されることに注意．
							ここでは %{ni} を (場合によっては特定の %type_ の展開値と共に) 使うとよいでしょう．
							単一のパッチファイルを管理し，
							各 variant 固有の変更点を <code>PatchScript</code> に記述する方が，
							各 variant 毎にパッチファイルを作るより手間が少ないでしょう．
						</p>
					</itemd>
				</item>
<item><itemt>PatchFile</itemt>
<itemd>
<p>
<code>Patch</code> フィールドと同じ文法．
このファイルへのフルパスは， <code>%{PatchFile}</code> パーセント展開で利用することができます．
<code>Patch</code> と異なり， <code>PatchFile</code> は <code>PatchScript</code> の一部分として適用されます．
Fink は，そのアイルが存在し，読み取り可能であり，チェックサムが <code>PatchFile-MD5</code> フィールドと適合していることを確認します．
</p>
<p>
<code>Patch</code> と <code>PatchFile</code> を，ひとつのパッケージ記述中に同時に使うことはできません．
<code>PatchFile</code> を使うパッケージは，<code>BuildDepends: fink (&gt;= 0.24.12)</code> を宣言しなければなりません．
他の理由があればこれより大きいバージョン番号を使ってもかまいません．
</p>
</itemd></item>

	<item><itemt>PatchFile<em>N</em></itemt>
		<itemd>
			<p>
			パッケージにパッチファイルが複数ある場合、
			N = 2 から始まる連番のフィールドを追加することができます。
			最初のパッチファイルは <code>PatchFile</code>、
			２番目のパッチファイルは <code>PatchFile2</code>
			となります。
			<code>PatchFile<em>N</em></code> を使うパッケージは、
			<code>BuildDepends: fink (&gt;= 0.30.0)</code> を設定する必要があります。
			他の理由で必要があれば、より高いバージョン番号を設定してもかまいません。
			</p>
		</itemd></item>

<item><itemt>PatchFile-MD5</itemt>
<itemd>
<p>
<code>PatchFile</code> フィールドで与えられたファイルの MD5 チェックサム．
<code>PatchFile</code> を使用する際には必須．
(fink-0.24.12 で導入)
</p>
</itemd></item>

	<item><itemt>PatchFile<em>N</em>-MD5</itemt>
		<itemd>
			<p>
			<code>PatchFile<em>N</em></code> の MD5 チェックサムです。
			<code>PatchFile<em>N</em></code> がある場合は必須です。
			(fink-0.30.0 で導入。)
			</p>
		</itemd></item>


				<item>
					<itemt>PatchScript</itemt>
					<itemd>
						<p>
							パッチ段階で実行されるコマンドのリスト．
							下記のスクリプトの注意書きを参照してください．
							ここには，パッチを当てるか，またはパッケージに変更を加えるコマンドを指定します．
							下記の<xref chapter="reference" section="scripts">スクリプトに関する注記</xref>もあわせて参照してください．
							コマンド実行前に，<xref chapter="format" section="percent">パーセント展開</xref>が行われます．
<code>PatchFile</code> フィールドが存在する場合，
<code>PatchScript</code> の既定値は:
</p>
<codeblock>
patch -p1 &lt; %{PatchFile}
</codeblock>
<p>
もし、<code>PatchFile<em>N</em></code> が設定された場合、
</p>
<codeblock>
patch -p1 &lt; %{PatchFile<em>N</em>}
</codeblock>
<p>
です．
<code>PatchFile</code> がない場合の既定値はブランクとなります．
<code>PatchScript</code> を明示的に用いる場合， <code>PatchFile</code> を明示しなければなりません．
</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>コンパイル段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>Set<em>環境変数名</em></itemt>
					<itemd>
						<p>
							コンパイルおよびインストールの段階の間，環境変数を設定します．
							コンパイラフラグなどを configure スクリプトや Makefile に渡すために使われます．
							現在，対応している変数は次の通り: 
							CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, DYLD_LIBRARY_PATH, JAVA_HOME,
							LD, LDFLAGS, LIBRARY_PATH, LIBS, MACOSX_DEPLOYMENT_TARGET, MAKE, 
							MFLAGS, MAKEFLAGS.
							指定した値の中では前節で説明したパーセント展開が行われます．
							よく使われる例:
						</p>
<codeblock>SetCPPFLAGS: -Wl,-strip_dead_dylibs</codeblock>
						<p>
							環境変数には，既定値を持つものもあります．
							この場合に値を指定すると，既定値に追加されます．
							既定値を持つ変数とその値は:
						</p>
<codeblock>
CPPFLAGS: -I%p/include
LDFLAGS: -L%p/lib
</codeblock>
<p>fink 0.26.0 より，これらの既定値に例外が一つあります．
<code>Type: -64bit</code> が <code>-64bit</code> と定義されている場合，
<code>LDFLAGS</code> は <code>-L%p/%lib -L%p/lib</code> となります．
</p>
						<p>
							MACOSX_DEPLOYMENT_TARGET は OSX のバージョンを既定値として持ちます．
							これに値を指定することで (値の追加ではなく) 既定値を書き換えることができます．
						</p>

					</itemd>
				</item>
				<item>
					<itemt>NoSet<em>環境変数名</em>
					</itemt>
					<itemd>
						<p>
							真の場合，既定値を持つ変数 (上述の CPPFLAGS, LDFLAGS, CXXFLAGS など) の既定値を使いません．
							例えば，LDFLAGS を unset のままにしたい場合， <code>NoSetLDFLAGS: true</code> とします．
						</p>
					</itemd>
				</item>

			<item><itemt>UseMaxBuildJobs</itemt>
				<itemd>
				<p>
				true が設定された場合、
				CompileScript と TestScript の間、
				MAKEFLAGS 環境変数に
				<code>-j<em>N</em></code> を
				追加します。
				<em>N</em> は、<filename>fink.conf</filename> の MaxBuildJobs から得られます。
				<code>NoSetMAKEFLAGS: true</code> が使われても MAKEFLAGS に渡されます。
				fink &gt; 0.31.2 では、このフィールドが無いあるいは空欄の場合、デフォルト値は true です。
				</p>
			</itemd></item>
	 
			<item><itemt>BuildAsNobody</itemt>
				<itemd>
				<p>
				fink &gt;= 0.33.0 で、<code>false</code> が設定された場合、
				fink は 権限のない <code>fink-bld</code> の代わりに、 <code>root</code> でビルドします。
				このフィールドが無い場合、デフォルト値は <code>true</code> で、
				<code>fink-bld</code> としてビルドします。
				</p>
				<p>これ以前の fink バージョンでは、このフィールドは何もしません。</p>
			</itemd></item>

				<item>
					<itemt>ConfigureParams</itemt>
					<itemd>
<p>
configure スクリプトに渡す付加的なパラメータ．
(詳細は CompileScript を参照)
<code>Type: Perl</code> となっていないパッケージに関しては，
パラメータ <code>--prefix=%p</code> が，この値の前に追加されます．
fink > 0.13.7　からは，このフィールドは perl モジュール <code>Type: Perl</code> にも適用されます;
既定の perl Makefile.PL 文字列が， <code>ConfigureParams</code> に与えられる値の前に追加されます．
</p>
<p>
テストスイートが有効でビルドする場合，<code>TestConfigureParams</code>
の値が 通常の <code>ConfigureParams</code> の後に追加されます．
</p>
						<p>
							fink-0.22.0 より，このフィールドは条件をサポートする．
							文法は <code>Depends</code> や他のパッケージ一覧フィールドと同様です．
							条件は，スペースデリミティッドな &quot;word&quot;  の直後に記述します．
							例えば:
						</p>
<codeblock>
Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) --with-x11 --disable-shared
</codeblock>
						<p>
							これは<code>--mandir</code> と <code>--disable-shared</code> フラグを送り，
							 -x11 variant の場合のみ <code>--with-x11</code> を送ります．
						</p>
						<p>
						このフィールドは、複数行宣言をすることで複数行に書くことができます。
						このフィールドは、シェルコマンドとして扱われ、<code>\</code> で行を分けることができます:
						</p>
<codeblock>
ConfigureParams: &lt;&lt;
    --mandir=%p/share/man \
    (%type_pkg[-x11]) --with-x11 \
    --disable-shared
&lt;&lt;
</codeblock>
						<p>
						注記: 複数行で書く場合には、最後の行に条件付きパラメータを設定しないでください。
						条件式が false の場合、直後のパラメータは評価されず、シェルを壊します。
						</p>
					</itemd>
				</item>
				<item>
					<itemt>GCC</itemt>
					<itemd>
						<p>
							当フィールドは，パッケージ内の C++ コードが使用する GCC-ABI を指定します．
							(このフィールドは，ABI が２度変わり，C++ コードと，それがリンクするライブラリが同じ ABI でなければならないために必要である．)
						</p><p>
							値としては:
							<code>2.95.2</code> (or <code>2.95</code>),
							<code>3.1</code>, <code>3.3</code> および <code>4.0</code> 
							があります．
							我々の知る限り，GCC の作者は，ある時点で GCC-ABI を固定するものと思われます．
							これ以上変わらないことを期待しましょう．
						</p>
<p>
GCC フィールドはそれ自体は既定値を持たず，設定されなければ無視されます．
しかし，各ツリーには，既定の g++ コンパイラが存在し，これに対応する GCC の値が想定されています．
想定値は，10.1 ツリーでは <code>2.95</code>， 10.2 ツリーでは <code>3.1</code>，
10.2-gcc3.3, 10.3, および 10.4-transitional　ツリーでは <code>3.3</code>，
10.4 と 10.7 ツリーでは <code>4.0</code> となります．
</p>
						<p>
							注記: GCC 値が既定値と異なる場合， (CC や CXX フラグを設定するなど) パッケージ内でコンパイラを指定する必要があります．
							また， (virtual) gcc パッケージへの依存性を指定します．
						</p>
						<p>
							Fink 0.13.8 以降，このフラグが指定されると， gcc のバージョンは <code>gcc_select</code> によって調べられ，
							誤ったバージョンのものが存在すると Fink はエラー終了します．
						</p>
						<p>
							このフィールドは gcc コンパイラ間の移行をメンテナが知ることができるように Fink に加えられました。
							gcc では， C++ コードの関わるライブラリ間で，実行可能・ファイル同士の (バージョン名に反映されない) 非互換が生じることがあります．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>CompileScript</itemt>
					<itemd>
						<p>
							コンパイル段階で実行されるコマンドのリスト．
							下記のスクリプトの注意書きを参照してください．
							パッケージの configure およびコンパイルを行うコマンドをここに指定します．
							下記の<xref chapter="reference" section="scripts">スクリプトに関する注記</xref>もあわせて参照してください．
							コマンド実行前に，<xref chapter="format" section="percent">パーセント展開</xref>が行われます．
							通常は以下の通り．
						</p>
<codeblock>./configure %c
make</codeblock>
						<p>
							これは GNU autoconf を利用するパッケージには適切でしょう．
							Perl タイプ (フィールド Type で指定される) のパッケージのうち perl のバージョン指定がないものでは，
							通常，次のようになります (0.13.4) ．
						</p>
<codeblock>perl Makefile.PL PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5 \
 INSTALLARCHLIB=%p/lib/perl5/darwin \
 INSTALLSITELIB=%p/lib/perl5 \
 INSTALLSITEARCH=%p/lib/perl5/darwin \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
						<p>
							タイプが <code>perl $version</code> となっていて，バージョンが指定されているものでは
							(例えば <code>$version</code> は 5.6.0 とする)，
							デフォルト値は次のようになります．
						</p>
<codeblock>perl$version Makefile.PL \
 PERL=perl$version PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5/$version \
 INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%p/lib/perl5/$version \
 INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>
ここで， <code>$perlarchdir</code> はバージョン 5.8.0 以前では &quot;darwin&quot; であり，
バージョン 5.8.1 以降では &quot;darwin-thread-multi-2level&quot; となります．
</p>
					</itemd>
				</item>
				<item>
					<itemt>NoPerlTests</itemt>
					<itemd>
						<p>
							<em>Fink 0.13.7 以降で導入:</em>
							真偽値フィールド．
							Perl モジュールのパッケージでのみ指定します．
							&quot;true&quot; にすると， <code>CompileScript</code> のうち <code>make test</code> の部分が，
							その perl モジュールのパッケージでは無視されます．
						</p>
					</itemd>
				</item>
			</itemtable>
			
<p><em>テストスイート:</em></p>
<itemtable>

<item><itemt>InfoTest</itemt>
<itemd>
<p>
<em>fink 0.25 にて導入．</em>
当フィールドは、テストスイートが有効な場合のビルド実行時にのみ使用される情報を含んだものです。
ここには他のフィールドが含まれます．
現在のところ，この中に  <code>TestScript</code> がなければ<em>なりません</em>．
他のフィールドはオプションです．
以下のフィールドが <code>InfoTest</code> にて許可されています:
</p><ul>
<li><code>TestScript</code>: 
    テストスイートを実行するスクリプト．
    このスクリプトは，スイートが終了するときは status を返します．
    0 の場合は通ったことを示し，
    1 の場合は警告があり，
    他の値の場合は致命的と考えられる重大な問題があったことを示します．
    この3状態のため，スクリプト内で終了値を明示的に設定しなければなりません．
    例えば， <code>make check</code> は悪いスクリプトです．
    これは終了時に，check のターゲットが存在しなければ status 1 を返すからです．
    <code>make check || exit 2</code> は比較的良いスクリプトです．
    </li>
<li><code>TestConfigureParams</code>: 
    テストスイートを実行するために必要な追加ソースです．
    関連する全てのフィールドもサポートされています．
    <code>TestSource-MD5</code> または <code>TestSource-Checksum</code> は指定されなければ<em>なりません</em>．
    <code>TestSourceN</code> や対応する <code>TestSourceN-MD5</code> , <code>TestSourceN-Checksum</code> , <code>TestTarFilesRename</code> などを追加することも可能です．</li>
<li><code>TestSuiteSize</code>: 
    テストスイートどの程度かかるかのおよその時間を示します．
    値は，<code>small</code>, <code>medium</code>, と <code>large</code> です．
    このフィールドは現在のところ無視されます．
    </li>
<li>
その他のフィールド．<code>InfoTest</code> 内と外で定義されるフィールドに関して，
スイートが有効な場合，<code>InfoTest</code> 内の値が他の値を書き換えます．</li>
</ul><p>例:
</p><codeblock>InfoTest: &lt;&lt;
    TestScript: make check || exit 2
    TestConfigureParams: --enable-tests
&lt;&lt;</codeblock>
</itemd></item>
</itemtable>
			
			<p>
				<em>インストール段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>UpdatePOD</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.5 で導入:</em>
							真偽値フィールド．
							Perl モジュールのパッケージでのみ指定します．
							&quot;true&quot; にすると， install, postrm および postinst スクリプトに，
							perl パッケージの提供する .pod ファイルを管理するためのコードを追加します．
							これには，中央のファイル <filename>/sw/lib/perl5/darwin/perllocal.pod</filename> に .pod ファイルのデータを追加したり，
							そこから削除することも含まれます．
							(<code>perl $version</code> のように，5.6.0 などの perl の特定のバージョンと共にタイプが指定された場合は，
							それらのスクリプトが扱う中央 .pod ファイルは <filename>/sw/lib/perl5/$version/perllocal.pod</filename> になる．)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>InstallScript</itemt>
					<itemd>
						<p>
							インストール段階におけるコマンドの一覧．
							ここでコマンドを指定することで，必要な全てのファイルを一時 dpkg ディレクトリにコピーします．
							下記の<xref chapter="reference" section="scripts">スクリプトに関する注記</xref>もあわせて参照してください．
							コマンド実行前に，<xref chapter="format" section="percent">パーセント展開</xref>が行われます．
							通常，デフォルトでは:
						</p>
<codeblock>make install prefix=%i</codeblock>
						<p>
							となります．
							このデフォルト値は GNU autoconf を利用するパッケージには適切です．
							Perl タイプ (フィールド Type で指定される) のパッケージのうち perl のバージョン指定がないものでは，
							デフォルト値は次のようになります．
						</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
INSTALLARCHLIB=%i/lib/perl5/darwin \
INSTALLSITELIB=%i/lib/perl5 \
INSTALLSITEARCH=%i/lib/perl5/darwin \
INSTALLMAN1DIR=%i/share/man/man1 \
INSTALLMAN3DIR=%i/share/man/man3 \
INSTALLSITEMAN1DIR=%i/share/man/man1 \
INSTALLSITEMAN3DIR=%i/share/man/man3 \
INSTALLBIN=%i/bin \
INSTALLSITEBIN=%i/bin \
INSTALLSCRIPT=%i/bin
</codeblock>
						<p>
							タイプが <code>perl $version</code> となっていて，バージョンが指定されているものでは 
							(例えば <code>$version</code> は 5.6.0 とする)，
							デフォルト値は次のようになります．
						</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
INSTALLARCHLIB=%i/lib/perl5/$version/$perlarchdir \
INSTALLSITELIB=%i/lib/perl5/$version \
INSTALLSITEARCH=%i/lib/perl5/$version/$perlarchdir \
INSTALLMAN1DIR=%i/share/man/man1 \
INSTALLMAN3DIR=%i/share/man/man3 \
INSTALLSITEMAN1DIR=%i/share/man/man1 \
INSTALLSITEMAN3DIR=%i/share/man/man3 \
INSTALLBIN=%i/bin \
INSTALLSITEBIN=%i/bin \
INSTALLSCRIPT=%i/bin
</codeblock>
<p>
ここで， <code>$perlarchdir</code> はバージョン 5.8.0 以前では &quot;darwin&quot; であり，
バージョン 5.8.1 以降では &quot;darwin-thread-multi-2level&quot; である．
</p>
						<p>
							パッケージが対応しているなら，代わりに <code>make install DESTDIR=%d</code> を使うことが望ましい．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>AppBundles</itemt>
					<itemd>
						<p>
							<em>post-0.23.1 バージョンから導入:</em>
							当フィールドは，アプリケーションバンドルを <filename>%p/Applications</filename> にインストールし， <filename>/Applications/Fink</filename>  にシンボリックリンクを作成します．
							例:
						</p>
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
					</itemd>
				</item>
				<item>
					<itemt>JarFiles</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドは DocFiles に似ています．
							ここで指定した jar ファイルは <filename>%p/share/java/%n</filename> にインストールされます．
							例:
						</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
						<p>
							こうすると，ディレクトリ lib 内の全ての jar ファイルをインストールし，
							foo.jar を fooBar.jar としてインストールします．
						</p>
						<p>
							また，これらの jar ファイル (正確にはディレクトリ <filename>%p/share/java/%n</filename> 内にある .jar で終わるファイル)
							は環境変数 CLASSPATH に確実に追加されませ．
							このフィールドにより， configure や ant といったツールが，インストールされた jar ファイルを適切に認識できるようになります．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DocFiles</itemt>
					<itemd>
						<p>
							このフィールドにより，ファイル README や COPYING を，
							パッケージの doc ディレクトリ (<filename>%p/share/doc/%n</filename>) に容易にインストールできます．
							値にはスペース区切りでファイルのリストを指定します．
							ビルド用ディレクトリのサブディレクトリからファイルをコピーすることはできますが，
							それらのファイルは doc ディレクトリそのものに入れなければいけません (そのサブディレクトリに入れてはいけない)．
							シェルのワイルドカードが利用できます．
							単一のファイルを，実行時にリネームすることもできます．
							新ファイル名はコロンで区切って後置してください．
							例:
							<code>libgimp/COPYING:COPYING.libgimp</code>.
							このフィールドは InstallScript に適切な <code>install</code> コマンドを追加することで動作します．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Shlibs</itemt>
					<itemd>
						<p>
							<em>Fink 0.11.0 で導入:</em>
							このフィールドでは，そのパッケージでインストールされる共有ライブラリを指定します．
							それぞれの共有ライブラリに一つの行があります．
							これには，ライブラリの<code>-install_name</code>と compatibility に関する情報は含まれます．
							「パブリック」な共有ライブラリ (つまり，他のパッケージに使われる) の場合，
							ファイル名の後に，空白区切りで，<code>-compatibility_version</code>，
							この compatibility version の Fink パッケージ，
							ライブラリのアーキテクチャ
							(値は &quot;32&quot;, &quot;64&quot;, または
                             &quot;32-64&quot;, あるいは空欄; 空欄時の既定値は &quot;32&quot; ．) 
							依存情報は <code>foo (>= バージョン-リビジョン)</code> という型式で指定しなければいけません。
							ここで <code>バージョン-リビジョン</code> は、 (互換性バージョンの同じ) そのライブラリを利用可能にしてくれる 
							Fink パッケージの<em>一番古い</em>バージョンを指します。
							フィールド Shlibs の設定は「この名前がついていて compatibility_version がこれ以上のライブラリは，
							その Fink パッケージの今後のバージョンでも必ず含まれている」というメンテナからの保証に相当します．
							「プライベート」な共有ライブラリは，ファイル名の前にビックリマークをつけ，代わりに compatibility やバージョン情報は書きません．
							詳細は <xref chapter="policy" section="sharedlibs">共有ライブラリのポリシー</xref> を参照してください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>RuntimeVars</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドにより，実行時に環境変数を何らかの固定された値に設定できます．
							(柔軟性が必要なら<xref section="profile.d">profile.d スクリプトの節</xref>を参照．)
							そのパッケージがインストールされる限り，
							ここに指定した環境変数はスクリプト <filename>/sw/bin/init.[c]sh</filename> によって設定されます．
						</p>
						<p>
							環境変数の値にはブランクが使えます (値の末尾に来ると取り除かれます)．
							また，パーセント展開が行われます．
							例:
						</p>
<codeblock>RuntimeVars: &lt;&lt;
SomeVar: %p/Value
AnotherVar: foo bar
&lt;&lt;</codeblock>
						<p>
							これは2つの環境変数 'SomeVar' および 'AnotherVar' を，
							それぞれ '/sw/Value' (環境のインストールディレクトリの値による) および 'foo bar' に設定します．
						</p>
						<p>
							このフィールドは InstallScript に適切なコマンドを追加することで機能します．
							それらのコマンドは，各環境変数に対してパッケージの profile.d スクリプトに setenv/export を追加します．
							よってパッケージメンテナ独自の環境変数は上書きされないので，自由に追加できます．
							これらの行はスクリプトに前置されるので，これらの環境変数をスクリプト内で利用できます．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SplitOff</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							1 回のコンパイル/インストール操作で第 2 のパッケージを生成する．
							詳細については，個別に書かれた<link url="#splitoffs">splitoff の節</link>を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SplitOff<em>N</em></itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							これはフィールド <code>SplitOff</code> と同様ですが，
							1 回のコンパイル/インストール操作で第 3 ，第 4 のパッケージを生成するために使われます．
							バージョン 0.19.2 以降の CVS 版 Fink では， 2 以上の任意の (つまり，必ずしも連続しない) 整数を N に使うことができます．
							しかし，重複はやはり許されていません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Files</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							フィールド <code>SplitOff</code> または <code>SplitOff<em>N</em></code> の内部<em>のみ</em>で使われます．
							ここでは，splitoff したパッケージのインストールディレクトリ %i に親パッケージのインストールディレクトリ %I から
							どのファイルやディレクトリを移動するかを指定します．
							注記:
							これが実行されるタイミングは，親パッケージの InstallScript や DocFiles のコマンドの実行後で，
							splitoff したパッケージの InstallScript や Docfiles の実行前です。
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>ビルド段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
					<itemd>
						<p>
							これらのフィールドには，パッケージがインストール，アップグレード，または削除される時点で実行されるシェルスクリプトの断片を記述します．
							Fink はシェルスクリプトのヘッダ <code>#!/bin/sh</code> を自動的に追加します．
							また <code>set -e</code> で実行するので，どのコマンドが実行に失敗しても，スクリプトはその時点で停止します．
							また Fink は末尾に <code>exit 0</code> を追加します．
							エラーの発生を示すには，非ゼロの終了コードでスクリプトから exit します．
							第 1 実引数 (<code>$1</code>) は，どのアクションが実行されているかを示す値に設定されます．
							値としては <code>install</code>, <code>upgrade</code>, <code>remove</code> および <code>purge</code> が使用できます．
							ただしこれらの他にも使われる値があることに注意してください．
							エラー回復や，別パッケージのインストールによりパッケージを取り除くことを表す値などがあります．
						</p>
						<p>
							各スクリプトは以下のタイミングで実行されます．
						</p>
						<ul>
							<li>PreInstScript: パッケージが初めてインストールされたときと，パッケージをそのバージョンにアップグレードする前．</li>
							<li>PostInstScript: パッケージを解凍し，設定する前．</li>
							<li>PreRmScript: パッケージが削除される前，または新しいバージョンにアップグレードされる前．</li>
							<li>PostRmScript: パッケージが削除された後，または新しいバージョンにアップグレードされた後．</li>
						</ul>
						<p>
							補足説明: アップグレードは新バージョンの ...InstScript と，旧バージョンの ...RmScript を実行します．
							詳細については Debian Policy Manual,
							<link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">第6章</link> を参照．
						</p>
						<p>
							スクリプト内ではパーセント展開が行われます．
							一般に，コマンドはフルパスを指定しなくても実行できます．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>ConfFiles</itemt>
					<itemd>
						<p>
							ユーザが修正できる設定ファイルの空白区切りの一覧。
							パーセント展開が行われます．
							ファイルは、<filename>%p/etc/%n.conf</filename> のように絶対パスで指定しなければいけません。
							dpkg はここで指定されたファイルを以下のように特別な扱いをします．
							パッケージがアップグレードされたとき，新設定ファイルが提供され，しかもユーザが旧パッケージの設定ファイルが修正していた場合は，
							ユーザはどちらのバージョンを使うか尋ねられ，設定ファイルのバックアップが作られます．
							パッケージを &quot;remove&quot; しても，設定ファイルは削除されずにディスク上に残ります．
							設定ファイルも削除されるのは &quot;purge&quot; を命じたときのみです。
						</p>
					</itemd>
				</item>
				<item>
					<itemt>InfoDocs</itemt>
					<itemd>
						<p>
							パッケージが <filename>%p/share/info</filename> にインストールする Info 文書のリスト．
							この設定により，Info ディレクトリ・ファイル <code>dir</code> を管理するための適切なコードが
							postinst および prerm スクリプトに追加されます．
</p>

<p><em>注記:</em>
Info ドキュメントがスプリットされている場合、
数字のないファイルだけを使います。
例えば、パッケージに:
</p>
<codeblock>
foo.info
foo.info-1
foo.info-2
</codeblock>
<p>があれば、</p>
<codeblock>
InfoDocs:  foo.info
</codeblock>
<p>と記述します。
この機能はまだ途中で、将来はよりよい制御のためのフィールドが追加されるかもしれません。
</p>


					</itemd>
				</item>
				<item>
					<itemt>DaemonicFile</itemt>
					<itemd>
						<p>
							<code>daemonic</code> のサービスの説明を記述します．
							Fink は <code>daemonic</code> を使ってデーモン・プロセス (web サーバなど) のための StartupItems を生成したり削除します．
							説明は <code>%p/etc/daemons/<em>名前</em>.xml</code> という名前のファイルとしてパッケージに追加されます．
							ここで <em>名前</em> はフィールド DaemonicName で指定される (デフォルト値は「パッケージ名」)．
							このフィールドの値ではパーセント展開が行われます．
							パッケージが <code>daemonic</code> を利用するなら，それを依存性リストに加えなければいけないことに注意．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DaemonicName</itemt>
					<itemd>
						<p>
							<code>daemonic</code> サービスの記述ファイルの名前．
							詳細はフィールド DaemonicFile を参照．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>付加的データ関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>Homepage</itemt>
					<itemd>
						<p>
							upstream パッケージのホームページの URL．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescDetail</itemt>
					<itemd>
						<p>
							フィールド <code>Description</code> よりも詳しい説明．
							(それが何であるか，何のために使うものか？)
							複数行に渡っても構いません．
							このフィールドは自動改行されずに表示されるので， (可能ならば) 手動で改行を挿入して各行 79 文字以内に収めてください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescUsage</itemt>
					<itemd>
						<p>
							パッケージを利用する上で必要になる情報を記述します．
							(そのパッケージはどのように使うものなのか？)
							例えば「 WindowMaker を使う前に wmaker.inst を起動．」等を (訳注: 英語で) ここに記述します．
							複数行に渡っても構いません．
							このフィールドはワードラップの恩恵に預らずに表示されるので， (可能ならば) 手動で改行を挿入して各行 79 文字以内に収めてください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescPackaging</itemt>
					<itemd>
						<p>
							パッケージ作成に関する注意書き．
							「ファイルを適切な場所に置くために Makefile にパッチを当てる」等を (英語で) ここに記述します．
							複数行も可。
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescPort</itemt>
					<itemd>
						<p>
							パッケージを Darwin に移植する場合に特有の注意書き．
							「config.guess と libtool スクリプトはアップデートする． -no-cpp-precomp が必要」等を (英語で) ここに記述します．
							複数行も可。
						</p>
					</itemd>
				</item>

			</itemtable>
		</section>
		<section name="splitoffs">
			<title>スプリットオフ (SplitOff)</title>
			<p>
				Fink 0.9.9 で導入．
				単一の .info ファイルで複数のパッケージを作成することが可能です．
				インストール段階は普通に始まり， <code>InstallScript</code> と <code>DocFiles</code> コマンドを実行します．
				フィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> が存在すれば，それらに対しインストールディレクトリを作成します．
				<code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中では，対応して新しく作られたインストールディレクトリは %i で，
				親パッケージのインストールディレクトリは %I で参照されます．
			</p>
			<p>
				フィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> には，独自のフィールドが多数あります．
				完全なパッケージ記述とよく似ていますが，抜けているフィールドもあります．
				以下は <code>SplitOff</code> に含まれる部分パッケージ記述 (分野別)です．
			</p>
			<ul>
				<li>
					初期データ関連:
					指定する必要があるのは <code>Package</code> のみで，
					その他は全て親パッケージから引き継がれます．
					<code>Type</code> と <code>License</code> は
					<code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中で宣言することで変更できます．
					パーセント展開も使えます．
					特に，親パッケージの名称を参照する %N を使用すると良いでしょう．
				</li>
				<li>
					依存性関連: 全てのフィールドが記述可能．
				</li>
				<li>
					解凍段階, パッチ段階, コンパイル段階関連: これらのフィールドは意味がないため無視されます．
				</li>
				<li>
					インストール段階, ビルド段階関連: 全てのフィールドが記述可能．
					(ただし <code>SplitOff</code> や <code>SplitOff<em>N</em></code> を入れ子にはできません．)
				</li>
				<li>
					付加的データ関連: 親パッケージから引き継がれますが，
					<code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中で宣言して修正することができます．
				</li>
			</ul>
<p>
%n-%v-%r は，パッケージのユニークな識別子として扱われるため，
<code>SplitOff</code> (あるいは <code>SplitOff<em>N</em></code>)
を用いて (同じ <code>Version</code> と <code>Revision</code> で) <code>Package</code> を作成してはいけません．
variant を使う際は，各 variant が独立したパッケージとなるようにしてください．
つまり，以下のようなパッケージレイアウトは禁止されます:
</p>
<codeblock>
Package: mime-base64-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4)
SplitOff: &lt;&lt;
  Package: mime-base64-pm-bin
&lt;&lt;
</codeblock>
			<p>
				インストール段階では，まず親パッケージの <code>InstallScript</code> と <code>DocFiles</code> が実行されます．
				次にフィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> の処理が行われます．
				すなわち，そのそれぞれの中の <code>Files</code> のコマンドが実行され，
				指定されたファイルやディレクトリが親インストールディレクトリ %I から splitoff パッケージのインストールディレクトリ %i に移されます．
				続いて <code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中の
				<code>InstallScript</code> や <code>DocFiles</code> などが順に実行されます．
			</p>
			<p>
				現在の Fink では，最初に <code>SplitOff</code> が (あれば) 処理され，その後に
				<code>SplitOff2</code>, <code>SplitOff3</code> などがさらに存在する場合，数の順に処理されます．
				しかしこの順番は将来変更されるかもしれません．
				よって， <code>SplitOff</code> が <code>SplitOff2</code> より先に処理される現状でしか正しく動作しない，次のようなコード
			</p>
<codeblock>
SplitOff: &lt;&lt;
  Description: Some header files
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: All other header files
  Files: include/*
&lt;&lt;
</codeblock>
			<p>
				を避け，それぞれの中で明示的なファイル名を使うか，より精密なファイルグロブ (いわゆるワイルドカード) を使う方がよいでしょう．
			</p>
			<p>
				ビルド段階では，各パッケージの pre/post install/remove スクリプトをビルド段階コマンドを使って作成します．
			</p>
			<p>
				ビルドされるパッケージは，ライセンス条項を <filename>%i/share/doc/%n</filename> に明記する必要があります
				(%n の値は当然パッケージ毎に異なる)．
				<code>DocFiles</code> はファイルを移動ではなくコピーすることに注意．
				よって <code>DocFiles</code> を使えば同一のドキュメントを各 splitoff パッケージ向けに複数回インストールできます．
			</p>
		</section>
		<section name="scripts">
			<title>スクリプト</title>
			<p>
				フィールド PatchScript, CompileScript, InstallScript には，実行させたいシェルコマンドを記述できる．
				形式は 2 種類ある．
			</p>
			<p>
				このフィールドには単にコマンドを列挙すれば，シェルスクリプトと同様です．
				しかし，コマンドが一行ごとに system() によって実行される点が異なります．
				よって変数の設定やディレクトリの移動はその行内でのみ有効になります．
				0.18.2 以降の CVS 版 Fink では，
				通常のシェルスクリプトと同様に長い行を改行できます．
				行末にバックスラッシュ (<code>\</code>) を置くと次の行は継続行になります．
			</p>
			<p>
				または，任意のスクリプト処理系の完全なスクリプトを記述することもできます．
				その場合，他の Unix のスクリプトファイルと同様，第1行目は <code>#!</code> にインタプリタのフルパス名を続け，
				さらに必要なフラグを続けたものでなければいけない
				(<code>#!/bin/csh</code>, <code>#!/bin/bash -ev</code> など)．
				その場合，フィールド *Script の値全体が一時ファイルにダンプされ，実行されます．
			</p>
		</section>
		<section name="patches">
			<title>パッチ</title>
			<p>
				パッケージを Darwin でコンパイルするために (または Fink と協調して動作するようにするために) パッチが必要な場合，
				パッチにはパッケージ記述の拡張子 &quot;.info&quot; を &quot;.patch&quot; に変えたファイル名を使い， 
				.info ファイルと同じディレクトリに入れます．
				パッケージファイル名に完全名を使っている場合は，次のどちらかを使います (どちらも同等)．
			</p>

<codeblock>PatchFile: %n.patch</codeblock>
<p>( variant がある場合、
<code>%{ni}.patch</code> の方がよいでしょう。)
また、パッチファイルの MD5 サムを
<code>PatchFile-MD5</code> に指定し、
<code>BuildDepends: fink (&gt;= 0.24.12)</code> (またはより新しい fink バージョン)　を指定しなければなりません。
</p>

<p><code>PatchFile<em>N</em></code>　が使われている場合、
<filename>%n-purpose-of-patch.patch</filename>　というようにわかりやすい名前をつけます。
<code>PatchFile<em>N</em>-MD5</code> も使い、
<code>BuildDepends: fink (&gt;= 0.24.12)</code> (またはより新しい fink バージョン)　を指定しなければなりません。
</p>

<p><code>PatchFile</code> がある場合、 <code>PatchScript</code> のデフォルトは:</p>
<codeblock>PatchScript: patch -p1 &lt; %{PatchFile}</codeblock>
<p><code>PatchFile<em>N</em></code> を使う場合、以下のものが上の <code>PatchScript</code> に追加されます:</p>
<codeblock>patch -p1 &lt; %{PatchFile<em>N</em>}</codeblock>
<p>(パッチファイルを適用する前に書き換えるなど)<code>PatchScript</code> を指定すると、
これらのデフォルトは書き換えられます。
</p>
<p>パッチファイルに、ユーザの選択した prefix を含める必要がある場合、
<code>/sw</code> をパッチで使うのではなく、
<code>@PREFIX@</code> などを使い:</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt; %{PatchFile} | patch -p1</codeblock>
<p>とします。
パッチは unidiff 形式で、以下のように作成します:</p>
<codeblock>diff -urN &lt;originalsourcedir&gt; &lt;patchedsourcedir&gt;</codeblock>
<p>emacs でファイルを編集した場合、
diff コマンドに
<code>-x'*~'</code> 
と追加すると、自動的に生成されるバックアップファイルを除くことができます。</p>
<p>もう一つの注意点は、巨大すぎるパッチを cvs に入れないことです。
ウェブか FTP サーバにおき、<code>SourceN:</code>　フィールドで指定します。
ウェブサイトを持っていない場合、
fink プロジェクトの管理者が fink サイトから提供できるようにします。
パッチが約 30Kb をこえるなら、別々にダウンロードすることを検討してください。
</p>

		</section>
		<section name="profile.d">
			<title>Profile.d スクリプト</title>
			<p>
				パッケージが実行時に何らかの初期化 (環境変数の設定など) を必要とするなら， profile.d スクリプトを使えばよいでしょう．
				これらのスクリプト断片はスクリプト <filename>/sw/bin/init.[c]sh</filename> によって読み込まれます．
				通常，全ての Fink ユーザがシェルのスタートアップファイル (<filename>.cshrc</filename> またはそれと互換なファイル) でそれを読み込むようになっています．
				パッケージの方では，どのスクリプトにも2種類を用意しなければいけません:
				sh 互換シェル (sh, zsh, bash, ksh, ...) 用と， csh 互換シェル (csh, tcsh) 用です．
				両スクリプトとも <filename>/sw/etc/profile.d/%n.[c]sh</filename> としてインストールされる必要があります．
				(ここで %n は，他と同様に「パッケージ名」を表す．)
				また，正しく読み込まれるためには，それらのパーミッションは実行，読み込みが共に可能でなければいけません．
				(すなわち，それらのインストールには引数 <code>-m 755</code> を付ける．)
			</p>
			<p>
				環境変数をいくつか設定したいだけなら (QTDIR を '/sw' にする，など)，フィールド RuntimeVars を使えばよいでしょう．
				このフィールドはまさにその作業を簡略化するために用意されたものです．
			</p>
		</section>
	</chapter>
</document>
